{"version":3,"file":"error-parser.js","names":["errorParser","message","filePath","undefined","location","error","handlers","regex","cb","match","id","context","sourceMessage","variableName","variableType","inputType","expectedType","fieldName","fieldType","field","type","desc","value","received","variable","operation","Error","structured","matched","locInGraphQlToLocInFile","locationOfGraphQLDocInSourceFile","graphqlLocation","line","start","column"],"sources":["../../src/query/error-parser.ts"],"sourcesContent":["import { IMatch } from \"../types\"\nimport { SourceLocation } from \"graphql\"\n\ninterface IErrorParser {\n  message: string\n  filePath: string | undefined\n  location:\n    | {\n        start: SourceLocation\n        end?: SourceLocation\n      }\n    | undefined\n  error?: Error\n}\n\nconst errorParser = ({\n  message,\n  filePath = undefined,\n  location = undefined,\n  error = undefined,\n}: IErrorParser): IMatch => {\n  // Handle GraphQL errors. A list of regexes to match certain\n  // errors to specific callbacks\n  const handlers = [\n    {\n      regex: /Variable \"(.+)\" of required type \"(.+)\" was not provided\\./m,\n      cb: (match): IMatch => {\n        return {\n          id: `85920`,\n          context: {\n            sourceMessage: match[0],\n            variableName: match[1],\n            variableType: match[2],\n          },\n        }\n      },\n    },\n    {\n      regex:\n        /Variable \"(.+)\" of type \"(.+)\" used in position expecting type \"(.+)\"\\./m,\n      cb: (match): IMatch => {\n        return {\n          id: `85921`,\n          context: {\n            sourceMessage: match[0],\n            variableName: match[1],\n            inputType: match[2],\n            expectedType: match[3],\n          },\n        }\n      },\n    },\n    {\n      regex:\n        /Field \"(.+)\" must not have a selection since type \"(.+)\" has no subfields\\./m,\n      cb: (match): IMatch => {\n        return {\n          id: `85922`,\n          context: {\n            sourceMessage: match[0],\n            fieldName: match[1],\n            fieldType: match[2],\n          },\n        }\n      },\n    },\n    {\n      regex: /Cannot query field \"(.+)\" on type \"(.+)\"\\./m,\n      cb: (match): IMatch => {\n        return {\n          id: `85923`,\n          context: {\n            sourceMessage: match[0],\n            field: match[1],\n            type: match[2],\n          },\n        }\n      },\n    },\n    {\n      regex: /(.+) cannot represent (.+) value: \"(.+)\"/m,\n      cb: (match): IMatch => {\n        return {\n          id: `85924`,\n          context: {\n            sourceMessage: match[0],\n            type: match[1],\n            desc: match[2],\n            value: match[3],\n          },\n        }\n      },\n    },\n    {\n      regex: /Cannot return null for non-nullable field (.+)/m,\n      cb: (match): IMatch => {\n        return {\n          id: `85925`,\n          context: {\n            sourceMessage: match[0],\n            field: match[1],\n          },\n        }\n      },\n    },\n    {\n      regex: /Must provide Source\\. Received: (.+)/m,\n      cb: (match): IMatch => {\n        return {\n          id: `85926`,\n          context: {\n            sourceMessage: match[0],\n            received: match[1],\n          },\n        }\n      },\n    },\n    {\n      regex: /Variable \"(.+)\" is never used in operation \"(.+)\".*/ms,\n      cb: (match): IMatch => {\n        return {\n          id: `85927`,\n          context: {\n            sourceMessage: match[0],\n            variable: match[1],\n            operation: match[2],\n          },\n        }\n      },\n    },\n    // Match anything with a generic catch-all error handler\n    {\n      regex: /[\\s\\S]*/gm,\n      cb: (match): IMatch => {\n        if (error instanceof Error) {\n          return {\n            id: `85901`,\n            error, // show stack trace\n            context: { sourceMessage: match[0] },\n          }\n        } else {\n          return {\n            id: `85901`,\n            context: { sourceMessage: match[0] },\n          }\n        }\n      },\n    },\n  ]\n\n  let structured\n\n  for (const { regex, cb } of handlers) {\n    const matched = message?.match(regex)\n    if (matched) {\n      structured = {\n        ...cb(matched),\n        ...{ location },\n        ...{ filePath },\n      }\n      break\n    }\n  }\n\n  return structured\n}\n\nexport default errorParser\n\ninterface ILocOfGraphQLDocInSrcFile {\n  start: SourceLocation\n  end: SourceLocation\n  fileName: boolean\n}\n\nexport const locInGraphQlToLocInFile = (\n  locationOfGraphQLDocInSourceFile: ILocOfGraphQLDocInSrcFile,\n  graphqlLocation: SourceLocation\n): SourceLocation => {\n  return {\n    line:\n      graphqlLocation.line + locationOfGraphQLDocInSourceFile.start.line - 1,\n    column:\n      (graphqlLocation.line === 1\n        ? locationOfGraphQLDocInSourceFile.start.column\n        : 0) + graphqlLocation.column,\n  }\n}\n"],"mappings":"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"}