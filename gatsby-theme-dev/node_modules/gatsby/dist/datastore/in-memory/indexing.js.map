{"version":3,"file":"indexing.js","names":["nodeIdToIdentifierMap","Map","getGatsbyNodePartial","node","indexFields","resolvedFields","cacheKey","id","internal","counter","derefPartial","undefined","has","get","deref","map","field","gatsbyNodePartialInternalData","dottedFields","fieldsToStore","Set","sortFieldIds","getSortFieldIdentifierKeys","fullNodeObject","resolvedNodeFields","dottedField","startsWith","getResolvedFields","getValueAt","slice","length","getNode","partial","Object","assign","type","set","WeakRef","sortByIds","a","b","postIndexingMetaSetup","filterCache","op","bucket","byValue","sort","postIndexingMetaSetupNeNin","includes","postIndexingMetaSetupLtLteGtGte","arr","meta","nodesUnordered","forEach","v","nodeId","push","entriesNullable","entries","filter","orderedNodes","orderedValues","offsets","valuesAsc","nodesByValueAsc","valueRangesAsc","valuesDesc","nodesByValueDesc","valueRangesDesc","ensureIndexByQuery","filterCacheKey","filterPath","nodeTypeNames","filtersCache","getDataStore","iterateNodesByType","addNodeToFilterCache","chain","iterateNodes","ensureEmptyFilterCache","orderedByCounter","valueOffset","i","nextProp","Array","isArray","markNodeForValue","value","ensureIndexByElemMatch","addNodeToBucketWithElemMatch","valueAtCurrentStep","path","nestedQuery","elem","binarySearchAsc","values","needle","min","max","pivot","Math","floor","binarySearchDesc","getNodesFromCacheByValue","filterValue","wasElemMatch","arrNull","arrUndef","unionNodesByCounter","Error","filterValueArr","add","nodes","expensiveDedupeInline","removeBucketFromSet","RegExp","regex","test","String","ranges","range","point","pivotMin","pivotMax","pivotValue","exclPivot","inclPivot","until","reverse","cache","delete","intersectNodesByCounter","pointerA","pointerB","result","maxA","maxB","lastAdded","counterA","counterB","prev","j","objectToDottedField","dottedFieldKeys","keys","fieldKeys","some","key"],"sources":["../../../src/datastore/in-memory/indexing.ts"],"sourcesContent":["import { IGatsbyNode } from \"../../redux/types\"\nimport {\n  IDbQueryElemMatch,\n  FilterValue,\n  FilterValueNullable,\n  objectToDottedField,\n} from \"../common/query\"\nimport { getDataStore, getNode } from \"../\"\nimport _ from \"lodash\"\nimport { getValueAt } from \"../../utils/get-value-at\"\nimport { getResolvedFields } from \"../../schema/utils\"\n\n// Only list supported ops here. \"CacheableFilterOp\"\n// TODO: merge with DbComparator ?\nexport type FilterOp =\n  | \"$eq\"\n  | \"$ne\"\n  | \"$lt\"\n  | \"$lte\"\n  | \"$gt\"\n  | \"$gte\"\n  | \"$in\"\n  | \"$nin\"\n  | \"$regex\" // Note: this includes $glob\n\nexport type FilterCacheKey = string\ntype GatsbyNodeID = string\n\nexport interface IGatsbyNodePartial {\n  id: GatsbyNodeID\n  internal: {\n    type: string\n    counter: number\n  }\n  gatsbyNodePartialInternalData: {\n    indexFields: Set<string>\n  }\n  [k: string]: any\n}\n\nconst nodeIdToIdentifierMap = new Map<\n  GatsbyNodeID,\n  WeakRef<IGatsbyNodePartial>\n>()\n\n/**\n * Grabs an instance of IGatsbyNodePartial for the given node.\n * This accepts an IGatsbyNode or IGatsbyNodePartial as input, which allows\n * us to conditionally store index fields on the partial if we encounter\n * one that hasn't been stored on the partial yet.\n */\nexport const getGatsbyNodePartial = (\n  node: IGatsbyNode | IGatsbyNodePartial,\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>\n): IGatsbyNodePartial => {\n  // first, check if we have the partial in the cache\n  const cacheKey = `${node.id}_____${node.internal.counter}`\n  let derefPartial: IGatsbyNodePartial | undefined = undefined\n  if (nodeIdToIdentifierMap.has(cacheKey)) {\n    derefPartial = nodeIdToIdentifierMap.get(cacheKey)?.deref()\n\n    // now check if we have it in memory and it has all the fields we need\n    if (\n      derefPartial &&\n      _.every(\n        indexFields.map(field =>\n          derefPartial!.gatsbyNodePartialInternalData.indexFields.has(field)\n        )\n      )\n    ) {\n      return derefPartial\n    }\n  }\n\n  // find all the keys of fields and store them and their values on the partial\n  // if we've already passed this partial, merge both sets of index fields\n  const dottedFields = {}\n  const fieldsToStore = derefPartial\n    ? new Set([\n        ...derefPartial.gatsbyNodePartialInternalData.indexFields,\n        ...indexFields,\n      ])\n    : new Set(indexFields)\n\n  const sortFieldIds = getSortFieldIdentifierKeys(\n    [...fieldsToStore],\n    resolvedFields\n  )\n  let fullNodeObject: IGatsbyNode | undefined =\n    node.gatsbyNodePartialInternalData ? undefined : (node as IGatsbyNode)\n  let resolvedNodeFields\n\n  for (const dottedField of sortFieldIds) {\n    if (dottedField in node) {\n      dottedFields[dottedField] = node[dottedField]\n    } else {\n      if (dottedField.startsWith(`__gatsby_resolved.`)) {\n        if (!resolvedNodeFields) {\n          resolvedNodeFields = getResolvedFields(node)\n        }\n\n        dottedFields[dottedField] = getValueAt(\n          resolvedNodeFields,\n          dottedField.slice(`__gatsby_resolved.`.length)\n        )\n      } else {\n        // if we haven't gotten the full node object, fetch it once\n        // use the full node object to fetch the value\n        if (!fullNodeObject) {\n          fullNodeObject = getNode(node.id)!\n        }\n        dottedFields[dottedField] = getValueAt(fullNodeObject, dottedField)\n      }\n    }\n  }\n\n  // create the partial object\n  const partial = Object.assign(dottedFields, {\n    id: node.id,\n    internal: {\n      counter: node.internal.counter,\n      type: node.internal.type,\n    },\n    gatsbyNodePartialInternalData: {\n      indexFields: fieldsToStore,\n    },\n  })\n\n  // set the object in the cache for later fetching\n  nodeIdToIdentifierMap.set(cacheKey, new WeakRef<IGatsbyNodePartial>(partial))\n\n  return partial\n}\n\nconst sortByIds = (a: IGatsbyNodePartial, b: IGatsbyNodePartial): number =>\n  a.internal.counter - b.internal.counter\n\nexport interface IFilterCache {\n  op: FilterOp\n  // In this map `undefined` values represent nodes that did not have the path\n  // The individual arrays are ordered asc by internal.counter which will\n  // preserve insertion order and guarantee uniqueness and it's a number so our\n  // .sort() calls can subtract one from the other which is nice :)\n  // This arrays may contain duplicates (!) because those only get filtered in the\n  // last step.\n  // TODO: We might decide to make sure these buckets _are_ deduped for eq perf\n  byValue: Map<FilterValueNullable, Array<IGatsbyNodePartial>>\n  meta: {\n    // Used by ne/nin, which will create a Set from this array and then remove another set(s) and sort\n    nodesUnordered?: Array<IGatsbyNodePartial>\n    // Flat list of all nodes by requested types, ordered by counter (cached for empty filters)\n    orderedByCounter?: Array<IGatsbyNodePartial>\n    // Ordered list of all values (by `<`) found by this filter. No null / undefs\n    valuesAsc?: Array<FilterValue>\n    // Flat list of nodes, ordered by valueAsc\n    nodesByValueAsc?: Array<IGatsbyNodePartial>\n    // Ranges of nodes per value, maps to the nodesByValueAsc array\n    valueRangesAsc?: Map<FilterValue, [number, number]>\n    // Ordered list of all values (by `>`) found by this filter. No null / undefs\n    valuesDesc?: Array<FilterValue>\n    // Flat list of nodes, ordered by valueDesc\n    nodesByValueDesc?: Array<IGatsbyNodePartial>\n    // Ranges of nodes per value, maps to the nodesByValueDesc array\n    valueRangesDesc?: Map<FilterValue, [number, number]>\n  }\n}\nexport type FiltersCache = Map<FilterCacheKey, IFilterCache>\n\nexport function postIndexingMetaSetup(\n  filterCache: IFilterCache,\n  op: FilterOp\n): void {\n  // Loop through byValue and make sure the buckets are sorted by counter\n  // Since we don't do insertion sort, we have to do it afterwards\n  for (const bucket of filterCache.byValue) {\n    bucket[1].sort(sortByIds)\n  }\n\n  if (op === `$ne` || op === `$nin`) {\n    postIndexingMetaSetupNeNin(filterCache)\n  } else if ([`$lt`, `$lte`, `$gt`, `$gte`].includes(op)) {\n    postIndexingMetaSetupLtLteGtGte(filterCache, op)\n  }\n}\n\nfunction postIndexingMetaSetupNeNin(filterCache: IFilterCache): void {\n  // Note: edge cases regarding `null` and `undefined`. Here `undefined` signals\n  // that the property did not exist as the filters do not support actual\n  // `undefined` values.\n  // For $ne, `null` only returns nodes that actually have the property\n  // and in that case the property cannot be `null` either. For any other value,\n  // $ne will return all nodes where the value is not actually the needle,\n  // including nodes where the value is null.\n  // A $nin does the same as an $ne except it filters multiple values instead\n  // of just one.\n  // For `$ne` we will take the list of all targeted nodes and eliminate the\n  // bucket of nodes with a particular value, if it exists at all..\n\n  const arr: Array<IGatsbyNodePartial> = []\n  filterCache.meta.nodesUnordered = arr\n  filterCache.byValue.forEach(v => {\n    v.forEach(nodeId => {\n      arr.push(nodeId)\n    })\n  })\n}\n\nfunction postIndexingMetaSetupLtLteGtGte(\n  filterCache: IFilterCache,\n  op: FilterOp\n): void {\n  // Create an ordered array of individual nodes, ordered (grouped) by the\n  // value to which the filter resolves. Nodes per value are ordered by\n  // internal.counter, asc.\n  // This way non-eq ops can simply slice the array to get a range.\n\n  const entriesNullable: Array<\n    [FilterValueNullable, Array<IGatsbyNodePartial>]\n  > = [...filterCache.byValue.entries()]\n\n  // These range checks never return `null` or `undefined` so filter those out\n  // By filtering them out early, the sort should be faster. Could be ...\n  const entries: Array<[FilterValue, Array<IGatsbyNodePartial>]> =\n    entriesNullable.filter(([v]) => v != null) as Array<\n      [FilterValue, Array<IGatsbyNodePartial>]\n    >\n\n  // Sort all arrays by its value, asc. Ignore/allow potential type casting.\n  // Note: while `<` is the inverse of `>=`, the ordering might coerce values.\n  // This coercion makes the op no longer idempotent (normally the result of\n  // `a < b` is the opposite of `b >= a` for any a or b of the same type). The\n  // exception is a number that is `NaN`, which we're ignoring here as it's most\n  // likely a bug in the user code. However, when coercing the ops may end up\n  // comparing against `NaN`, too. For example: `(\"abc\" <= 12) !== (12 > \"abc\")`\n  // which ends up doing `NaN <= 12` and `NaN > \"abc\"`, which will both yield\n  // false.\n  // So instead we potentially track two ordered lists; ascending and descending\n  // and the only difference when comparing the inverse of one to the other\n  // should be how these `NaN` cases end up getting ordered.\n  // It's fine for `lt` and `lte` to use the same ordered list. Same for gt/gte.\n  if (op === `$lt` || op === `$lte`) {\n    // Order ascending; first value is lowest\n    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))\n  } else if (op === `$gt` || op === `$gte`) {\n    // Order descending; first value is highest\n    entries.sort(([a], [b]) => (a > b ? -1 : a < b ? 1 : 0))\n  }\n\n  const orderedNodes: Array<IGatsbyNodePartial> = []\n  const orderedValues: Array<FilterValue> = []\n  const offsets: Map<FilterValue, [number, number]> = new Map()\n  entries.forEach(([v, bucket]: [FilterValue, Array<IGatsbyNodePartial>]) => {\n    // Record the range containing all nodes with as filter value v\n    // The last value of the range should be the offset of the next value\n    // (So you should be able to do `nodes.slice(start, stop)` to get them)\n    offsets.set(v, [orderedNodes.length, orderedNodes.length + bucket.length])\n    // We could do `arr.push(...bucket)` here but that's not safe with very\n    // large sets, so we use a regular loop\n    bucket.forEach(node => orderedNodes.push(node))\n    orderedValues.push(v)\n  })\n\n  if (op === `$lt` || op === `$lte`) {\n    filterCache.meta.valuesAsc = orderedValues\n    filterCache.meta.nodesByValueAsc = orderedNodes\n    // The nodesByValueAsc is ordered by value, but multiple nodes per value are\n    // not ordered. To make lt as fast as lte, we must know the start and stop\n    // index for each value. Similarly useful for for `ne`.\n    filterCache.meta.valueRangesAsc = offsets\n  } else if (op === `$gt` || op === `$gte`) {\n    filterCache.meta.valuesDesc = orderedValues\n    filterCache.meta.nodesByValueDesc = orderedNodes\n    // The nodesByValueDesc is ordered by value, but multiple nodes per value are\n    // not ordered. To make gt as fast as gte, we must know the start and stop\n    // index for each value. Similarly useful for for `ne`.\n    filterCache.meta.valueRangesDesc = offsets\n  }\n}\n\n/**\n * Given a single non-elemMatch filter path, a list of node types, and a\n * cache, create a cache that for each resulting value of the filter contains\n * all the Nodes in a list.\n * This cache is used for applying the filter and is a massive improvement over\n * looping over all the nodes, when the number of pages (/nodes) scales up.\n */\nexport const ensureIndexByQuery = (\n  op: FilterOp,\n  filterCacheKey: FilterCacheKey,\n  filterPath: Array<string>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>\n): void => {\n  const filterCache: IFilterCache = {\n    op,\n    byValue: new Map<FilterValueNullable, Array<IGatsbyNodePartial>>(),\n    meta: {},\n  } as IFilterCache\n  filtersCache.set(filterCacheKey, filterCache)\n\n  // We cache the subsets of nodes by type, but only one type. So if searching\n  // through one node type we can prevent a search through all nodes, otherwise\n  // it's probably faster to loop through all nodes. Perhaps. Maybe.\n\n  if (nodeTypeNames.length === 1) {\n    getDataStore()\n      .iterateNodesByType(nodeTypeNames[0])\n      .forEach(node => {\n        addNodeToFilterCache({\n          node,\n          chain: filterPath,\n          filterCache,\n          indexFields,\n          resolvedFields,\n        })\n      })\n  } else {\n    // Here we must first filter for the node type\n    // This loop is expensive at scale (!)\n    getDataStore()\n      .iterateNodes()\n      .forEach(node => {\n        if (!nodeTypeNames.includes(node.internal.type)) {\n          return\n        }\n\n        addNodeToFilterCache({\n          node,\n          chain: filterPath,\n          filterCache,\n          indexFields,\n          resolvedFields,\n        })\n      })\n  }\n\n  postIndexingMetaSetup(filterCache, op)\n}\n\nexport function ensureEmptyFilterCache(\n  filterCacheKey,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>\n): void {\n  // This is called for queries without any filters\n  // We want to cache the result since it's basically a list of nodes by type(s)\n  // There are sites that have multiple queries which are empty\n\n  const orderedByCounter: Array<IGatsbyNodePartial> = []\n\n  filtersCache.set(filterCacheKey, {\n    op: `$eq`, // Ignore.\n    byValue: new Map<FilterValueNullable, Array<IGatsbyNodePartial>>(),\n    meta: {\n      orderedByCounter, // This is what we want\n    },\n  })\n\n  if (nodeTypeNames.length === 1) {\n    getDataStore()\n      .iterateNodesByType(nodeTypeNames[0])\n      .forEach(node => {\n        orderedByCounter.push(\n          getGatsbyNodePartial(node, indexFields, resolvedFields)\n        )\n      })\n  } else {\n    // Here we must first filter for the node type\n    // This loop is expensive at scale (!)\n    getDataStore()\n      .iterateNodes()\n      .forEach(node => {\n        if (nodeTypeNames.includes(node.internal.type)) {\n          orderedByCounter.push(\n            getGatsbyNodePartial(node, indexFields, resolvedFields)\n          )\n        }\n      })\n  }\n\n  // Since each node can only have one type, we shouldn't have to be concerned\n  // about duplicates in this array. Just make sure they're sorted.\n  orderedByCounter.sort(sortByIds)\n}\n\nfunction addNodeToFilterCache({\n  node,\n  chain,\n  filterCache,\n  indexFields,\n  resolvedFields,\n  valueOffset = node,\n}: {\n  node: IGatsbyNode\n  chain: Array<string>\n  filterCache: IFilterCache\n  indexFields: Array<string>\n  resolvedFields: Record<string, any>\n  valueOffset?: any\n}): void {\n  // - for plain query, valueOffset === node\n  // - for elemMatch, valueOffset is sub-tree of the node to continue matching\n  let v = valueOffset as any\n  let i = 0\n  while (i < chain.length && v) {\n    const nextProp = chain[i++]\n    if (i === 1 && nextProp === `__gatsby_resolved`) {\n      v = getResolvedFields(v)\n    } else {\n      v = v[nextProp]\n    }\n  }\n\n  if (\n    (typeof v !== `string` &&\n      typeof v !== `number` &&\n      typeof v !== `boolean` &&\n      v !== null) ||\n    i !== chain.length\n  ) {\n    if (i === chain.length && Array.isArray(v)) {\n      // The op resolved to an array\n      // Add an entry for each element of the array. This would work for ops\n      // like eq and ne, but not sure about range ops like lt,lte,gt,gte.\n\n      v.forEach(v =>\n        markNodeForValue(filterCache, node, v, indexFields, resolvedFields)\n      )\n\n      return\n    }\n\n    // This means that either\n    // - The filter resolved to `undefined`, or\n    // - The filter resolved to something other than a primitive\n    // Set the value to `undefined` to mark \"path does not (fully) exist\"\n    v = undefined\n  }\n\n  markNodeForValue(filterCache, node, v, indexFields, resolvedFields)\n}\n\nfunction markNodeForValue(\n  filterCache: IFilterCache,\n  node: IGatsbyNode,\n  value: FilterValueNullable,\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>\n): void {\n  let arr = filterCache.byValue.get(value)\n  if (!arr) {\n    arr = []\n    filterCache.byValue.set(value, arr)\n  }\n\n  const partial = getGatsbyNodePartial(node, indexFields, resolvedFields)\n  if (!arr.includes(partial)) {\n    arr.push(partial)\n  }\n}\n\nexport const ensureIndexByElemMatch = (\n  op: FilterOp,\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryElemMatch,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>\n): void => {\n  // Given an elemMatch filter, generate the cache that contains all nodes that\n  // matches a given value for that sub-query\n\n  const filterCache: IFilterCache = {\n    op,\n    byValue: new Map<FilterValueNullable, Array<IGatsbyNodePartial>>(),\n    meta: {},\n  } as IFilterCache\n  filtersCache.set(filterCacheKey, filterCache)\n\n  if (nodeTypeNames.length === 1) {\n    getDataStore()\n      .iterateNodesByType(nodeTypeNames[0])\n      .forEach(node => {\n        addNodeToBucketWithElemMatch({\n          node,\n          valueAtCurrentStep: node,\n          filter,\n          filterCache,\n          indexFields,\n          resolvedFields,\n        })\n      })\n  } else {\n    // Expensive at scale\n    getDataStore()\n      .iterateNodes()\n      .forEach(node => {\n        if (!nodeTypeNames.includes(node.internal.type)) {\n          return\n        }\n\n        addNodeToBucketWithElemMatch({\n          node,\n          valueAtCurrentStep: node,\n          filter,\n          filterCache,\n          indexFields,\n          resolvedFields,\n        })\n      })\n  }\n\n  postIndexingMetaSetup(filterCache, op)\n}\n\nfunction addNodeToBucketWithElemMatch({\n  node,\n  valueAtCurrentStep, // Arbitrary step on the path inside the node\n  filter,\n  filterCache,\n  indexFields,\n  resolvedFields,\n}: {\n  node: IGatsbyNode\n  valueAtCurrentStep: any // Arbitrary step on the path inside the node\n  filter: IDbQueryElemMatch\n  filterCache: IFilterCache\n  indexFields: Array<string>\n  resolvedFields: Record<string, any>\n}): void {\n  const { path, nestedQuery } = filter\n\n  // Find the value to apply elemMatch to\n  let i = 0\n  while (i < path.length && valueAtCurrentStep) {\n    const nextProp = path[i++]\n    if (i === 1 && nextProp === `__gatsby_resolved`) {\n      valueAtCurrentStep = getResolvedFields(valueAtCurrentStep)\n    } else {\n      valueAtCurrentStep = valueAtCurrentStep[nextProp]\n    }\n  }\n\n  if (path.length !== i) {\n    // Found undefined before the end of the path\n    return\n  }\n\n  // `v` should now be an elemMatch target, probably an array (but maybe not)\n  if (!Array.isArray(valueAtCurrentStep)) {\n    // It's possible to `elemMatch` on a non-array so let's support that too\n    valueAtCurrentStep = [valueAtCurrentStep]\n  }\n\n  // Note: We need to check all elements because the node may need to be added\n  // to multiple buckets (`{a:[{b:3},{b:4}]}`, for `a.elemMatch.b/eq` that\n  // node ends up in buckets for value 3 and 4. This may lead to duplicate\n  // work when elements resolve to the same value, but that can't be helped.\n  valueAtCurrentStep.forEach(elem => {\n    if (nestedQuery.type === `elemMatch`) {\n      addNodeToBucketWithElemMatch({\n        node,\n        valueAtCurrentStep: elem,\n        filter: nestedQuery,\n        filterCache,\n        indexFields,\n        resolvedFields,\n      })\n    } else {\n      // Now take same route as non-elemMatch filters would take\n      addNodeToFilterCache({\n        node,\n        chain: nestedQuery.path,\n        filterCache,\n        indexFields,\n        resolvedFields,\n        valueOffset: elem,\n      })\n    }\n  })\n}\n\nconst binarySearchAsc = (\n  values: Array<FilterValue>, // Assume ordered asc\n  needle: FilterValue\n): [number, number] | undefined => {\n  let min = 0\n  let max = values.length - 1\n  let pivot = Math.floor(values.length / 2)\n  while (min <= max) {\n    const value = values[pivot]\n    if (needle < value) {\n      // Move pivot to middle of nodes left of current pivot\n      // assert pivot < max\n      max = pivot\n    } else if (needle > value) {\n      // Move pivot to middle of nodes right of current pivot\n      // assert pivot > min\n      min = pivot\n    } else {\n      // This means needle === value\n      // TODO: except for NaN ... and potentially certain type casting cases\n      return [pivot, pivot]\n    }\n\n    if (max - min <= 1) {\n      // End of search. Needle not found (as expected). Use pivot as index.\n      // If the needle was not found, max-min==1 and max is returned.\n      return [min, max]\n    }\n\n    pivot = min + Math.floor((max - min) / 2)\n  }\n\n  // Shouldn't be reachable\n  return undefined\n}\nconst binarySearchDesc = (\n  values: Array<FilterValue>, // Assume ordered desc\n  needle: FilterValue\n): [number, number] | undefined => {\n  let min = 0\n  let max = values.length - 1\n  let pivot = Math.floor(values.length / 2)\n  while (min <= max) {\n    const value = values[pivot]\n    if (needle < value) {\n      // Move pivot to middle of nodes right of current pivot\n      // assert pivot < min\n      min = pivot\n    } else if (needle > value) {\n      // Move pivot to middle of nodes left of current pivot\n      // assert pivot > max\n      max = pivot\n    } else {\n      // This means needle === value\n      // TODO: except for NaN ... and potentially certain type casting cases\n      return [pivot, pivot]\n    }\n\n    if (max - min <= 1) {\n      // End of search. Needle not found (as expected). Use pivot as index.\n      // If the needle was not found, max-min==1 and max is returned.\n      return [min, max]\n    }\n\n    pivot = min + Math.floor((max - min) / 2)\n  }\n\n  // Shouldn't be reachable\n  return undefined\n}\n\n/**\n * Given the cache key for a filter and a target value return the list of nodes\n * that resolve to this value. The returned array should be ordered by id.\n * This returns `undefined` if there is no such node\n *\n * Basically if the filter was {a: {b: {slug: {eq: \"foo/bar\"}}}} then it will\n * return all the nodes that have `node.slug === \"foo/bar\"`. That usually (but\n * not always) at most one node for slug, but this filter can apply to anything.\n *\n * Arrays returned by this function must be ordered by internal.counter and\n * not contain duplicate nodes (!)\n */\nexport const getNodesFromCacheByValue = (\n  filterCacheKey: FilterCacheKey,\n  filterValue: FilterValueNullable,\n  filtersCache: FiltersCache,\n  wasElemMatch\n): Array<IGatsbyNodePartial> | undefined => {\n  const filterCache = filtersCache.get(filterCacheKey)\n  if (!filterCache) {\n    return undefined\n  }\n\n  const op = filterCache.op\n\n  if (op === `$eq`) {\n    // Arrays in byValue are assumed to be ordered by counter\n\n    if (filterValue == null) {\n      // Edge case for null; fetch all nodes for `null` and `undefined` because\n      // `$eq` also returns nodes without the path when searching for `null`.\n      // Not all ops do so, so we map non-existing paths to `undefined`.\n\n      const arrNull = filterCache.byValue.get(null) ?? []\n      const arrUndef = filterCache.byValue.get(undefined) ?? []\n\n      // Merge the two (ordered) arrays and return an ordered deduped array\n      // TODO: is there a reason left why we cant just cache this merged list?\n      return unionNodesByCounter(arrNull, arrUndef)\n    }\n\n    return filterCache.byValue.get(filterValue)\n  }\n\n  if (op === `$in`) {\n    if (!Array.isArray(filterValue)) {\n      throw new Error(\"The argument to the `in` comparator should be an array\")\n    }\n    const filterValueArr: Array<FilterValueNullable> = filterValue\n\n    const set: Set<IGatsbyNodePartial> = new Set()\n\n    // TODO: we can also mergeSort for every step. this may perform worse because of how memory in js works.\n    // For every value in the needle array, find the bucket of nodes for\n    // that value, add this bucket of nodes to one list, return the list.\n    filterValueArr.forEach((v: FilterValueNullable) =>\n      filterCache.byValue.get(v)?.forEach(v => set.add(v))\n    )\n\n    const arr = [...set] // this is bad for perf but will guarantee us a unique set :(\n    arr.sort(sortByIds)\n\n    // Note: it's very unlikely that the list of filter values is big so .includes should be fine here\n    if (filterValueArr.includes(null)) {\n      // Like all other ops, `in: [null]` behaves weirdly, allowing all nodes\n      // that do not actually have a (complete) path (v=undefined)\n      const nodes = filterCache.byValue.get(undefined)\n      if (nodes) {\n        // This will also dedupe so don't do that immediately\n        return unionNodesByCounter(nodes, arr)\n      }\n    }\n\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe first\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n\n    return arr\n  }\n\n  if (op === `$nin`) {\n    // This is essentially the same as the $ne operator, just with multiple\n    // values to exclude.\n\n    if (!Array.isArray(filterValue)) {\n      throw new Error(`The $nin operator expects an array as value`)\n    }\n\n    const values: Set<FilterValueNullable> = new Set(filterValue)\n    const set = new Set(filterCache.meta.nodesUnordered)\n\n    // Do the action for \"$ne\" for each element in the set of values\n    values.forEach(filterValue => {\n      removeBucketFromSet(filterValue, filterCache, set)\n    })\n\n    // TODO: there's probably a more efficient algorithm to do set\n    //       subtraction in such a way that we don't have to re-sort\n    return [...set].sort(sortByIds)\n  }\n\n  if (op === `$ne`) {\n    const set = new Set(filterCache.meta.nodesUnordered)\n\n    removeBucketFromSet(filterValue, filterCache, set)\n\n    // TODO: there's probably a more efficient algorithm to do set\n    //       subtraction in such a way that we don't have to resort here\n    return [...set].sort(sortByIds)\n  }\n\n  if (op === `$regex`) {\n    // Note: $glob is converted to $regex so $glob filters go through here, too\n    // Aside from the input pattern format, further behavior is exactly the same.\n\n    // The input to the filter must be a string (including leading/trailing slash and regex flags)\n    // By the time the filter reaches this point, the filterValue has to be a regex.\n\n    if (!(filterValue instanceof RegExp)) {\n      throw new Error(\n        `The value for the $regex comparator must be an instance of RegExp`\n      )\n    }\n    const regex = filterValue\n\n    const arr: Array<IGatsbyNodePartial> = []\n    filterCache.byValue.forEach((nodes, value) => {\n      // TODO: does the value have to be a string for $regex? Can we auto-ignore any non-strings? Or does it coerce.\n      // Note: for legacy reasons partial paths should also be included for regex\n      if (value !== undefined && regex.test(String(value))) {\n        nodes.forEach(node => arr.push(node))\n      }\n    })\n\n    // TODO: we _can_ cache this list as well. Might make sense if it turns out that $regex is mostly used with literals\n    // TODO: it may make sense to first collect all buckets and then to .concat them, or merge sort them\n\n    arr.sort(sortByIds)\n\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n\n    return arr\n  }\n\n  if (filterValue == null) {\n    if (op === `$lt` || op === `$gt`) {\n      // Nothing is lt/gt null\n      return undefined\n    }\n\n    // This is an edge case and this value should be directly indexed\n    // For `lte`/`gte` this should only return nodes for `null`, not a \"range\"\n    return filterCache.byValue.get(filterValue)\n  }\n\n  if (Array.isArray(filterValue)) {\n    throw new Error(\n      \"Array is an invalid filter value for the `\" + op + \"` comparator\"\n    )\n  }\n\n  if (filterValue instanceof RegExp) {\n    // This is most likely an internal error, although it is possible for\n    // users to talk to this API more directly.\n    throw new Error(\n      `A RegExp instance is only valid for $regex and $glob comparators`\n    )\n  }\n\n  if (op === `$lt`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesAsc\n    const nodes = filterCache.meta.nodesByValueAsc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      const arr = nodes!.slice(0, range[0])\n      arr.sort(sortByIds)\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr)\n      }\n      return arr\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for lte, the valueAsc array must be list at this point\n    const values = filterCache.meta.valuesAsc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchAsc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do lte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue > filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 <= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue < filterValue ? inclPivot : exclPivot\n    const arr = nodes!.slice(0, until)\n    arr.sort(sortByIds)\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n    return arr\n  }\n\n  if (op === `$lte`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesAsc\n    const nodes = filterCache.meta.nodesByValueAsc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      const arr = nodes!.slice(0, range[1])\n      arr.sort(sortByIds)\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr)\n      }\n      return arr\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for lte, the valueAsc array must be list at this point\n    const values = filterCache.meta.valuesAsc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchAsc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do lte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue > filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 <= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue <= filterValue ? inclPivot : exclPivot\n    const arr = nodes!.slice(0, until)\n    arr.sort(sortByIds)\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n    return arr\n  }\n\n  if (op === `$gt`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesDesc\n    const nodes = filterCache.meta.nodesByValueDesc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      const arr = nodes!.slice(0, range[0]).reverse()\n      arr.sort(sortByIds)\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr)\n      }\n      return arr\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for gte, the valueDesc array must be list at this point\n    const values = filterCache.meta.valuesDesc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchDesc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do gte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue < filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 >= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue > filterValue ? inclPivot : exclPivot\n    const arr = nodes!.slice(0, until).reverse()\n    arr.sort(sortByIds)\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n    return arr\n  }\n\n  if (op === `$gte`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesDesc\n    const nodes = filterCache.meta.nodesByValueDesc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      const arr = nodes!.slice(0, range[1]).reverse()\n      arr.sort(sortByIds)\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr)\n      }\n      return arr\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for gte, the valueDesc array must be list at this point\n    const values = filterCache.meta.valuesDesc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchDesc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do gte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue < filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 >= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue >= filterValue ? inclPivot : exclPivot\n    const arr = nodes!.slice(0, until).reverse()\n    arr.sort(sortByIds)\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n    return arr\n  }\n\n  // Unreachable because we checked all values of FilterOp (which op is)\n  return undefined\n}\n\nfunction removeBucketFromSet(\n  filterValue: FilterValueNullable,\n  filterCache: IFilterCache,\n  set: Set<IGatsbyNodePartial>\n): void {\n  if (filterValue === null) {\n    // Edge case: $ne with `null` returns only the nodes that contain the full\n    // path and that don't resolve to null, so drop `undefined` as well.\n    let cache = filterCache.byValue.get(undefined)\n    if (cache) cache.forEach(node => set.delete(node))\n    cache = filterCache.byValue.get(null)\n    if (cache) cache.forEach(node => set.delete(node))\n  } else {\n    // Not excluding null so it should include undefined leafs or leafs where\n    // only the partial path exists for whatever reason.\n    const cache = filterCache.byValue.get(filterValue)\n    if (cache) cache.forEach(node => set.delete(node))\n  }\n}\n\n/**\n * Finds the intersection of two arrays in O(n) with n = min(a.length, b.length)\n * The returned set should not contain duplicate nodes.\n *\n * The input should be ordered by node.internal.counter and it will return a\n * list that is also ordered by node.internal.counter\n */\nexport function intersectNodesByCounter(\n  a: Array<IGatsbyNodePartial>,\n  b: Array<IGatsbyNodePartial>\n): Array<IGatsbyNodePartial> {\n  let pointerA = 0\n  let pointerB = 0\n  // TODO: perf check: is it helpful to init the array to min(maxA,maxB) items?\n  const result: Array<IGatsbyNodePartial> = []\n  const maxA = a.length\n  const maxB = b.length\n  let lastAdded: IGatsbyNodePartial | undefined = undefined // Used to dedupe the list\n\n  while (pointerA < maxA && pointerB < maxB) {\n    const counterA = a[pointerA].internal.counter\n    const counterB = b[pointerB].internal.counter\n\n    if (counterA < counterB) {\n      pointerA++\n    } else if (counterA > counterB) {\n      pointerB++\n    } else {\n      if (a[pointerA].id !== b[pointerB].id) {\n        throw new Error(\n          `Invariant violation: inconsistent node counters detected`\n        )\n      }\n      // nodeA===nodeB. Make sure we didn't just add this node already.\n      // Since input arrays are sorted, the same node should be grouped\n      // back to back, so even if both input arrays contained the same node\n      // twice, this check would prevent the result from getting duplicate nodes\n      if (lastAdded !== a[pointerA]) {\n        result.push(a[pointerA])\n        lastAdded = a[pointerA]\n      }\n      pointerA++\n      pointerB++\n    }\n  }\n\n  return result\n}\n\n/**\n * Merge two lists of nodes.\n * The returned set should not contain duplicate nodes.\n *\n * The input should be ordered by node.internal.counter and it will return a\n * list that is also ordered by node.internal.counter\n */\nexport function unionNodesByCounter(\n  a: Array<IGatsbyNodePartial>,\n  b: Array<IGatsbyNodePartial>\n): Array<IGatsbyNodePartial> {\n  // TODO: perf check: is it helpful to init the array to max(maxA,maxB) items?\n  const arr: Array<IGatsbyNodePartial> = []\n  let lastAdded: IGatsbyNodePartial | undefined = undefined // Used to dedupe the list\n\n  let pointerA = 0\n  let pointerB = 0\n  const maxA = a.length\n  const maxB = b.length\n\n  while (pointerA < maxA && pointerB < maxB) {\n    const counterA = a[pointerA].internal.counter\n    const counterB = b[pointerB].internal.counter\n\n    if (counterA < counterB) {\n      if (lastAdded !== a[pointerA]) {\n        arr.push(a[pointerA])\n        lastAdded = a[pointerA]\n      }\n      pointerA++\n    } else if (counterA > counterB) {\n      if (lastAdded !== b[pointerB]) {\n        arr.push(b[pointerB])\n        lastAdded = b[pointerB]\n      }\n      pointerB++\n    } else {\n      if (lastAdded !== a[pointerA]) {\n        arr.push(a[pointerA])\n        lastAdded = a[pointerA]\n      }\n      pointerA++\n      pointerB++\n    }\n  }\n\n  while (pointerA < maxA) {\n    if (lastAdded !== a[pointerA]) {\n      arr.push(a[pointerA])\n      lastAdded = a[pointerA]\n    }\n    pointerA++\n  }\n\n  while (pointerB < maxB) {\n    if (lastAdded !== b[pointerB]) {\n      arr.push(b[pointerB])\n      lastAdded = b[pointerB]\n    }\n    pointerB++\n  }\n\n  return arr\n}\n\nfunction expensiveDedupeInline(arr: Array<IGatsbyNodePartial>): void {\n  // An elemMatch filter may cause duplicates to appear in a bucket.\n  // Since the bucket is sorted those should now be back to back\n  // Worst case this is a fast O(n) loop that does nothing.\n  let prev: IGatsbyNodePartial | undefined = undefined\n\n  // We copy-on-find because a splice is expensive and we can't use Sets\n\n  let j = 0\n  for (let i = 0; i < arr.length; ++i) {\n    const node = arr[i]\n    if (node !== prev) {\n      // Only start copying the remainder of the list once a dupe is found\n      if (i !== j) {\n        arr[j] = node\n      }\n      ++j\n      prev = node\n    }\n  }\n  arr.length = j\n}\n\nexport function getSortFieldIdentifierKeys(\n  indexFields: Array<string>,\n  resolvedFields: Record<string, any>\n): Array<string> {\n  const dottedFields = objectToDottedField(resolvedFields)\n  const dottedFieldKeys = Object.keys(dottedFields)\n  const fieldKeys = indexFields.map(field => {\n    if (\n      dottedFields[field] ||\n      dottedFieldKeys.some(key => field.startsWith(key))\n    ) {\n      return `__gatsby_resolved.${field}`\n    } else {\n      return field\n    }\n  })\n\n  return fieldKeys\n}\n"],"mappings":";;;;;;;;;;;;;;AACA;;AAMA;;AAEA;;AACA;;AA8BA,MAAMA,qBAAqB,GAAG,IAAIC,GAAJ,EAA9B;AAKA;AACA;AACA;AACA;AACA;AACA;;AACO,MAAMC,oBAAoB,GAAG,CAClCC,IADkC,EAElCC,WAFkC,EAGlCC,cAHkC,KAIX;EACvB;EACA,MAAMC,QAAQ,GAAI,GAAEH,IAAI,CAACI,EAAG,QAAOJ,IAAI,CAACK,QAAL,CAAcC,OAAQ,EAAzD;EACA,IAAIC,YAA4C,GAAGC,SAAnD;;EACA,IAAIX,qBAAqB,CAACY,GAAtB,CAA0BN,QAA1B,CAAJ,EAAyC;IAAA;;IACvCI,YAAY,4BAAGV,qBAAqB,CAACa,GAAtB,CAA0BP,QAA1B,CAAH,0DAAG,sBAAqCQ,KAArC,EAAf,CADuC,CAGvC;;IACA,IACEJ,YAAY,IACZ,qBACEN,WAAW,CAACW,GAAZ,CAAgBC,KAAK,IACnBN,YAAY,CAAEO,6BAAd,CAA4Cb,WAA5C,CAAwDQ,GAAxD,CAA4DI,KAA5D,CADF,CADF,CAFF,EAOE;MACA,OAAON,YAAP;IACD;EACF,CAlBsB,CAoBvB;EACA;;;EACA,MAAMQ,YAAY,GAAG,EAArB;EACA,MAAMC,aAAa,GAAGT,YAAY,GAC9B,IAAIU,GAAJ,CAAQ,CACN,GAAGV,YAAY,CAACO,6BAAb,CAA2Cb,WADxC,EAEN,GAAGA,WAFG,CAAR,CAD8B,GAK9B,IAAIgB,GAAJ,CAAQhB,WAAR,CALJ;EAOA,MAAMiB,YAAY,GAAGC,0BAA0B,CAC7C,CAAC,GAAGH,aAAJ,CAD6C,EAE7Cd,cAF6C,CAA/C;EAIA,IAAIkB,cAAuC,GACzCpB,IAAI,CAACc,6BAAL,GAAqCN,SAArC,GAAkDR,IADpD;EAEA,IAAIqB,kBAAJ;;EAEA,KAAK,MAAMC,WAAX,IAA0BJ,YAA1B,EAAwC;IACtC,IAAII,WAAW,IAAItB,IAAnB,EAAyB;MACvBe,YAAY,CAACO,WAAD,CAAZ,GAA4BtB,IAAI,CAACsB,WAAD,CAAhC;IACD,CAFD,MAEO;MACL,IAAIA,WAAW,CAACC,UAAZ,CAAwB,oBAAxB,CAAJ,EAAkD;QAChD,IAAI,CAACF,kBAAL,EAAyB;UACvBA,kBAAkB,GAAG,IAAAG,wBAAA,EAAkBxB,IAAlB,CAArB;QACD;;QAEDe,YAAY,CAACO,WAAD,CAAZ,GAA4B,IAAAG,sBAAA,EAC1BJ,kBAD0B,EAE1BC,WAAW,CAACI,KAAZ,CAAmB,oBAAD,CAAqBC,MAAvC,CAF0B,CAA5B;MAID,CATD,MASO;QACL;QACA;QACA,IAAI,CAACP,cAAL,EAAqB;UACnBA,cAAc,GAAG,IAAAQ,UAAA,EAAQ5B,IAAI,CAACI,EAAb,CAAjB;QACD;;QACDW,YAAY,CAACO,WAAD,CAAZ,GAA4B,IAAAG,sBAAA,EAAWL,cAAX,EAA2BE,WAA3B,CAA5B;MACD;IACF;EACF,CA5DsB,CA8DvB;;;EACA,MAAMO,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAchB,YAAd,EAA4B;IAC1CX,EAAE,EAAEJ,IAAI,CAACI,EADiC;IAE1CC,QAAQ,EAAE;MACRC,OAAO,EAAEN,IAAI,CAACK,QAAL,CAAcC,OADf;MAER0B,IAAI,EAAEhC,IAAI,CAACK,QAAL,CAAc2B;IAFZ,CAFgC;IAM1ClB,6BAA6B,EAAE;MAC7Bb,WAAW,EAAEe;IADgB;EANW,CAA5B,CAAhB,CA/DuB,CA0EvB;;EACAnB,qBAAqB,CAACoC,GAAtB,CAA0B9B,QAA1B,EAAoC,IAAI+B,OAAJ,CAAgCL,OAAhC,CAApC;EAEA,OAAOA,OAAP;AACD,CAlFM;;;;AAoFP,MAAMM,SAAS,GAAG,CAACC,CAAD,EAAwBC,CAAxB,KAChBD,CAAC,CAAC/B,QAAF,CAAWC,OAAX,GAAqB+B,CAAC,CAAChC,QAAF,CAAWC,OADlC;;AAkCO,SAASgC,qBAAT,CACLC,WADK,EAELC,EAFK,EAGC;EACN;EACA;EACA,KAAK,MAAMC,MAAX,IAAqBF,WAAW,CAACG,OAAjC,EAA0C;IACxCD,MAAM,CAAC,CAAD,CAAN,CAAUE,IAAV,CAAeR,SAAf;EACD;;EAED,IAAIK,EAAE,KAAM,KAAR,IAAgBA,EAAE,KAAM,MAA5B,EAAmC;IACjCI,0BAA0B,CAACL,WAAD,CAA1B;EACD,CAFD,MAEO,IAAI,CAAE,KAAF,EAAS,MAAT,EAAiB,KAAjB,EAAwB,MAAxB,EAA+BM,QAA/B,CAAwCL,EAAxC,CAAJ,EAAiD;IACtDM,+BAA+B,CAACP,WAAD,EAAcC,EAAd,CAA/B;EACD;AACF;;AAED,SAASI,0BAAT,CAAoCL,WAApC,EAAqE;EACnE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA,MAAMQ,GAA8B,GAAG,EAAvC;EACAR,WAAW,CAACS,IAAZ,CAAiBC,cAAjB,GAAkCF,GAAlC;EACAR,WAAW,CAACG,OAAZ,CAAoBQ,OAApB,CAA4BC,CAAC,IAAI;IAC/BA,CAAC,CAACD,OAAF,CAAUE,MAAM,IAAI;MAClBL,GAAG,CAACM,IAAJ,CAASD,MAAT;IACD,CAFD;EAGD,CAJD;AAKD;;AAED,SAASN,+BAAT,CACEP,WADF,EAEEC,EAFF,EAGQ;EACN;EACA;EACA;EACA;EAEA,MAAMc,eAEL,GAAG,CAAC,GAAGf,WAAW,CAACG,OAAZ,CAAoBa,OAApB,EAAJ,CAFJ,CANM,CAUN;EACA;;EACA,MAAMA,OAAwD,GAC5DD,eAAe,CAACE,MAAhB,CAAuB,CAAC,CAACL,CAAD,CAAD,KAASA,CAAC,IAAI,IAArC,CADF,CAZM,CAiBN;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA,IAAIX,EAAE,KAAM,KAAR,IAAgBA,EAAE,KAAM,MAA5B,EAAmC;IACjC;IACAe,OAAO,CAACZ,IAAR,CAAa,CAAC,CAACP,CAAD,CAAD,EAAM,CAACC,CAAD,CAAN,KAAeD,CAAC,GAAGC,CAAJ,GAAQ,CAAC,CAAT,GAAaD,CAAC,GAAGC,CAAJ,GAAQ,CAAR,GAAY,CAArD;EACD,CAHD,MAGO,IAAIG,EAAE,KAAM,KAAR,IAAgBA,EAAE,KAAM,MAA5B,EAAmC;IACxC;IACAe,OAAO,CAACZ,IAAR,CAAa,CAAC,CAACP,CAAD,CAAD,EAAM,CAACC,CAAD,CAAN,KAAeD,CAAC,GAAGC,CAAJ,GAAQ,CAAC,CAAT,GAAaD,CAAC,GAAGC,CAAJ,GAAQ,CAAR,GAAY,CAArD;EACD;;EAED,MAAMoB,YAAuC,GAAG,EAAhD;EACA,MAAMC,aAAiC,GAAG,EAA1C;EACA,MAAMC,OAA2C,GAAG,IAAI7D,GAAJ,EAApD;EACAyD,OAAO,CAACL,OAAR,CAAgB,CAAC,CAACC,CAAD,EAAIV,MAAJ,CAAD,KAA2D;IACzE;IACA;IACA;IACAkB,OAAO,CAAC1B,GAAR,CAAYkB,CAAZ,EAAe,CAACM,YAAY,CAAC9B,MAAd,EAAsB8B,YAAY,CAAC9B,MAAb,GAAsBc,MAAM,CAACd,MAAnD,CAAf,EAJyE,CAKzE;IACA;;IACAc,MAAM,CAACS,OAAP,CAAelD,IAAI,IAAIyD,YAAY,CAACJ,IAAb,CAAkBrD,IAAlB,CAAvB;IACA0D,aAAa,CAACL,IAAd,CAAmBF,CAAnB;EACD,CATD;;EAWA,IAAIX,EAAE,KAAM,KAAR,IAAgBA,EAAE,KAAM,MAA5B,EAAmC;IACjCD,WAAW,CAACS,IAAZ,CAAiBY,SAAjB,GAA6BF,aAA7B;IACAnB,WAAW,CAACS,IAAZ,CAAiBa,eAAjB,GAAmCJ,YAAnC,CAFiC,CAGjC;IACA;IACA;;IACAlB,WAAW,CAACS,IAAZ,CAAiBc,cAAjB,GAAkCH,OAAlC;EACD,CAPD,MAOO,IAAInB,EAAE,KAAM,KAAR,IAAgBA,EAAE,KAAM,MAA5B,EAAmC;IACxCD,WAAW,CAACS,IAAZ,CAAiBe,UAAjB,GAA8BL,aAA9B;IACAnB,WAAW,CAACS,IAAZ,CAAiBgB,gBAAjB,GAAoCP,YAApC,CAFwC,CAGxC;IACA;IACA;;IACAlB,WAAW,CAACS,IAAZ,CAAiBiB,eAAjB,GAAmCN,OAAnC;EACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAMO,kBAAkB,GAAG,CAChC1B,EADgC,EAEhC2B,cAFgC,EAGhCC,UAHgC,EAIhCC,aAJgC,EAKhCC,YALgC,EAMhCrE,WANgC,EAOhCC,cAPgC,KAQvB;EACT,MAAMqC,WAAyB,GAAG;IAChCC,EADgC;IAEhCE,OAAO,EAAE,IAAI5C,GAAJ,EAFuB;IAGhCkD,IAAI,EAAE;EAH0B,CAAlC;EAKAsB,YAAY,CAACrC,GAAb,CAAiBkC,cAAjB,EAAiC5B,WAAjC,EANS,CAQT;EACA;EACA;;EAEA,IAAI8B,aAAa,CAAC1C,MAAd,KAAyB,CAA7B,EAAgC;IAC9B,IAAA4C,eAAA,IACGC,kBADH,CACsBH,aAAa,CAAC,CAAD,CADnC,EAEGnB,OAFH,CAEWlD,IAAI,IAAI;MACfyE,oBAAoB,CAAC;QACnBzE,IADmB;QAEnB0E,KAAK,EAAEN,UAFY;QAGnB7B,WAHmB;QAInBtC,WAJmB;QAKnBC;MALmB,CAAD,CAApB;IAOD,CAVH;EAWD,CAZD,MAYO;IACL;IACA;IACA,IAAAqE,eAAA,IACGI,YADH,GAEGzB,OAFH,CAEWlD,IAAI,IAAI;MACf,IAAI,CAACqE,aAAa,CAACxB,QAAd,CAAuB7C,IAAI,CAACK,QAAL,CAAc2B,IAArC,CAAL,EAAiD;QAC/C;MACD;;MAEDyC,oBAAoB,CAAC;QACnBzE,IADmB;QAEnB0E,KAAK,EAAEN,UAFY;QAGnB7B,WAHmB;QAInBtC,WAJmB;QAKnBC;MALmB,CAAD,CAApB;IAOD,CAdH;EAeD;;EAEDoC,qBAAqB,CAACC,WAAD,EAAcC,EAAd,CAArB;AACD,CArDM;;;;AAuDA,SAASoC,sBAAT,CACLT,cADK,EAELE,aAFK,EAGLC,YAHK,EAILrE,WAJK,EAKLC,cALK,EAMC;EACN;EACA;EACA;EAEA,MAAM2E,gBAA2C,GAAG,EAApD;EAEAP,YAAY,CAACrC,GAAb,CAAiBkC,cAAjB,EAAiC;IAC/B3B,EAAE,EAAG,KAD0B;IACpB;IACXE,OAAO,EAAE,IAAI5C,GAAJ,EAFsB;IAG/BkD,IAAI,EAAE;MACJ6B,gBADI,CACc;;IADd;EAHyB,CAAjC;;EAQA,IAAIR,aAAa,CAAC1C,MAAd,KAAyB,CAA7B,EAAgC;IAC9B,IAAA4C,eAAA,IACGC,kBADH,CACsBH,aAAa,CAAC,CAAD,CADnC,EAEGnB,OAFH,CAEWlD,IAAI,IAAI;MACf6E,gBAAgB,CAACxB,IAAjB,CACEtD,oBAAoB,CAACC,IAAD,EAAOC,WAAP,EAAoBC,cAApB,CADtB;IAGD,CANH;EAOD,CARD,MAQO;IACL;IACA;IACA,IAAAqE,eAAA,IACGI,YADH,GAEGzB,OAFH,CAEWlD,IAAI,IAAI;MACf,IAAIqE,aAAa,CAACxB,QAAd,CAAuB7C,IAAI,CAACK,QAAL,CAAc2B,IAArC,CAAJ,EAAgD;QAC9C6C,gBAAgB,CAACxB,IAAjB,CACEtD,oBAAoB,CAACC,IAAD,EAAOC,WAAP,EAAoBC,cAApB,CADtB;MAGD;IACF,CARH;EASD,CAnCK,CAqCN;EACA;;;EACA2E,gBAAgB,CAAClC,IAAjB,CAAsBR,SAAtB;AACD;;AAED,SAASsC,oBAAT,CAA8B;EAC5BzE,IAD4B;EAE5B0E,KAF4B;EAG5BnC,WAH4B;EAI5BtC,WAJ4B;EAK5BC,cAL4B;EAM5B4E,WAAW,GAAG9E;AANc,CAA9B,EAcS;EACP;EACA;EACA,IAAImD,CAAC,GAAG2B,WAAR;EACA,IAAIC,CAAC,GAAG,CAAR;;EACA,OAAOA,CAAC,GAAGL,KAAK,CAAC/C,MAAV,IAAoBwB,CAA3B,EAA8B;IAC5B,MAAM6B,QAAQ,GAAGN,KAAK,CAACK,CAAC,EAAF,CAAtB;;IACA,IAAIA,CAAC,KAAK,CAAN,IAAWC,QAAQ,KAAM,mBAA7B,EAAiD;MAC/C7B,CAAC,GAAG,IAAA3B,wBAAA,EAAkB2B,CAAlB,CAAJ;IACD,CAFD,MAEO;MACLA,CAAC,GAAGA,CAAC,CAAC6B,QAAD,CAAL;IACD;EACF;;EAED,IACG,OAAO7B,CAAP,KAAc,QAAd,IACC,OAAOA,CAAP,KAAc,QADf,IAEC,OAAOA,CAAP,KAAc,SAFf,IAGCA,CAAC,KAAK,IAHR,IAIA4B,CAAC,KAAKL,KAAK,CAAC/C,MALd,EAME;IACA,IAAIoD,CAAC,KAAKL,KAAK,CAAC/C,MAAZ,IAAsBsD,KAAK,CAACC,OAAN,CAAc/B,CAAd,CAA1B,EAA4C;MAC1C;MACA;MACA;MAEAA,CAAC,CAACD,OAAF,CAAUC,CAAC,IACTgC,gBAAgB,CAAC5C,WAAD,EAAcvC,IAAd,EAAoBmD,CAApB,EAAuBlD,WAAvB,EAAoCC,cAApC,CADlB;MAIA;IACD,CAXD,CAaA;IACA;IACA;IACA;;;IACAiD,CAAC,GAAG3C,SAAJ;EACD;;EAED2E,gBAAgB,CAAC5C,WAAD,EAAcvC,IAAd,EAAoBmD,CAApB,EAAuBlD,WAAvB,EAAoCC,cAApC,CAAhB;AACD;;AAED,SAASiF,gBAAT,CACE5C,WADF,EAEEvC,IAFF,EAGEoF,KAHF,EAIEnF,WAJF,EAKEC,cALF,EAMQ;EACN,IAAI6C,GAAG,GAAGR,WAAW,CAACG,OAAZ,CAAoBhC,GAApB,CAAwB0E,KAAxB,CAAV;;EACA,IAAI,CAACrC,GAAL,EAAU;IACRA,GAAG,GAAG,EAAN;IACAR,WAAW,CAACG,OAAZ,CAAoBT,GAApB,CAAwBmD,KAAxB,EAA+BrC,GAA/B;EACD;;EAED,MAAMlB,OAAO,GAAG9B,oBAAoB,CAACC,IAAD,EAAOC,WAAP,EAAoBC,cAApB,CAApC;;EACA,IAAI,CAAC6C,GAAG,CAACF,QAAJ,CAAahB,OAAb,CAAL,EAA4B;IAC1BkB,GAAG,CAACM,IAAJ,CAASxB,OAAT;EACD;AACF;;AAEM,MAAMwD,sBAAsB,GAAG,CACpC7C,EADoC,EAEpC2B,cAFoC,EAGpCX,MAHoC,EAIpCa,aAJoC,EAKpCC,YALoC,EAMpCrE,WANoC,EAOpCC,cAPoC,KAQ3B;EACT;EACA;EAEA,MAAMqC,WAAyB,GAAG;IAChCC,EADgC;IAEhCE,OAAO,EAAE,IAAI5C,GAAJ,EAFuB;IAGhCkD,IAAI,EAAE;EAH0B,CAAlC;EAKAsB,YAAY,CAACrC,GAAb,CAAiBkC,cAAjB,EAAiC5B,WAAjC;;EAEA,IAAI8B,aAAa,CAAC1C,MAAd,KAAyB,CAA7B,EAAgC;IAC9B,IAAA4C,eAAA,IACGC,kBADH,CACsBH,aAAa,CAAC,CAAD,CADnC,EAEGnB,OAFH,CAEWlD,IAAI,IAAI;MACfsF,4BAA4B,CAAC;QAC3BtF,IAD2B;QAE3BuF,kBAAkB,EAAEvF,IAFO;QAG3BwD,MAH2B;QAI3BjB,WAJ2B;QAK3BtC,WAL2B;QAM3BC;MAN2B,CAAD,CAA5B;IAQD,CAXH;EAYD,CAbD,MAaO;IACL;IACA,IAAAqE,eAAA,IACGI,YADH,GAEGzB,OAFH,CAEWlD,IAAI,IAAI;MACf,IAAI,CAACqE,aAAa,CAACxB,QAAd,CAAuB7C,IAAI,CAACK,QAAL,CAAc2B,IAArC,CAAL,EAAiD;QAC/C;MACD;;MAEDsD,4BAA4B,CAAC;QAC3BtF,IAD2B;QAE3BuF,kBAAkB,EAAEvF,IAFO;QAG3BwD,MAH2B;QAI3BjB,WAJ2B;QAK3BtC,WAL2B;QAM3BC;MAN2B,CAAD,CAA5B;IAQD,CAfH;EAgBD;;EAEDoC,qBAAqB,CAACC,WAAD,EAAcC,EAAd,CAArB;AACD,CArDM;;;;AAuDP,SAAS8C,4BAAT,CAAsC;EACpCtF,IADoC;EAEpCuF,kBAFoC;EAEhB;EACpB/B,MAHoC;EAIpCjB,WAJoC;EAKpCtC,WALoC;EAMpCC;AANoC,CAAtC,EAcS;EACP,MAAM;IAAEsF,IAAF;IAAQC;EAAR,IAAwBjC,MAA9B,CADO,CAGP;;EACA,IAAIuB,CAAC,GAAG,CAAR;;EACA,OAAOA,CAAC,GAAGS,IAAI,CAAC7D,MAAT,IAAmB4D,kBAA1B,EAA8C;IAC5C,MAAMP,QAAQ,GAAGQ,IAAI,CAACT,CAAC,EAAF,CAArB;;IACA,IAAIA,CAAC,KAAK,CAAN,IAAWC,QAAQ,KAAM,mBAA7B,EAAiD;MAC/CO,kBAAkB,GAAG,IAAA/D,wBAAA,EAAkB+D,kBAAlB,CAArB;IACD,CAFD,MAEO;MACLA,kBAAkB,GAAGA,kBAAkB,CAACP,QAAD,CAAvC;IACD;EACF;;EAED,IAAIQ,IAAI,CAAC7D,MAAL,KAAgBoD,CAApB,EAAuB;IACrB;IACA;EACD,CAjBM,CAmBP;;;EACA,IAAI,CAACE,KAAK,CAACC,OAAN,CAAcK,kBAAd,CAAL,EAAwC;IACtC;IACAA,kBAAkB,GAAG,CAACA,kBAAD,CAArB;EACD,CAvBM,CAyBP;EACA;EACA;EACA;;;EACAA,kBAAkB,CAACrC,OAAnB,CAA2BwC,IAAI,IAAI;IACjC,IAAID,WAAW,CAACzD,IAAZ,KAAsB,WAA1B,EAAsC;MACpCsD,4BAA4B,CAAC;QAC3BtF,IAD2B;QAE3BuF,kBAAkB,EAAEG,IAFO;QAG3BlC,MAAM,EAAEiC,WAHmB;QAI3BlD,WAJ2B;QAK3BtC,WAL2B;QAM3BC;MAN2B,CAAD,CAA5B;IAQD,CATD,MASO;MACL;MACAuE,oBAAoB,CAAC;QACnBzE,IADmB;QAEnB0E,KAAK,EAAEe,WAAW,CAACD,IAFA;QAGnBjD,WAHmB;QAInBtC,WAJmB;QAKnBC,cALmB;QAMnB4E,WAAW,EAAEY;MANM,CAAD,CAApB;IAQD;EACF,CArBD;AAsBD;;AAED,MAAMC,eAAe,GAAG,CACtBC,MADsB,EAEtBC,MAFsB,KAGW;EACjC,IAAIC,GAAG,GAAG,CAAV;EACA,IAAIC,GAAG,GAAGH,MAAM,CAACjE,MAAP,GAAgB,CAA1B;EACA,IAAIqE,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWN,MAAM,CAACjE,MAAP,GAAgB,CAA3B,CAAZ;;EACA,OAAOmE,GAAG,IAAIC,GAAd,EAAmB;IACjB,MAAMX,KAAK,GAAGQ,MAAM,CAACI,KAAD,CAApB;;IACA,IAAIH,MAAM,GAAGT,KAAb,EAAoB;MAClB;MACA;MACAW,GAAG,GAAGC,KAAN;IACD,CAJD,MAIO,IAAIH,MAAM,GAAGT,KAAb,EAAoB;MACzB;MACA;MACAU,GAAG,GAAGE,KAAN;IACD,CAJM,MAIA;MACL;MACA;MACA,OAAO,CAACA,KAAD,EAAQA,KAAR,CAAP;IACD;;IAED,IAAID,GAAG,GAAGD,GAAN,IAAa,CAAjB,EAAoB;MAClB;MACA;MACA,OAAO,CAACA,GAAD,EAAMC,GAAN,CAAP;IACD;;IAEDC,KAAK,GAAGF,GAAG,GAAGG,IAAI,CAACC,KAAL,CAAW,CAACH,GAAG,GAAGD,GAAP,IAAc,CAAzB,CAAd;EACD,CA3BgC,CA6BjC;;;EACA,OAAOtF,SAAP;AACD,CAlCD;;AAmCA,MAAM2F,gBAAgB,GAAG,CACvBP,MADuB,EAEvBC,MAFuB,KAGU;EACjC,IAAIC,GAAG,GAAG,CAAV;EACA,IAAIC,GAAG,GAAGH,MAAM,CAACjE,MAAP,GAAgB,CAA1B;EACA,IAAIqE,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWN,MAAM,CAACjE,MAAP,GAAgB,CAA3B,CAAZ;;EACA,OAAOmE,GAAG,IAAIC,GAAd,EAAmB;IACjB,MAAMX,KAAK,GAAGQ,MAAM,CAACI,KAAD,CAApB;;IACA,IAAIH,MAAM,GAAGT,KAAb,EAAoB;MAClB;MACA;MACAU,GAAG,GAAGE,KAAN;IACD,CAJD,MAIO,IAAIH,MAAM,GAAGT,KAAb,EAAoB;MACzB;MACA;MACAW,GAAG,GAAGC,KAAN;IACD,CAJM,MAIA;MACL;MACA;MACA,OAAO,CAACA,KAAD,EAAQA,KAAR,CAAP;IACD;;IAED,IAAID,GAAG,GAAGD,GAAN,IAAa,CAAjB,EAAoB;MAClB;MACA;MACA,OAAO,CAACA,GAAD,EAAMC,GAAN,CAAP;IACD;;IAEDC,KAAK,GAAGF,GAAG,GAAGG,IAAI,CAACC,KAAL,CAAW,CAACH,GAAG,GAAGD,GAAP,IAAc,CAAzB,CAAd;EACD,CA3BgC,CA6BjC;;;EACA,OAAOtF,SAAP;AACD,CAlCD;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,MAAM4F,wBAAwB,GAAG,CACtCjC,cADsC,EAEtCkC,WAFsC,EAGtC/B,YAHsC,EAItCgC,YAJsC,KAKI;EAC1C,MAAM/D,WAAW,GAAG+B,YAAY,CAAC5D,GAAb,CAAiByD,cAAjB,CAApB;;EACA,IAAI,CAAC5B,WAAL,EAAkB;IAChB,OAAO/B,SAAP;EACD;;EAED,MAAMgC,EAAE,GAAGD,WAAW,CAACC,EAAvB;;EAEA,IAAIA,EAAE,KAAM,KAAZ,EAAkB;IAChB;IAEA,IAAI6D,WAAW,IAAI,IAAnB,EAAyB;MAAA;;MACvB;MACA;MACA;MAEA,MAAME,OAAO,4BAAGhE,WAAW,CAACG,OAAZ,CAAoBhC,GAApB,CAAwB,IAAxB,CAAH,yEAAoC,EAAjD;MACA,MAAM8F,QAAQ,6BAAGjE,WAAW,CAACG,OAAZ,CAAoBhC,GAApB,CAAwBF,SAAxB,CAAH,2EAAyC,EAAvD,CANuB,CAQvB;MACA;;MACA,OAAOiG,mBAAmB,CAACF,OAAD,EAAUC,QAAV,CAA1B;IACD;;IAED,OAAOjE,WAAW,CAACG,OAAZ,CAAoBhC,GAApB,CAAwB2F,WAAxB,CAAP;EACD;;EAED,IAAI7D,EAAE,KAAM,KAAZ,EAAkB;IAChB,IAAI,CAACyC,KAAK,CAACC,OAAN,CAAcmB,WAAd,CAAL,EAAiC;MAC/B,MAAM,IAAIK,KAAJ,CAAU,wDAAV,CAAN;IACD;;IACD,MAAMC,cAA0C,GAAGN,WAAnD;IAEA,MAAMpE,GAA4B,GAAG,IAAIhB,GAAJ,EAArC,CANgB,CAQhB;IACA;IACA;;IACA0F,cAAc,CAACzD,OAAf,CAAwBC,CAAD;MAAA;;MAAA,iCACrBZ,WAAW,CAACG,OAAZ,CAAoBhC,GAApB,CAAwByC,CAAxB,CADqB,2DACrB,uBAA4BD,OAA5B,CAAoCC,CAAC,IAAIlB,GAAG,CAAC2E,GAAJ,CAAQzD,CAAR,CAAzC,CADqB;IAAA,CAAvB;IAIA,MAAMJ,GAAG,GAAG,CAAC,GAAGd,GAAJ,CAAZ,CAfgB,CAeK;;IACrBc,GAAG,CAACJ,IAAJ,CAASR,SAAT,EAhBgB,CAkBhB;;IACA,IAAIwE,cAAc,CAAC9D,QAAf,CAAwB,IAAxB,CAAJ,EAAmC;MACjC;MACA;MACA,MAAMgE,KAAK,GAAGtE,WAAW,CAACG,OAAZ,CAAoBhC,GAApB,CAAwBF,SAAxB,CAAd;;MACA,IAAIqG,KAAJ,EAAW;QACT;QACA,OAAOJ,mBAAmB,CAACI,KAAD,EAAQ9D,GAAR,CAA1B;MACD;IACF,CA3Be,CA6BhB;;;IACA,IAAIuD,YAAJ,EAAkB;MAChBQ,qBAAqB,CAAC/D,GAAD,CAArB;IACD;;IAED,OAAOA,GAAP;EACD;;EAED,IAAIP,EAAE,KAAM,MAAZ,EAAmB;IACjB;IACA;IAEA,IAAI,CAACyC,KAAK,CAACC,OAAN,CAAcmB,WAAd,CAAL,EAAiC;MAC/B,MAAM,IAAIK,KAAJ,CAAW,6CAAX,CAAN;IACD;;IAED,MAAMd,MAAgC,GAAG,IAAI3E,GAAJ,CAAQoF,WAAR,CAAzC;IACA,MAAMpE,GAAG,GAAG,IAAIhB,GAAJ,CAAQsB,WAAW,CAACS,IAAZ,CAAiBC,cAAzB,CAAZ,CATiB,CAWjB;;IACA2C,MAAM,CAAC1C,OAAP,CAAemD,WAAW,IAAI;MAC5BU,mBAAmB,CAACV,WAAD,EAAc9D,WAAd,EAA2BN,GAA3B,CAAnB;IACD,CAFD,EAZiB,CAgBjB;IACA;;IACA,OAAO,CAAC,GAAGA,GAAJ,EAASU,IAAT,CAAcR,SAAd,CAAP;EACD;;EAED,IAAIK,EAAE,KAAM,KAAZ,EAAkB;IAChB,MAAMP,GAAG,GAAG,IAAIhB,GAAJ,CAAQsB,WAAW,CAACS,IAAZ,CAAiBC,cAAzB,CAAZ;IAEA8D,mBAAmB,CAACV,WAAD,EAAc9D,WAAd,EAA2BN,GAA3B,CAAnB,CAHgB,CAKhB;IACA;;IACA,OAAO,CAAC,GAAGA,GAAJ,EAASU,IAAT,CAAcR,SAAd,CAAP;EACD;;EAED,IAAIK,EAAE,KAAM,QAAZ,EAAqB;IACnB;IACA;IAEA;IACA;IAEA,IAAI,EAAE6D,WAAW,YAAYW,MAAzB,CAAJ,EAAsC;MACpC,MAAM,IAAIN,KAAJ,CACH,mEADG,CAAN;IAGD;;IACD,MAAMO,KAAK,GAAGZ,WAAd;IAEA,MAAMtD,GAA8B,GAAG,EAAvC;IACAR,WAAW,CAACG,OAAZ,CAAoBQ,OAApB,CAA4B,CAAC2D,KAAD,EAAQzB,KAAR,KAAkB;MAC5C;MACA;MACA,IAAIA,KAAK,KAAK5E,SAAV,IAAuByG,KAAK,CAACC,IAAN,CAAWC,MAAM,CAAC/B,KAAD,CAAjB,CAA3B,EAAsD;QACpDyB,KAAK,CAAC3D,OAAN,CAAclD,IAAI,IAAI+C,GAAG,CAACM,IAAJ,CAASrD,IAAT,CAAtB;MACD;IACF,CAND,EAfmB,CAuBnB;IACA;;IAEA+C,GAAG,CAACJ,IAAJ,CAASR,SAAT,EA1BmB,CA4BnB;;IACA,IAAImE,YAAJ,EAAkB;MAChBQ,qBAAqB,CAAC/D,GAAD,CAArB;IACD;;IAED,OAAOA,GAAP;EACD;;EAED,IAAIsD,WAAW,IAAI,IAAnB,EAAyB;IACvB,IAAI7D,EAAE,KAAM,KAAR,IAAgBA,EAAE,KAAM,KAA5B,EAAkC;MAChC;MACA,OAAOhC,SAAP;IACD,CAJsB,CAMvB;IACA;;;IACA,OAAO+B,WAAW,CAACG,OAAZ,CAAoBhC,GAApB,CAAwB2F,WAAxB,CAAP;EACD;;EAED,IAAIpB,KAAK,CAACC,OAAN,CAAcmB,WAAd,CAAJ,EAAgC;IAC9B,MAAM,IAAIK,KAAJ,CACJ,+CAA+ClE,EAA/C,GAAoD,cADhD,CAAN;EAGD;;EAED,IAAI6D,WAAW,YAAYW,MAA3B,EAAmC;IACjC;IACA;IACA,MAAM,IAAIN,KAAJ,CACH,kEADG,CAAN;EAGD;;EAED,IAAIlE,EAAE,KAAM,KAAZ,EAAkB;IAChB;IACA;IAEA,MAAM4E,MAAM,GAAG7E,WAAW,CAACS,IAAZ,CAAiBc,cAAhC;IACA,MAAM+C,KAAK,GAAGtE,WAAW,CAACS,IAAZ,CAAiBa,eAA/B;IAEA,MAAMwD,KAAK,GAAGD,MAAM,CAAE1G,GAAR,CAAY2F,WAAZ,CAAd;;IACA,IAAIgB,KAAJ,EAAW;MACT,MAAMtE,GAAG,GAAG8D,KAAK,CAAEnF,KAAP,CAAa,CAAb,EAAgB2F,KAAK,CAAC,CAAD,CAArB,CAAZ;MACAtE,GAAG,CAACJ,IAAJ,CAASR,SAAT,EAFS,CAGT;;MACA,IAAImE,YAAJ,EAAkB;QAChBQ,qBAAqB,CAAC/D,GAAD,CAArB;MACD;;MACD,OAAOA,GAAP;IACD,CAhBe,CAkBhB;IACA;IACA;IAEA;;;IACA,MAAM6C,MAAM,GAAGrD,WAAW,CAACS,IAAZ,CAAiBY,SAAhC,CAvBgB,CAwBhB;IACA;;IACA,MAAM0D,KAAK,GAAG3B,eAAe,CAACC,MAAD,EAASS,WAAT,CAA7B;;IACA,IAAI,CAACiB,KAAL,EAAY;MACV,OAAO9G,SAAP;IACD;;IACD,MAAM,CAAC+G,QAAD,EAAWC,QAAX,IAAuBF,KAA7B,CA9BgB,CAgChB;IACA;IACA;;IACA,IAAIG,UAAU,GAAG7B,MAAM,CAAC4B,QAAD,CAAvB;;IACA,IAAIC,UAAU,GAAGpB,WAAjB,EAA8B;MAC5BoB,UAAU,GAAG7B,MAAM,CAAC2B,QAAD,CAAnB;IACD,CAtCe,CAwChB;IACA;IACA;;;IAEA,MAAM,CAACG,SAAD,EAAYC,SAAZ,IAAyBP,MAAM,CAAE1G,GAAR,CAAY+G,UAAZ,CAA/B,CA5CgB,CA8ChB;IACA;;IACA,MAAMG,KAAK,GAAGH,UAAU,GAAGpB,WAAb,GAA2BsB,SAA3B,GAAuCD,SAArD;IACA,MAAM3E,GAAG,GAAG8D,KAAK,CAAEnF,KAAP,CAAa,CAAb,EAAgBkG,KAAhB,CAAZ;IACA7E,GAAG,CAACJ,IAAJ,CAASR,SAAT,EAlDgB,CAmDhB;;IACA,IAAImE,YAAJ,EAAkB;MAChBQ,qBAAqB,CAAC/D,GAAD,CAArB;IACD;;IACD,OAAOA,GAAP;EACD;;EAED,IAAIP,EAAE,KAAM,MAAZ,EAAmB;IACjB;IACA;IAEA,MAAM4E,MAAM,GAAG7E,WAAW,CAACS,IAAZ,CAAiBc,cAAhC;IACA,MAAM+C,KAAK,GAAGtE,WAAW,CAACS,IAAZ,CAAiBa,eAA/B;IAEA,MAAMwD,KAAK,GAAGD,MAAM,CAAE1G,GAAR,CAAY2F,WAAZ,CAAd;;IACA,IAAIgB,KAAJ,EAAW;MACT,MAAMtE,GAAG,GAAG8D,KAAK,CAAEnF,KAAP,CAAa,CAAb,EAAgB2F,KAAK,CAAC,CAAD,CAArB,CAAZ;MACAtE,GAAG,CAACJ,IAAJ,CAASR,SAAT,EAFS,CAGT;;MACA,IAAImE,YAAJ,EAAkB;QAChBQ,qBAAqB,CAAC/D,GAAD,CAArB;MACD;;MACD,OAAOA,GAAP;IACD,CAhBgB,CAkBjB;IACA;IACA;IAEA;;;IACA,MAAM6C,MAAM,GAAGrD,WAAW,CAACS,IAAZ,CAAiBY,SAAhC,CAvBiB,CAwBjB;IACA;;IACA,MAAM0D,KAAK,GAAG3B,eAAe,CAACC,MAAD,EAASS,WAAT,CAA7B;;IACA,IAAI,CAACiB,KAAL,EAAY;MACV,OAAO9G,SAAP;IACD;;IACD,MAAM,CAAC+G,QAAD,EAAWC,QAAX,IAAuBF,KAA7B,CA9BiB,CAgCjB;IACA;IACA;;IACA,IAAIG,UAAU,GAAG7B,MAAM,CAAC4B,QAAD,CAAvB;;IACA,IAAIC,UAAU,GAAGpB,WAAjB,EAA8B;MAC5BoB,UAAU,GAAG7B,MAAM,CAAC2B,QAAD,CAAnB;IACD,CAtCgB,CAwCjB;IACA;IACA;;;IAEA,MAAM,CAACG,SAAD,EAAYC,SAAZ,IAAyBP,MAAM,CAAE1G,GAAR,CAAY+G,UAAZ,CAA/B,CA5CiB,CA8CjB;IACA;;IACA,MAAMG,KAAK,GAAGH,UAAU,IAAIpB,WAAd,GAA4BsB,SAA5B,GAAwCD,SAAtD;IACA,MAAM3E,GAAG,GAAG8D,KAAK,CAAEnF,KAAP,CAAa,CAAb,EAAgBkG,KAAhB,CAAZ;IACA7E,GAAG,CAACJ,IAAJ,CAASR,SAAT,EAlDiB,CAmDjB;;IACA,IAAImE,YAAJ,EAAkB;MAChBQ,qBAAqB,CAAC/D,GAAD,CAArB;IACD;;IACD,OAAOA,GAAP;EACD;;EAED,IAAIP,EAAE,KAAM,KAAZ,EAAkB;IAChB;IACA;IAEA,MAAM4E,MAAM,GAAG7E,WAAW,CAACS,IAAZ,CAAiBiB,eAAhC;IACA,MAAM4C,KAAK,GAAGtE,WAAW,CAACS,IAAZ,CAAiBgB,gBAA/B;IAEA,MAAMqD,KAAK,GAAGD,MAAM,CAAE1G,GAAR,CAAY2F,WAAZ,CAAd;;IACA,IAAIgB,KAAJ,EAAW;MACT,MAAMtE,GAAG,GAAG8D,KAAK,CAAEnF,KAAP,CAAa,CAAb,EAAgB2F,KAAK,CAAC,CAAD,CAArB,EAA0BQ,OAA1B,EAAZ;MACA9E,GAAG,CAACJ,IAAJ,CAASR,SAAT,EAFS,CAGT;;MACA,IAAImE,YAAJ,EAAkB;QAChBQ,qBAAqB,CAAC/D,GAAD,CAArB;MACD;;MACD,OAAOA,GAAP;IACD,CAhBe,CAkBhB;IACA;IACA;IAEA;;;IACA,MAAM6C,MAAM,GAAGrD,WAAW,CAACS,IAAZ,CAAiBe,UAAhC,CAvBgB,CAwBhB;IACA;;IACA,MAAMuD,KAAK,GAAGnB,gBAAgB,CAACP,MAAD,EAASS,WAAT,CAA9B;;IACA,IAAI,CAACiB,KAAL,EAAY;MACV,OAAO9G,SAAP;IACD;;IACD,MAAM,CAAC+G,QAAD,EAAWC,QAAX,IAAuBF,KAA7B,CA9BgB,CAgChB;IACA;IACA;;IACA,IAAIG,UAAU,GAAG7B,MAAM,CAAC4B,QAAD,CAAvB;;IACA,IAAIC,UAAU,GAAGpB,WAAjB,EAA8B;MAC5BoB,UAAU,GAAG7B,MAAM,CAAC2B,QAAD,CAAnB;IACD,CAtCe,CAwChB;IACA;IACA;;;IAEA,MAAM,CAACG,SAAD,EAAYC,SAAZ,IAAyBP,MAAM,CAAE1G,GAAR,CAAY+G,UAAZ,CAA/B,CA5CgB,CA8ChB;IACA;;IACA,MAAMG,KAAK,GAAGH,UAAU,GAAGpB,WAAb,GAA2BsB,SAA3B,GAAuCD,SAArD;IACA,MAAM3E,GAAG,GAAG8D,KAAK,CAAEnF,KAAP,CAAa,CAAb,EAAgBkG,KAAhB,EAAuBC,OAAvB,EAAZ;IACA9E,GAAG,CAACJ,IAAJ,CAASR,SAAT,EAlDgB,CAmDhB;;IACA,IAAImE,YAAJ,EAAkB;MAChBQ,qBAAqB,CAAC/D,GAAD,CAArB;IACD;;IACD,OAAOA,GAAP;EACD;;EAED,IAAIP,EAAE,KAAM,MAAZ,EAAmB;IACjB;IACA;IAEA,MAAM4E,MAAM,GAAG7E,WAAW,CAACS,IAAZ,CAAiBiB,eAAhC;IACA,MAAM4C,KAAK,GAAGtE,WAAW,CAACS,IAAZ,CAAiBgB,gBAA/B;IAEA,MAAMqD,KAAK,GAAGD,MAAM,CAAE1G,GAAR,CAAY2F,WAAZ,CAAd;;IACA,IAAIgB,KAAJ,EAAW;MACT,MAAMtE,GAAG,GAAG8D,KAAK,CAAEnF,KAAP,CAAa,CAAb,EAAgB2F,KAAK,CAAC,CAAD,CAArB,EAA0BQ,OAA1B,EAAZ;MACA9E,GAAG,CAACJ,IAAJ,CAASR,SAAT,EAFS,CAGT;;MACA,IAAImE,YAAJ,EAAkB;QAChBQ,qBAAqB,CAAC/D,GAAD,CAArB;MACD;;MACD,OAAOA,GAAP;IACD,CAhBgB,CAkBjB;IACA;IACA;IAEA;;;IACA,MAAM6C,MAAM,GAAGrD,WAAW,CAACS,IAAZ,CAAiBe,UAAhC,CAvBiB,CAwBjB;IACA;;IACA,MAAMuD,KAAK,GAAGnB,gBAAgB,CAACP,MAAD,EAASS,WAAT,CAA9B;;IACA,IAAI,CAACiB,KAAL,EAAY;MACV,OAAO9G,SAAP;IACD;;IACD,MAAM,CAAC+G,QAAD,EAAWC,QAAX,IAAuBF,KAA7B,CA9BiB,CAgCjB;IACA;IACA;;IACA,IAAIG,UAAU,GAAG7B,MAAM,CAAC4B,QAAD,CAAvB;;IACA,IAAIC,UAAU,GAAGpB,WAAjB,EAA8B;MAC5BoB,UAAU,GAAG7B,MAAM,CAAC2B,QAAD,CAAnB;IACD,CAtCgB,CAwCjB;IACA;IACA;;;IAEA,MAAM,CAACG,SAAD,EAAYC,SAAZ,IAAyBP,MAAM,CAAE1G,GAAR,CAAY+G,UAAZ,CAA/B,CA5CiB,CA8CjB;IACA;;IACA,MAAMG,KAAK,GAAGH,UAAU,IAAIpB,WAAd,GAA4BsB,SAA5B,GAAwCD,SAAtD;IACA,MAAM3E,GAAG,GAAG8D,KAAK,CAAEnF,KAAP,CAAa,CAAb,EAAgBkG,KAAhB,EAAuBC,OAAvB,EAAZ;IACA9E,GAAG,CAACJ,IAAJ,CAASR,SAAT,EAlDiB,CAmDjB;;IACA,IAAImE,YAAJ,EAAkB;MAChBQ,qBAAqB,CAAC/D,GAAD,CAArB;IACD;;IACD,OAAOA,GAAP;EACD,CAlYyC,CAoY1C;;;EACA,OAAOvC,SAAP;AACD,CA3YM;;;;AA6YP,SAASuG,mBAAT,CACEV,WADF,EAEE9D,WAFF,EAGEN,GAHF,EAIQ;EACN,IAAIoE,WAAW,KAAK,IAApB,EAA0B;IACxB;IACA;IACA,IAAIyB,KAAK,GAAGvF,WAAW,CAACG,OAAZ,CAAoBhC,GAApB,CAAwBF,SAAxB,CAAZ;IACA,IAAIsH,KAAJ,EAAWA,KAAK,CAAC5E,OAAN,CAAclD,IAAI,IAAIiC,GAAG,CAAC8F,MAAJ,CAAW/H,IAAX,CAAtB;IACX8H,KAAK,GAAGvF,WAAW,CAACG,OAAZ,CAAoBhC,GAApB,CAAwB,IAAxB,CAAR;IACA,IAAIoH,KAAJ,EAAWA,KAAK,CAAC5E,OAAN,CAAclD,IAAI,IAAIiC,GAAG,CAAC8F,MAAJ,CAAW/H,IAAX,CAAtB;EACZ,CAPD,MAOO;IACL;IACA;IACA,MAAM8H,KAAK,GAAGvF,WAAW,CAACG,OAAZ,CAAoBhC,GAApB,CAAwB2F,WAAxB,CAAd;IACA,IAAIyB,KAAJ,EAAWA,KAAK,CAAC5E,OAAN,CAAclD,IAAI,IAAIiC,GAAG,CAAC8F,MAAJ,CAAW/H,IAAX,CAAtB;EACZ;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASgI,uBAAT,CACL5F,CADK,EAELC,CAFK,EAGsB;EAC3B,IAAI4F,QAAQ,GAAG,CAAf;EACA,IAAIC,QAAQ,GAAG,CAAf,CAF2B,CAG3B;;EACA,MAAMC,MAAiC,GAAG,EAA1C;EACA,MAAMC,IAAI,GAAGhG,CAAC,CAACT,MAAf;EACA,MAAM0G,IAAI,GAAGhG,CAAC,CAACV,MAAf;EACA,IAAI2G,SAAyC,GAAG9H,SAAhD,CAP2B,CAO+B;;EAE1D,OAAOyH,QAAQ,GAAGG,IAAX,IAAmBF,QAAQ,GAAGG,IAArC,EAA2C;IACzC,MAAME,QAAQ,GAAGnG,CAAC,CAAC6F,QAAD,CAAD,CAAY5H,QAAZ,CAAqBC,OAAtC;IACA,MAAMkI,QAAQ,GAAGnG,CAAC,CAAC6F,QAAD,CAAD,CAAY7H,QAAZ,CAAqBC,OAAtC;;IAEA,IAAIiI,QAAQ,GAAGC,QAAf,EAAyB;MACvBP,QAAQ;IACT,CAFD,MAEO,IAAIM,QAAQ,GAAGC,QAAf,EAAyB;MAC9BN,QAAQ;IACT,CAFM,MAEA;MACL,IAAI9F,CAAC,CAAC6F,QAAD,CAAD,CAAY7H,EAAZ,KAAmBiC,CAAC,CAAC6F,QAAD,CAAD,CAAY9H,EAAnC,EAAuC;QACrC,MAAM,IAAIsG,KAAJ,CACH,0DADG,CAAN;MAGD,CALI,CAML;MACA;MACA;MACA;;;MACA,IAAI4B,SAAS,KAAKlG,CAAC,CAAC6F,QAAD,CAAnB,EAA+B;QAC7BE,MAAM,CAAC9E,IAAP,CAAYjB,CAAC,CAAC6F,QAAD,CAAb;QACAK,SAAS,GAAGlG,CAAC,CAAC6F,QAAD,CAAb;MACD;;MACDA,QAAQ;MACRC,QAAQ;IACT;EACF;;EAED,OAAOC,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACO,SAAS1B,mBAAT,CACLrE,CADK,EAELC,CAFK,EAGsB;EAC3B;EACA,MAAMU,GAA8B,GAAG,EAAvC;EACA,IAAIuF,SAAyC,GAAG9H,SAAhD,CAH2B,CAG+B;;EAE1D,IAAIyH,QAAQ,GAAG,CAAf;EACA,IAAIC,QAAQ,GAAG,CAAf;EACA,MAAME,IAAI,GAAGhG,CAAC,CAACT,MAAf;EACA,MAAM0G,IAAI,GAAGhG,CAAC,CAACV,MAAf;;EAEA,OAAOsG,QAAQ,GAAGG,IAAX,IAAmBF,QAAQ,GAAGG,IAArC,EAA2C;IACzC,MAAME,QAAQ,GAAGnG,CAAC,CAAC6F,QAAD,CAAD,CAAY5H,QAAZ,CAAqBC,OAAtC;IACA,MAAMkI,QAAQ,GAAGnG,CAAC,CAAC6F,QAAD,CAAD,CAAY7H,QAAZ,CAAqBC,OAAtC;;IAEA,IAAIiI,QAAQ,GAAGC,QAAf,EAAyB;MACvB,IAAIF,SAAS,KAAKlG,CAAC,CAAC6F,QAAD,CAAnB,EAA+B;QAC7BlF,GAAG,CAACM,IAAJ,CAASjB,CAAC,CAAC6F,QAAD,CAAV;QACAK,SAAS,GAAGlG,CAAC,CAAC6F,QAAD,CAAb;MACD;;MACDA,QAAQ;IACT,CAND,MAMO,IAAIM,QAAQ,GAAGC,QAAf,EAAyB;MAC9B,IAAIF,SAAS,KAAKjG,CAAC,CAAC6F,QAAD,CAAnB,EAA+B;QAC7BnF,GAAG,CAACM,IAAJ,CAAShB,CAAC,CAAC6F,QAAD,CAAV;QACAI,SAAS,GAAGjG,CAAC,CAAC6F,QAAD,CAAb;MACD;;MACDA,QAAQ;IACT,CANM,MAMA;MACL,IAAII,SAAS,KAAKlG,CAAC,CAAC6F,QAAD,CAAnB,EAA+B;QAC7BlF,GAAG,CAACM,IAAJ,CAASjB,CAAC,CAAC6F,QAAD,CAAV;QACAK,SAAS,GAAGlG,CAAC,CAAC6F,QAAD,CAAb;MACD;;MACDA,QAAQ;MACRC,QAAQ;IACT;EACF;;EAED,OAAOD,QAAQ,GAAGG,IAAlB,EAAwB;IACtB,IAAIE,SAAS,KAAKlG,CAAC,CAAC6F,QAAD,CAAnB,EAA+B;MAC7BlF,GAAG,CAACM,IAAJ,CAASjB,CAAC,CAAC6F,QAAD,CAAV;MACAK,SAAS,GAAGlG,CAAC,CAAC6F,QAAD,CAAb;IACD;;IACDA,QAAQ;EACT;;EAED,OAAOC,QAAQ,GAAGG,IAAlB,EAAwB;IACtB,IAAIC,SAAS,KAAKjG,CAAC,CAAC6F,QAAD,CAAnB,EAA+B;MAC7BnF,GAAG,CAACM,IAAJ,CAAShB,CAAC,CAAC6F,QAAD,CAAV;MACAI,SAAS,GAAGjG,CAAC,CAAC6F,QAAD,CAAb;IACD;;IACDA,QAAQ;EACT;;EAED,OAAOnF,GAAP;AACD;;AAED,SAAS+D,qBAAT,CAA+B/D,GAA/B,EAAqE;EACnE;EACA;EACA;EACA,IAAI0F,IAAoC,GAAGjI,SAA3C,CAJmE,CAMnE;;EAEA,IAAIkI,CAAC,GAAG,CAAR;;EACA,KAAK,IAAI3D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhC,GAAG,CAACpB,MAAxB,EAAgC,EAAEoD,CAAlC,EAAqC;IACnC,MAAM/E,IAAI,GAAG+C,GAAG,CAACgC,CAAD,CAAhB;;IACA,IAAI/E,IAAI,KAAKyI,IAAb,EAAmB;MACjB;MACA,IAAI1D,CAAC,KAAK2D,CAAV,EAAa;QACX3F,GAAG,CAAC2F,CAAD,CAAH,GAAS1I,IAAT;MACD;;MACD,EAAE0I,CAAF;MACAD,IAAI,GAAGzI,IAAP;IACD;EACF;;EACD+C,GAAG,CAACpB,MAAJ,GAAa+G,CAAb;AACD;;AAEM,SAASvH,0BAAT,CACLlB,WADK,EAELC,cAFK,EAGU;EACf,MAAMa,YAAY,GAAG,IAAA4H,0BAAA,EAAoBzI,cAApB,CAArB;EACA,MAAM0I,eAAe,GAAG9G,MAAM,CAAC+G,IAAP,CAAY9H,YAAZ,CAAxB;EACA,MAAM+H,SAAS,GAAG7I,WAAW,CAACW,GAAZ,CAAgBC,KAAK,IAAI;IACzC,IACEE,YAAY,CAACF,KAAD,CAAZ,IACA+H,eAAe,CAACG,IAAhB,CAAqBC,GAAG,IAAInI,KAAK,CAACU,UAAN,CAAiByH,GAAjB,CAA5B,CAFF,EAGE;MACA,OAAQ,qBAAoBnI,KAAM,EAAlC;IACD,CALD,MAKO;MACL,OAAOA,KAAP;IACD;EACF,CATiB,CAAlB;EAWA,OAAOiI,SAAP;AACD"}