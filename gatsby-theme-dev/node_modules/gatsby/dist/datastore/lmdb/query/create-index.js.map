{"version":3,"file":"create-index.js","names":["undefinedSymbol","Symbol","for","createIndex","context","typeName","indexFields","indexName","buildIndexName","meta","getIndexMetadata","state","indexReady","lockIndex","err","doCreateIndex","assertReady","databases","metadata","get","toMetadataKey","Error","datastore","indexes","label","console","time","resolvedNodes","store","getState","resolvedNodesCache","stats","maxKeysPerItem","keyCount","itemCount","indexMetadata","keyFields","multiKeyFields","keyPrefix","i","node","iterateNodesByType","resolvedFields","id","keys","prepareIndexKeys","length","Math","max","push","indexKey","put","Promise","resolve","setTimeout","Set","timeEnd","e","error","String","indexKeyElements","dottedField","fieldValue","resolveFieldValue","indexFieldValue","jsValueToLmdbKey","path","internal","type","inspect","Array","isArray","flat","counter","cartesianProduct","justLocked","ifNoExists","reject","retries","timeout","poll","min","fields","tokens","field","sortDirection","join","value","result","item","lmdbKey","undefined","JSON","stringify"],"sources":["../../../../src/datastore/lmdb/query/create-index.ts"],"sourcesContent":["import { inspect } from \"util\"\nimport { store } from \"../../../redux\"\nimport { IGatsbyNode } from \"../../../redux/types\"\nimport { IDataStore, ILmdbDatabases } from \"../../types\"\nimport { cartesianProduct, resolveFieldValue } from \"./common\"\n\ninterface IIndexingContext {\n  databases: ILmdbDatabases\n  datastore: IDataStore\n}\n\nexport type IndexFields = Map<string, number> // name, direction\n\nexport interface IIndexMetadata {\n  state: \"ready\" | \"building\" | \"stale\" | \"error\" | \"initial\"\n  error?: string\n  typeName: string\n  keyPrefix: number | string\n  keyFields: Array<[fieldName: string, orderDirection: number]>\n  multiKeyFields: Array<string>\n\n  // Stats for multi-key indexes\n  // (e.g. when node is { id: `id`, foo: [1,2] } it translates into two index keys: [1,`id`], [2,`id`])\n  stats: {\n    keyCount: number\n    itemCount: number\n    maxKeysPerItem: number\n  }\n}\n\nexport const undefinedSymbol = Symbol.for(`undef`)\n\nexport type IndexFieldValue =\n  | number\n  | string\n  | boolean\n  | null\n  | typeof undefinedSymbol\n  | Array<IndexFieldValue>\n\nexport type IndexKey = Array<IndexFieldValue>\n\nexport async function createIndex(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields\n): Promise<IIndexMetadata> {\n  const indexName = buildIndexName(typeName, indexFields)\n  const meta = getIndexMetadata(context, typeName, indexFields, false)\n\n  switch (meta?.state) {\n    case `ready`:\n      return meta\n    case `building`: {\n      return indexReady(context, indexName)\n    }\n    case `initial`:\n    default: {\n      try {\n        await lockIndex(context, indexName)\n      } catch (err) {\n        // Index is being updated in some other process.\n        // Wait and assume it's in a good state when done\n        return indexReady(context, indexName)\n      }\n      return doCreateIndex(context, typeName, indexFields)\n    }\n  }\n}\n\nexport function getIndexMetadata(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields,\n  assertReady = true\n): IIndexMetadata {\n  const { databases } = context\n  const indexName = buildIndexName(typeName, indexFields)\n  const meta: IIndexMetadata = databases.metadata.get(toMetadataKey(indexName))\n\n  if (assertReady && meta?.state !== `ready`) {\n    throw new Error(\n      `Index ${indexName} is not ready yet. State: ${meta?.state ?? `unknown`}`\n    )\n  }\n  return meta\n}\n\nasync function doCreateIndex(\n  context: IIndexingContext,\n  typeName: string,\n  indexFields: IndexFields\n): Promise<IIndexMetadata> {\n  const { datastore, databases } = context\n  const { indexes, metadata } = databases\n  const indexName = buildIndexName(typeName, indexFields)\n\n  const label = `Indexing ${indexName}`\n  console.time(label)\n\n  // Assuming materialization was run before creating index\n  const resolvedNodes = store.getState().resolvedNodesCache.get(typeName)\n\n  // TODO: iterate only over dirty nodes\n  // TODO: wrap in async transaction?\n  const stats: IIndexMetadata[\"stats\"] = {\n    maxKeysPerItem: 0,\n    keyCount: 0,\n    itemCount: 0,\n  }\n  const indexMetadata: IIndexMetadata = {\n    state: `building`,\n    typeName,\n    keyFields: [...indexFields],\n    multiKeyFields: [],\n    keyPrefix: indexName, // FIXME\n    stats,\n  }\n\n  try {\n    let i = 0\n    for (const node of datastore.iterateNodesByType(typeName)) {\n      // Assuming materialization was run (executing custom resolvers for fields in `filter` and `sort` clauses)\n      //  And materialized values of those fields are stored in resolvedNodes\n      const resolvedFields = resolvedNodes?.get(node.id)\n      const { keys, multiKeyFields } = prepareIndexKeys(\n        node,\n        resolvedFields,\n        indexName,\n        indexFields\n      )\n      stats.keyCount += keys.length\n      stats.itemCount++\n      stats.maxKeysPerItem = Math.max(stats.maxKeysPerItem, keys.length)\n      indexMetadata.multiKeyFields.push(...multiKeyFields)\n\n      for (const indexKey of keys) {\n        // Note: this may throw if indexKey exceeds 1978 chars (lmdb limit) or contain objects/buffers/etc\n        indexes.put(indexKey, node.id)\n      }\n      if (++i % 5000 === 0) {\n        // Do not block event loop too much\n        await new Promise(resolve => setTimeout(resolve, 3))\n      }\n    }\n    indexMetadata.state = `ready`\n    indexMetadata.multiKeyFields = [...new Set(indexMetadata.multiKeyFields)]\n\n    await metadata.put(toMetadataKey(indexName), indexMetadata)\n    console.timeEnd(label)\n\n    return indexMetadata\n  } catch (e) {\n    indexMetadata.state = `error`\n    indexMetadata.error = String(e)\n    await metadata.put(toMetadataKey(indexName), indexMetadata)\n    throw e\n  }\n}\n\n/**\n * Returns a list of index keys for a given node.\n * One node may produce multiple index entries when indexing over array values.\n *\n * For example:\n *  Node: { foo: [{ bar: `bar1`}, { bar: `bar2` }] }\n *  Index fields: [`foo.bar`] will produce the following elements: [`bar1`, `bar2`]\n *\n * Keys are prefixed with index name and suffixed with node counter for stable sort.\n *\n * If materialization result (resolvedFields) exists for a given index field\n *  it is used as a key element, otherwise the a raw node value is used.\n */\nfunction prepareIndexKeys(\n  node: IGatsbyNode,\n  resolvedFields: { [field: string]: unknown } | undefined,\n  indexName: string,\n  indexFields: IndexFields\n): { keys: Array<IndexKey>; multiKeyFields: Array<string> } {\n  // TODO: use index id vs index name (shorter)\n  const indexKeyElements: Array<Array<IndexFieldValue>> = []\n  const multiKeyFields: Array<string> = []\n\n  indexKeyElements.push([indexName])\n  for (const dottedField of indexFields.keys()) {\n    const fieldValue = resolveFieldValue(dottedField, node, resolvedFields)\n    let indexFieldValue = jsValueToLmdbKey(fieldValue)\n\n    // Got value that can't be stored in lmdb key\n    if (typeof indexFieldValue === `undefined`) {\n      const path = `${node.internal.type}.${dottedField} (id: ${node.id})`\n      throw new Error(`Bad value at ${path}: ${inspect(fieldValue)}`)\n    }\n    indexFieldValue = Array.isArray(indexFieldValue)\n      ? indexFieldValue.flat() // FIXME\n      : [indexFieldValue]\n\n    indexKeyElements.push(indexFieldValue)\n\n    if (indexFieldValue.length > 1) {\n      multiKeyFields.push(dottedField)\n    }\n  }\n  indexKeyElements.push([node.internal.counter])\n\n  return { keys: cartesianProduct(...indexKeyElements), multiKeyFields }\n}\n\nasync function lockIndex(\n  context: IIndexingContext,\n  indexName: string\n): Promise<void> {\n  const { metadata } = context.databases\n  const indexKey = toMetadataKey(indexName)\n\n  const justLocked = await metadata.ifNoExists(indexKey, () => {\n    metadata.put(indexKey, null)\n  })\n  if (!justLocked) {\n    throw new Error(`Index is already locked`)\n  }\n}\n\nasync function indexReady(\n  context: IIndexingContext,\n  indexName: string\n): Promise<IIndexMetadata> {\n  return new Promise((resolve, reject) => {\n    const { metadata } = context.databases\n\n    let retries = 0\n    let timeout = 16\n    function poll(): void {\n      const indexMetadata = metadata.get(toMetadataKey(indexName))\n      if (indexMetadata?.state === `ready`) {\n        resolve(indexMetadata)\n        return\n      }\n      if (retries++ > 1000) {\n        reject(new Error(`Index ${indexName} is locked for too long`))\n        return\n      }\n      setTimeout(poll, timeout)\n      timeout = Math.min(200, timeout * 1.5)\n    }\n    poll()\n  })\n}\n\n/**\n * Autogenerate index name based on parameters.\n *\n * Example:\n *\n * buildIndexName(`Foo`, { foo: 1, bar: -1 }) -> `Foo/foo:1/bar:-1\n */\nfunction buildIndexName(typeName: string, fields: IndexFields): string {\n  const tokens: Array<string> = [typeName]\n\n  for (const [field, sortDirection] of fields) {\n    tokens.push(`${field}:${sortDirection}`)\n  }\n\n  return tokens.join(`/`)\n}\n\nfunction toMetadataKey(indexName: string): string {\n  return `index:${indexName}`\n}\n\nfunction jsValueToLmdbKey(value: unknown): IndexFieldValue | undefined {\n  if (\n    typeof value === `number` ||\n    typeof value === `string` ||\n    typeof value === `boolean` ||\n    value === null\n  ) {\n    return value\n  }\n  if (typeof value === `undefined`) {\n    // Array keys containing `undefined` are not supported by lmdb-store\n    //  But we can't exclude those nodes from an index because\n    //  filters { eq: null, gte: null, lte: null } are expected to return such nodes\n    // Furthermore, lmdb-store puts those keys before others and we want them to be below\n    //  so need to add additional padding\n    return undefinedSymbol\n  }\n  if (Array.isArray(value)) {\n    const result: Array<IndexFieldValue> = []\n    for (const item of value) {\n      const lmdbKey = jsValueToLmdbKey(item)\n      if (typeof lmdbKey === `undefined`) {\n        return undefined // bad value\n      }\n      result.push(lmdbKey)\n    }\n    return result\n  }\n  // FIXME: not sure if we want this but there are tests for this :/\n  if (typeof value === `object`) {\n    return JSON.stringify(value)\n  }\n  return undefined\n}\n"],"mappings":"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"}