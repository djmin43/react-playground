{"version":3,"file":"filter-using-index.js","names":["BinaryInfinityNegative","Buffer","from","BinaryInfinityPositive","String","fromCharCode","repeat","ValueEdges","filterUsingIndex","args","context","createFilteringContext","ranges","getIndexRanges","entries","length","performRangeScan","performFullScan","usedQueries","size","dbQueries","narrowResultsIfPossible","isMultiKeyIndex","needsDeduplication","deduplicate","getIdentifier","usedLimit","usedSkip","countUsingIndexOnly","databases","indexes","indexMetadata","keyPrefix","Error","range","start","end","getValueEdgeAfter","snapshot","getKeysCount","count","undefined","Set","multiKeyFields","fieldsWithAppliedEq","forEach","q","filter","getFilterStatement","comparator","DbComparator","EQ","add","dbQueryToDottedField","some","fieldName","has","stats","reverse","limit","skip","offset","maxKeysPerItem","lmdbRanges","push","GatsbyIterable","traverseRanges","undefinedSymbol","undefinedToEnd","topToUndefined","getRange","indexFields","Map","keyFields","positionInKey","set","filtersToApply","query","get","isNegatedQuery","key","fieldPositionInIndex","value","matchesFilter","getSupportedQueries","isSupported","IN","GTE","LTE","GT","LT","NIN","NE","supportedQueries","sortBySpecificity","isEqualityQuery","rangeStarts","rangeEndings","indexFieldInfo","getMostSpecificQuery","result","resolveIndexFieldRanges","i","rangeStartsProduct","cartesianProduct","rangeEndingsProduct","getFieldQueries","queries","indexField","fieldQueries","field","sortDirection","Array","isArray","arr","sort","a","b","hasNull","item","toIndexFieldValue","resolveRangeEdge","AFTER","rangeHead","rangeTail","predicate","edge","dbQuery","filterStatement","getValueEdgeBefore","filterValue","inspect","entry","id","out"],"sources":["../../../../src/datastore/lmdb/query/filter-using-index.ts"],"sourcesContent":["import { GatsbyIterable } from \"../../common/iterable\"\nimport {\n  DbComparator,\n  DbComparatorValue,\n  DbQuery,\n  dbQueryToDottedField,\n  getFilterStatement,\n  IDbFilterStatement,\n  sortBySpecificity,\n} from \"../../common/query\"\nimport { IDataStore, ILmdbDatabases, NodeId } from \"../../types\"\nimport {\n  IIndexMetadata,\n  IndexFieldValue,\n  IndexKey,\n  undefinedSymbol,\n} from \"./create-index\"\nimport { cartesianProduct, matchesFilter } from \"./common\"\nimport { inspect } from \"util\"\n\n// JS values encoded by ordered-binary never start with 0 or 255 byte\nexport const BinaryInfinityNegative = Buffer.from([0])\nexport const BinaryInfinityPositive = String.fromCharCode(255).repeat(4)\n\ntype RangeEdgeAfter = [IndexFieldValue, typeof BinaryInfinityPositive]\ntype RangeEdgeBefore = [typeof undefinedSymbol, IndexFieldValue]\ntype RangeValue =\n  | IndexFieldValue\n  | RangeEdgeAfter\n  | RangeEdgeBefore\n  | typeof BinaryInfinityPositive\n  | typeof BinaryInfinityNegative\ntype RangeBoundary = Array<RangeValue>\n\nexport interface IIndexEntry {\n  key: IndexKey\n  value: NodeId\n}\n\ninterface IIndexRange {\n  start: RangeBoundary\n  end: RangeBoundary\n}\n\nenum ValueEdges {\n  BEFORE = -1,\n  EQ = 0,\n  AFTER = 1,\n}\n\nexport interface IFilterArgs {\n  datastore: IDataStore\n  databases: ILmdbDatabases\n  dbQueries: Array<DbQuery>\n  indexMetadata: IIndexMetadata\n  limit?: number\n  skip?: number\n  reverse?: boolean\n}\n\ninterface IFilterContext extends IFilterArgs {\n  usedLimit: number | undefined\n  usedSkip: number\n  usedQueries: Set<DbQuery>\n}\n\nexport interface IFilterResult {\n  entries: GatsbyIterable<IIndexEntry>\n  usedQueries: Set<DbQuery>\n  usedLimit: number | undefined\n  usedSkip: number\n}\n\ninterface ILmdbStoreRangeOptions {\n  start?: any\n  end?: any\n  limit?: number | undefined\n  offset?: number | undefined\n  revers?: boolean\n  snapshot?: boolean\n}\n\nexport function filterUsingIndex(args: IFilterArgs): IFilterResult {\n  const context = createFilteringContext(args)\n  const ranges = getIndexRanges(context)\n\n  let entries =\n    ranges.length > 0\n      ? performRangeScan(context, ranges)\n      : performFullScan(context)\n\n  if (context.usedQueries.size !== args.dbQueries.length) {\n    // Try to additionally filter out results using data stored in index\n    entries = narrowResultsIfPossible(context, entries)\n  }\n  if (isMultiKeyIndex(context) && needsDeduplication(context)) {\n    entries = entries.deduplicate(getIdentifier)\n  }\n  return {\n    entries,\n    usedQueries: context.usedQueries,\n    usedLimit: context.usedLimit,\n    usedSkip: context.usedSkip,\n  }\n}\n\nexport function countUsingIndexOnly(args: IFilterArgs): number {\n  const context = createFilteringContext(args)\n  const {\n    databases: { indexes },\n    dbQueries,\n    indexMetadata: { keyPrefix },\n  } = args\n\n  const ranges = getIndexRanges(context)\n\n  if (context.usedQueries.size !== dbQueries.length) {\n    throw new Error(`Cannot count using index only`)\n  }\n  if (isMultiKeyIndex(context) && needsDeduplication(context)) {\n    throw new Error(`Cannot count using MultiKey index.`)\n  }\n  if (ranges.length === 0) {\n    const range: ILmdbStoreRangeOptions = {\n      start: [keyPrefix],\n      end: [getValueEdgeAfter(keyPrefix)],\n      snapshot: false,\n    }\n    return indexes.getKeysCount(range)\n  }\n  let count = 0\n  for (let { start, end } of ranges) {\n    start = [keyPrefix, ...start]\n    end = [keyPrefix, ...end]\n    // Assuming ranges are not overlapping\n    const range: ILmdbStoreRangeOptions = { start, end, snapshot: false }\n    count += indexes.getKeysCount(range)\n  }\n  return count\n}\n\nfunction createFilteringContext(args: IFilterArgs): IFilterContext {\n  return {\n    ...args,\n    usedLimit: undefined,\n    usedSkip: 0,\n    usedQueries: new Set<DbQuery>(),\n  }\n}\n\nfunction isMultiKeyIndex(context: IFilterContext): boolean {\n  return context.indexMetadata.multiKeyFields.length > 0\n}\n\nfunction needsDeduplication(context: IFilterContext): boolean {\n  if (!isMultiKeyIndex(context)) {\n    return false\n  }\n  // Deduplication is not needed if all multiKeyFields have applied `eq` filters\n  const fieldsWithAppliedEq = new Set<string>()\n  context.usedQueries.forEach(q => {\n    const filter = getFilterStatement(q)\n    if (filter.comparator === DbComparator.EQ) {\n      fieldsWithAppliedEq.add(dbQueryToDottedField(q))\n    }\n  })\n  return context.indexMetadata.multiKeyFields.some(\n    fieldName => !fieldsWithAppliedEq.has(fieldName)\n  )\n}\n\nfunction performRangeScan(\n  context: IFilterContext,\n  ranges: Array<IIndexRange>\n): GatsbyIterable<IIndexEntry> {\n  const {\n    indexMetadata: { keyPrefix, stats },\n    reverse,\n  } = context\n\n  let { limit, skip: offset = 0 } = context\n\n  if (context.dbQueries.length !== context.usedQueries.size) {\n    // Since this query is not fully satisfied by the index, we can't use limit/skip\n    limit = undefined\n    offset = 0\n  }\n  if (ranges.length > 1) {\n    // e.g. { in: [1, 2] }\n    // Cannot use offset: we will run several range queries and it's not clear which one to offset\n    // TODO: assuming ranges are sorted and not overlapping it should be possible to use offsets in this case\n    //   by running first range query, counting results while lazily iterating and\n    //   running the next range query when the previous iterator is done (and count is known)\n    //   with offset = offset - previousRangeCount, limit = limit - previousRangeCount\n    limit = typeof limit !== `undefined` ? offset + limit : undefined\n    offset = 0\n  }\n  if (limit && isMultiKeyIndex(context) && needsDeduplication(context)) {\n    // Cannot use limit:\n    // MultiKey index may contain duplicates - we can only set a safe upper bound\n    limit *= stats.maxKeysPerItem\n  }\n\n  // Assuming ranges are sorted and not overlapping, we can yield results sequentially\n  const lmdbRanges: Array<ILmdbStoreRangeOptions> = []\n  for (let { start, end } of ranges) {\n    start = [keyPrefix, ...start]\n    end = [keyPrefix, ...end]\n    const range = !reverse\n      ? { start, end, limit, offset, snapshot: false }\n      : { start: end, end: start, limit, offset, reverse, snapshot: false }\n\n    lmdbRanges.push(range)\n  }\n  context.usedLimit = limit\n  context.usedSkip = offset\n  return new GatsbyIterable(() => traverseRanges(context, lmdbRanges))\n}\n\nfunction performFullScan(context: IFilterContext): GatsbyIterable<IIndexEntry> {\n  // *Caveat*: our old query implementation was putting undefined and null values at the end\n  //   of the list when ordered ascending. But lmdb-store keeps them at the top.\n  //   So in LMDB case, need to concat two ranges to conform to our old format:\n  //     concat(undefinedToEnd, topToUndefined)\n  const {\n    reverse,\n    indexMetadata: { keyPrefix },\n  } = context\n\n  let start: RangeBoundary = [keyPrefix, getValueEdgeAfter(undefinedSymbol)]\n  let end: RangeBoundary = [getValueEdgeAfter(keyPrefix)]\n  let range = !reverse\n    ? { start, end, snapshot: false }\n    : { start: end, end: start, reverse, snapshot: false }\n\n  const undefinedToEnd = range\n\n  // Concat null/undefined values\n  end = start\n  start = [keyPrefix, null]\n  range = !reverse\n    ? { start, end, snapshot: false }\n    : { start: end, end: start, reverse, snapshot: false }\n\n  const topToUndefined = range\n\n  const ranges: Array<ILmdbStoreRangeOptions> = !reverse\n    ? [undefinedToEnd, topToUndefined]\n    : [topToUndefined, undefinedToEnd]\n\n  return new GatsbyIterable(() => traverseRanges(context, ranges))\n}\n\nfunction* traverseRanges(\n  context: IFilterContext,\n  ranges: Array<ILmdbStoreRangeOptions>\n): Generator<IIndexEntry> {\n  const {\n    databases: { indexes },\n  } = context\n\n  for (const range of ranges) {\n    // @ts-ignore\n    yield* indexes.getRange(range)\n  }\n}\n\n/**\n * Takes results after the index scan and tries to filter them additionally with unused parts of the query.\n *\n * This is O(N) but the advantage is that it uses data available in the index.\n * So it effectively bypasses the `getNode()` call for such filters (with all associated deserialization complexity).\n *\n * Example:\n *   Imagine the index is: { foo: 1, bar: 1 }\n *\n * Now we run the query:\n *   sort: [`foo`]\n *   filter: { bar: { eq: `test` }}\n *\n * Initial filtering pass will have to perform a full index scan (because `bar` is the last field in the index).\n *\n * But we still have values of `bar` stored in the index itself,\n * so can filter by this value without loading the full node contents.\n */\nfunction narrowResultsIfPossible(\n  context: IFilterContext,\n  entries: GatsbyIterable<IIndexEntry>\n): GatsbyIterable<IIndexEntry> {\n  const { indexMetadata, dbQueries, usedQueries } = context\n\n  const indexFields = new Map<string, number>()\n  indexMetadata.keyFields.forEach(([fieldName], positionInKey) => {\n    // Every index key is [indexId, field1, field2, ...] and `indexMetadata.keyFields` contains [field1, field2, ...]\n    // As `indexId` is in the first column the fields need to be offset by +1 for correct addressing\n    indexFields.set(fieldName, positionInKey + 1)\n  })\n\n  type Filter = [filter: IDbFilterStatement, fieldPositionInIndex: number]\n  const filtersToApply: Array<Filter> = []\n\n  for (const query of dbQueries) {\n    const fieldName = dbQueryToDottedField(query)\n    const positionInKey = indexFields.get(fieldName)\n\n    if (typeof positionInKey === `undefined`) {\n      // No data for this field in index\n      continue\n    }\n    if (usedQueries.has(query)) {\n      // Filter is already applied\n      continue\n    }\n    if (isMultiKeyIndex(context) && isNegatedQuery(query)) {\n      // NE/NIN not supported with MultiKey indexes:\n      //   MultiKey indexes include duplicates; negated queries will only filter some of those\n      //   but may still incorrectly include others in final results\n      continue\n    }\n    const filter = getFilterStatement(query)\n    filtersToApply.push([filter, positionInKey])\n    usedQueries.add(query)\n  }\n\n  return filtersToApply.length === 0\n    ? entries\n    : entries.filter(({ key }) => {\n        for (const [filter, fieldPositionInIndex] of filtersToApply) {\n          const value =\n            key[fieldPositionInIndex] === undefinedSymbol\n              ? undefined\n              : key[fieldPositionInIndex]\n\n          if (!matchesFilter(filter, value)) {\n            // Mimic AND semantics\n            return false\n          }\n        }\n        return true\n      })\n}\n\n/**\n * Returns query clauses that can potentially use index.\n * Returned list is sorted by query specificity\n */\nfunction getSupportedQueries(\n  context: IFilterContext,\n  dbQueries: Array<DbQuery>\n): Array<DbQuery> {\n  const isSupported = new Set([\n    DbComparator.EQ,\n    DbComparator.IN,\n    DbComparator.GTE,\n    DbComparator.LTE,\n    DbComparator.GT,\n    DbComparator.LT,\n    DbComparator.NIN,\n    DbComparator.NE,\n  ])\n  let supportedQueries = dbQueries.filter(query =>\n    isSupported.has(getFilterStatement(query).comparator)\n  )\n  if (isMultiKeyIndex(context)) {\n    // Note:\n    // NE and NIN are not supported by multi-key indexes. Why?\n    //   Imagine a node { id: 1, field: [`foo`, `bar`] }\n    //   Then the filter { field: { ne: `foo` } } should completely remove this node from results.\n    //   But multikey index contains separate entries for `foo` and `bar` values.\n    //   Final range will exclude entry \"foo\" but it will still include entry for \"bar\" hence\n    //   will incorrectly include our node in results.\n    supportedQueries = supportedQueries.filter(query => !isNegatedQuery(query))\n  }\n  return sortBySpecificity(supportedQueries)\n}\n\nfunction isEqualityQuery(query: DbQuery): boolean {\n  const filter = getFilterStatement(query)\n  return (\n    filter.comparator === DbComparator.EQ ||\n    filter.comparator === DbComparator.IN\n  )\n}\n\nfunction isNegatedQuery(query: DbQuery): boolean {\n  const filter = getFilterStatement(query)\n  return (\n    filter.comparator === DbComparator.NE ||\n    filter.comparator === DbComparator.NIN\n  )\n}\n\nexport function getIndexRanges(context: IFilterContext): Array<IIndexRange> {\n  const {\n    dbQueries,\n    indexMetadata: { keyFields },\n  } = context\n  const rangeStarts: Array<RangeBoundary> = []\n  const rangeEndings: Array<RangeBoundary> = []\n  const supportedQueries = getSupportedQueries(context, dbQueries)\n\n  for (const indexFieldInfo of new Map(keyFields)) {\n    const query = getMostSpecificQuery(supportedQueries, indexFieldInfo)\n    if (!query) {\n      // Use index prefix, not all index fields\n      break\n    }\n    const result = resolveIndexFieldRanges(context, query, indexFieldInfo)\n    rangeStarts.push(result.rangeStarts)\n    rangeEndings.push(result.rangeEndings)\n\n    if (!isEqualityQuery(query)) {\n      // Compound index { a: 1, b: 1, c: 1 } supports only one non-eq (range) operator. E.g.:\n      //  Supported: { a: { eq: `foo` }, b: { eq: 8 }, c: { gt: 5 } }\n      //  Not supported: { a: { eq: `foo` }, b: { gt: 5 }, c: { eq: 5 } }\n      //  (or to be precise, can do a range scan only for { a: { eq: `foo` }, b: { gt: 5 } })\n      break\n    }\n  }\n  if (!rangeStarts.length) {\n    return []\n  }\n  // Only the last segment encloses the whole range.\n  // For example, given an index { a: 1, b: 1 } and a filter { a: { eq: `foo` }, b: { eq: `bar` } },\n  // It should produce this range:\n  // {\n  //   start: [`foo`, `bar`],\n  //   end: [`foo`, [`bar`, BinaryInfinityPositive]]\n  // }\n  //\n  // Not this:\n  // {\n  //   start: [`foo`, `bar`],\n  //   end: [[`foo`, BinaryInfinityPositive], [`bar`, BinaryInfinityPositive]]\n  // }\n  for (let i = 0; i < rangeStarts.length - 1; i++) {\n    rangeEndings[i] = rangeStarts[i]\n  }\n\n  // Example:\n  //   rangeStarts: [\n  //     [field1Start1, field1Start2],\n  //     [field2Start1],\n  //   ]\n  //   rangeEnds: [\n  //     [field1End1, field1End2],\n  //     [field2End1],\n  //   ]\n  // Need:\n  //   rangeStartsProduct: [\n  //     [field1Start1, field2Start1],\n  //     [field1Start2, field2Start1],\n  //   ]\n  //   rangeEndingsProduct: [\n  //     [field1End1, field2End1],\n  //     [field1End2, field2End1],\n  //   ]\n  const rangeStartsProduct = cartesianProduct(...rangeStarts)\n  const rangeEndingsProduct = cartesianProduct(...rangeEndings)\n\n  const ranges: Array<IIndexRange> = []\n  for (let i = 0; i < rangeStartsProduct.length; i++) {\n    ranges.push({\n      start: rangeStartsProduct[i],\n      end: rangeEndingsProduct[i],\n    })\n  }\n  // TODO: sort and intersect ranges. Also, we may want this at some point:\n  //   https://docs.mongodb.com/manual/core/multikey-index-bounds/\n  return ranges\n}\n\nfunction getFieldQueries(\n  queries: Array<DbQuery>,\n  fieldName: string\n): Array<DbQuery> {\n  return queries.filter(q => dbQueryToDottedField(q) === fieldName)\n}\n\nfunction getMostSpecificQuery(\n  queries: Array<DbQuery>,\n  [indexField]: [fieldName: string, sortDirection: number]\n): DbQuery | undefined {\n  const fieldQueries = getFieldQueries(queries, indexField)\n  // Assuming queries are sorted by specificity, the best bet is to pick the first query\n  return fieldQueries[0]\n}\n\nfunction resolveIndexFieldRanges(\n  context: IFilterContext,\n  query: DbQuery,\n  [field, sortDirection]: [fieldName: string, sortDirection: number]\n): {\n  rangeStarts: RangeBoundary\n  rangeEndings: RangeBoundary\n} {\n  // Tracking starts and ends separately instead of doing Array<[start, end]>\n  //  to simplify cartesian product creation later\n  const rangeStarts: RangeBoundary = []\n  const rangeEndings: RangeBoundary = []\n\n  const filter = getFilterStatement(query)\n\n  if (filter.comparator === DbComparator.IN && !Array.isArray(filter.value)) {\n    throw new Error(\"The argument to the `in` predicate should be an array\")\n  }\n\n  context.usedQueries.add(query)\n\n  switch (filter.comparator) {\n    case DbComparator.EQ:\n    case DbComparator.IN: {\n      const arr = Array.isArray(filter.value)\n        ? [...filter.value]\n        : [filter.value]\n\n      // Sort ranges by index sort direction\n      arr.sort((a: any, b: any): number => {\n        if (a === b) return 0\n        if (sortDirection === 1) return a > b ? 1 : -1\n        return a < b ? 1 : -1\n      })\n\n      let hasNull = false\n      for (const item of new Set(arr)) {\n        const value = toIndexFieldValue(item, filter)\n        if (value === null) hasNull = true\n        rangeStarts.push(value)\n        rangeEndings.push(getValueEdgeAfter(value))\n      }\n      // Special case: { eq: null } or { in: [null, `any`]} must also include values for undefined!\n      if (hasNull) {\n        rangeStarts.push(undefinedSymbol)\n        rangeEndings.push(getValueEdgeAfter(undefinedSymbol))\n      }\n      break\n    }\n    case DbComparator.LT:\n    case DbComparator.LTE: {\n      if (Array.isArray(filter.value))\n        throw new Error(`${filter.comparator} value must not be an array`)\n\n      const value = toIndexFieldValue(filter.value, filter)\n      const end =\n        filter.comparator === DbComparator.LT ? value : getValueEdgeAfter(value)\n\n      // Try to find matching GTE/GT filter\n      const start =\n        resolveRangeEdge(context, field, DbComparator.GTE) ??\n        resolveRangeEdge(context, field, DbComparator.GT, ValueEdges.AFTER)\n\n      // Do not include null or undefined in results unless null was requested explicitly\n      //\n      // Index ordering:\n      //  BinaryInfinityNegative\n      //  null\n      //  Symbol(`undef`)\n      //  -10\n      //  10\n      //  `Hello`\n      //  [`Hello`]\n      //  BinaryInfinityPositive\n      const rangeHead =\n        value === null\n          ? BinaryInfinityNegative\n          : getValueEdgeAfter(undefinedSymbol)\n\n      rangeStarts.push(start ?? rangeHead)\n      rangeEndings.push(end)\n      break\n    }\n    case DbComparator.GT:\n    case DbComparator.GTE: {\n      if (Array.isArray(filter.value))\n        throw new Error(`${filter.comparator} value must not be an array`)\n\n      const value = toIndexFieldValue(filter.value, filter)\n      const start =\n        filter.comparator === DbComparator.GTE\n          ? value\n          : getValueEdgeAfter(value)\n\n      // Try to find matching LT/LTE\n      const end =\n        resolveRangeEdge(context, field, DbComparator.LTE, ValueEdges.AFTER) ??\n        resolveRangeEdge(context, field, DbComparator.LT)\n\n      const rangeTail =\n        value === null ? getValueEdgeAfter(null) : BinaryInfinityPositive\n\n      rangeStarts.push(start)\n      rangeEndings.push(end ?? rangeTail)\n      break\n    }\n    case DbComparator.NE:\n    case DbComparator.NIN: {\n      const arr = Array.isArray(filter.value)\n        ? [...filter.value]\n        : [filter.value]\n\n      // Sort ranges by index sort direction\n      arr.sort((a: any, b: any): number => {\n        if (a === b) return 0\n        if (sortDirection === 1) return a > b ? 1 : -1\n        return a < b ? 1 : -1\n      })\n      const hasNull = arr.some(value => value === null)\n\n      if (hasNull) {\n        rangeStarts.push(getValueEdgeAfter(undefinedSymbol))\n      } else {\n        rangeStarts.push(BinaryInfinityNegative)\n      }\n      for (const item of new Set(arr)) {\n        const value = toIndexFieldValue(item, filter)\n        if (value === null) continue // already handled via hasNull case above\n        rangeEndings.push(value)\n        rangeStarts.push(getValueEdgeAfter(value))\n      }\n      rangeEndings.push(BinaryInfinityPositive)\n      break\n    }\n    default:\n      throw new Error(`Unsupported predicate: ${filter.comparator}`)\n  }\n  return { rangeStarts, rangeEndings }\n}\n\nfunction resolveRangeEdge(\n  context: IFilterContext,\n  indexField: string,\n  predicate: DbComparator,\n  edge: ValueEdges = ValueEdges.EQ\n): IndexFieldValue | RangeEdgeBefore | RangeEdgeAfter | undefined {\n  const fieldQueries = getFieldQueries(context.dbQueries, indexField)\n  for (const dbQuery of fieldQueries) {\n    if (context.usedQueries.has(dbQuery)) {\n      continue\n    }\n    const filterStatement = getFilterStatement(dbQuery)\n    if (filterStatement.comparator !== predicate) {\n      continue\n    }\n    context.usedQueries.add(dbQuery)\n    const value = filterStatement.value\n    if (Array.isArray(value)) {\n      throw new Error(`Range filter ${predicate} should not have array value`)\n    }\n    if (typeof value === `object` && value !== null) {\n      throw new Error(\n        `Range filter ${predicate} should not have value of type ${typeof value}`\n      )\n    }\n    if (edge === 0) {\n      return value\n    }\n    return edge < 0 ? getValueEdgeBefore(value) : getValueEdgeAfter(value)\n  }\n  return undefined\n}\n\n/**\n * Returns the edge after the given value, suitable for lmdb range queries.\n *\n * Example:\n * Get all items from index starting with [\"foo\"] prefix up to the next existing prefix:\n *\n * ```js\n *   db.getRange({ start: [\"foo\"], end: [getValueEdgeAfter(\"foo\")] })\n * ```\n *\n * This method relies on ordered-binary format used by lmdb-store to persist keys\n * and assumes keys are composite and represented as arrays.\n *\n * Implementation detail: ordered-binary treats `null` as multipart separator within binary sequence\n */\nfunction getValueEdgeAfter(value: IndexFieldValue): RangeEdgeAfter {\n  return [value, BinaryInfinityPositive]\n}\nfunction getValueEdgeBefore(value: IndexFieldValue): RangeEdgeBefore {\n  return [undefinedSymbol, value]\n}\n\nfunction toIndexFieldValue(\n  filterValue: DbComparatorValue,\n  filter: IDbFilterStatement\n): IndexFieldValue {\n  if (typeof filterValue === `object` && filterValue !== null) {\n    throw new Error(\n      `Bad filter value for predicate ${filter.comparator}: ${inspect(\n        filter.value\n      )}`\n    )\n  }\n  return filterValue\n}\n\nfunction getIdentifier(entry: IIndexEntry): number | string {\n  const id = entry.key[entry.key.length - 1]\n  if (typeof id !== `number` && typeof id !== `string`) {\n    const out = inspect(id)\n    throw new Error(\n      `Last element of index key is expected to be numeric or string id, got ${out}`\n    )\n  }\n  return id\n}\n"],"mappings":"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"}