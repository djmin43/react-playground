{"version":3,"file":"queries.js","names":["FLAG_DIRTY_NEW_PAGE","FLAG_DIRTY_TEXT","FLAG_DIRTY_DATA","FLAG_DIRTY_PAGE_CONTEXT","FLAG_ERROR_EXTRACTION","FLAG_RUNNING_INFLIGHT","initialState","byNode","Map","byConnection","queryNodes","trackedQueries","trackedComponents","deletedQueries","Set","dirtyQueriesListToEmitViaWebsocket","initialQueryState","dirty","running","initialComponentState","componentPath","query","pages","errors","queriesReducer","state","action","type","path","payload","get","contextModified","registerQuery","setFlag","trackDirtyQuery","registerComponent","add","delete","apiName","queryId","component","values","clearNodeDependencies","clearConnectionDependencies","clear","hasFlag","set","id","forEach","dep","nodeId","connection","addNodeDependency","addConnectionDependency","node","queriesByNode","queriesByConnection","internal","queryStateChunk","assertCorrectWorkerState","mergeWorkerDataDependencies","allFlags","flag","nodeQueries","queryIds","queryNodeIds","process","env","GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND","push","workerStateChunk","queryState","keys","queries","connectionName","workerId","size","Error"],"sources":["../../../src/redux/reducers/queries.ts"],"sourcesContent":["import {\n  ActionsUnion,\n  IComponentState,\n  IGatsbyState,\n  IQueryState,\n} from \"../types\"\n\ntype QueryId = string // page query path or static query id\ntype ComponentPath = string\ntype NodeId = string\ntype ConnectionName = string\n\nexport const FLAG_DIRTY_NEW_PAGE = 0b0001\nexport const FLAG_DIRTY_TEXT = 0b0010\nexport const FLAG_DIRTY_DATA = 0b0100\nexport const FLAG_DIRTY_PAGE_CONTEXT = 0b1000\n\nexport const FLAG_ERROR_EXTRACTION = 0b0001\n\nexport const FLAG_RUNNING_INFLIGHT = 0b0001\n\nconst initialState = (): IGatsbyState[\"queries\"] => {\n  return {\n    byNode: new Map<NodeId, Set<QueryId>>(),\n    byConnection: new Map<ConnectionName, Set<QueryId>>(),\n    queryNodes: new Map<QueryId, Set<NodeId>>(),\n    trackedQueries: new Map<QueryId, IQueryState>(),\n    trackedComponents: new Map<ComponentPath, IComponentState>(),\n    deletedQueries: new Set<QueryId>(),\n    dirtyQueriesListToEmitViaWebsocket: [],\n  }\n}\n\nconst initialQueryState = (): IQueryState => {\n  return {\n    dirty: -1, // unknown, must be set right after init\n    running: 0,\n  }\n}\n\nconst initialComponentState = (): IComponentState => {\n  return {\n    componentPath: ``,\n    query: ``,\n    pages: new Set<QueryId>(),\n    errors: 0,\n    // TODO: staticQueries: new Set<QueryId>()\n  }\n}\n\n/**\n * Tracks query dirtiness. Dirty queries are queries that:\n *\n * - depend on nodes or node collections (via `actions.createPageDependency`) that have changed.\n * - have been recently extracted (or their query text has changed)\n * - belong to newly created pages (or pages with modified context)\n *\n * Dirty queries must be re-ran.\n */\nexport function queriesReducer(\n  state: IGatsbyState[\"queries\"] = initialState(),\n  action: ActionsUnion\n): IGatsbyState[\"queries\"] {\n  switch (action.type) {\n    case `DELETE_CACHE`:\n      return initialState()\n\n    case `CREATE_PAGE`: {\n      const { path, componentPath } = action.payload\n      let query = state.trackedQueries.get(path)\n      if (!query || action.contextModified) {\n        query = registerQuery(state, path)\n        query.dirty = setFlag(\n          query.dirty,\n          action.contextModified ? FLAG_DIRTY_PAGE_CONTEXT : FLAG_DIRTY_NEW_PAGE\n        )\n        state = trackDirtyQuery(state, path)\n      }\n      registerComponent(state, componentPath).pages.add(path)\n      state.deletedQueries.delete(path)\n      return state\n    }\n    case `DELETE_PAGE`: {\n      // Don't actually remove the page query from trackedQueries, just mark it as \"deleted\". Why?\n      //   We promote a technique of a consecutive deletePage/createPage calls in onCreatePage hook,\n      //   see https://www.gatsbyjs.com/docs/creating-and-modifying-pages/#pass-context-to-pages\n      //   If we remove a query and then re-add, it will be marked as dirty.\n      //   This is OK for cold cache but with warm cache we will re-run all of those queries (unnecessarily).\n      //   We will reconcile the state after createPages API call and actually delete those queries.\n      state.deletedQueries.add(action.payload.path)\n      return state\n    }\n    case `API_FINISHED`: {\n      if (action.payload.apiName !== `createPages`) {\n        return state\n      }\n      for (const queryId of state.deletedQueries) {\n        for (const component of state.trackedComponents.values()) {\n          component.pages.delete(queryId)\n        }\n        state = clearNodeDependencies(state, queryId)\n        state = clearConnectionDependencies(state, queryId)\n        state.trackedQueries.delete(queryId)\n      }\n      state.deletedQueries.clear()\n      return state\n    }\n    case `QUERY_EXTRACTED`: {\n      // Note: this action is called even in case of\n      // extraction error or missing query (with query === ``)\n      // TODO: use hash instead of a query text\n      const { componentPath, query } = action.payload\n      const component = registerComponent(state, componentPath)\n      if (hasFlag(component.errors, FLAG_ERROR_EXTRACTION)) {\n        return state\n      }\n      if (component.query !== query) {\n        // Invalidate all pages associated with a component when query text changes\n        for (const queryId of component.pages) {\n          const query = state.trackedQueries.get(queryId)\n          if (query) {\n            query.dirty = setFlag(query.dirty, FLAG_DIRTY_TEXT)\n            state = trackDirtyQuery(state, queryId)\n          }\n        }\n        component.query = query\n      }\n      return state\n    }\n    case `QUERY_EXTRACTION_GRAPHQL_ERROR`:\n    case `QUERY_EXTRACTION_BABEL_ERROR`:\n    case `QUERY_EXTRACTION_BABEL_SUCCESS`: {\n      const { componentPath } = action.payload\n      const component = registerComponent(state, componentPath)\n      const set = action.type !== `QUERY_EXTRACTION_BABEL_SUCCESS`\n      component.errors = setFlag(component.errors, FLAG_ERROR_EXTRACTION, set)\n      return state\n    }\n    case `REPLACE_STATIC_QUERY`: {\n      // Only called when static query text has changed, so no need to compare\n      // TODO: unify the behavior?\n      const query = registerQuery(state, action.payload.id)\n      query.dirty = setFlag(query.dirty, FLAG_DIRTY_TEXT)\n      // static queries are not on demand, so skipping tracking which\n      // queries were marked dirty recently\n      // state = trackDirtyQuery(state, action.payload.id)\n      state.deletedQueries.delete(action.payload.id)\n      return state\n    }\n    case `REMOVE_STATIC_QUERY`: {\n      state.deletedQueries.add(action.payload)\n      return state\n    }\n    case `CREATE_COMPONENT_DEPENDENCY`: {\n      action.payload.forEach(dep => {\n        const { path: queryId, nodeId, connection } = dep\n\n        if (nodeId) {\n          state = addNodeDependency(state, queryId, nodeId)\n        }\n        if (connection) {\n          state = addConnectionDependency(state, queryId, connection)\n        }\n      })\n\n      return state\n    }\n    case `QUERY_START`: {\n      // Reset data dependencies as they will be updated when running the query\n      const { path } = action.payload\n      state = clearNodeDependencies(state, path)\n      state = clearConnectionDependencies(state, path)\n      const query = state.trackedQueries.get(path)\n      if (query) {\n        query.running = setFlag(query.running, FLAG_RUNNING_INFLIGHT)\n      }\n      return state\n    }\n    case `CREATE_NODE`:\n    case `DELETE_NODE`: {\n      const node = action.payload\n      if (!node) {\n        return state\n      }\n      const queriesByNode = state.byNode.get(node.id) ?? []\n      const queriesByConnection =\n        state.byConnection.get(node.internal.type) ?? []\n\n      for (const queryId of queriesByNode) {\n        const query = state.trackedQueries.get(queryId)\n        if (query) {\n          query.dirty = setFlag(query.dirty, FLAG_DIRTY_DATA)\n          state = trackDirtyQuery(state, queryId)\n        }\n      }\n      for (const queryId of queriesByConnection) {\n        const query = state.trackedQueries.get(queryId)\n        if (query) {\n          query.dirty = setFlag(query.dirty, FLAG_DIRTY_DATA)\n          state = trackDirtyQuery(state, queryId)\n        }\n      }\n      return state\n    }\n    case `PAGE_QUERY_RUN`: {\n      const { path } = action.payload\n      const query = registerQuery(state, path)\n      query.dirty = 0\n      query.running = 0 // TODO: also\n      return state\n    }\n    case `SET_PROGRAM_STATUS`: {\n      if (action.payload === `BOOTSTRAP_FINISHED`) {\n        // Reset the running state (as it could've been persisted)\n        for (const [, query] of state.trackedQueries) {\n          query.running = 0\n        }\n        // Reset list of dirty queries (this is used only to notify runtime and it could've been persisted)\n        state.dirtyQueriesListToEmitViaWebsocket = []\n      }\n      return state\n    }\n    case `QUERY_CLEAR_DIRTY_QUERIES_LIST_TO_EMIT_VIA_WEBSOCKET`: {\n      state.dirtyQueriesListToEmitViaWebsocket = []\n      return state\n    }\n    case `MERGE_WORKER_QUERY_STATE`: {\n      // This action may be dispatched in cases where queries might not be included in the merge data\n      if (!action.payload.queryStateChunk) {\n        return state\n      }\n\n      assertCorrectWorkerState(action.payload)\n\n      state = mergeWorkerDataDependencies(state, action.payload)\n      return state\n    }\n    default:\n      return state\n  }\n}\n\nfunction setFlag(allFlags: number, flag: number, set = true): number {\n  if (allFlags < 0) {\n    allFlags = 0\n  }\n  return set ? allFlags | flag : allFlags & ~flag\n}\n\nexport function hasFlag(allFlags: number, flag: number): boolean {\n  return allFlags >= 0 && (allFlags & flag) > 0\n}\n\nfunction addNodeDependency(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId,\n  nodeId: NodeId\n): IGatsbyState[\"queries\"] {\n  // Perf: using two-side maps.\n  //   Without additional `queryNodes` map we would have to loop through\n  //   all existing nodes in `clearNodeDependencies` to delete node <-> query dependency\n  let nodeQueries = state.byNode.get(nodeId)\n  if (!nodeQueries) {\n    nodeQueries = new Set<QueryId>()\n    state.byNode.set(nodeId, nodeQueries)\n  }\n  let queryNodes = state.queryNodes.get(queryId)\n  if (!queryNodes) {\n    queryNodes = new Set<NodeId>()\n    state.queryNodes.set(queryId, queryNodes)\n  }\n  nodeQueries.add(queryId)\n  queryNodes.add(nodeId)\n  return state\n}\n\nfunction addConnectionDependency(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId,\n  connection: ConnectionName\n): IGatsbyState[\"queries\"] {\n  // Note: not using two-side maps for connections as associated overhead\n  //   for small number of elements is greater then benefits, so no perf. gains\n  let queryIds = state.byConnection.get(connection)\n  if (!queryIds) {\n    queryIds = new Set()\n    state.byConnection.set(connection, queryIds)\n  }\n  queryIds.add(queryId)\n  return state\n}\n\nfunction clearNodeDependencies(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId\n): IGatsbyState[\"queries\"] {\n  const queryNodeIds = state.queryNodes.get(queryId) ?? new Set()\n  for (const nodeId of queryNodeIds) {\n    const nodeQueries = state.byNode.get(nodeId)\n    if (nodeQueries) {\n      nodeQueries.delete(queryId)\n    }\n  }\n  return state\n}\n\nfunction clearConnectionDependencies(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId\n): IGatsbyState[\"queries\"] {\n  for (const [, queryIds] of state.byConnection) {\n    queryIds.delete(queryId)\n  }\n  return state\n}\n\nfunction registerQuery(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId\n): IQueryState {\n  let query = state.trackedQueries.get(queryId)\n  if (!query) {\n    query = initialQueryState()\n    state.trackedQueries.set(queryId, query)\n  }\n  return query\n}\n\nfunction registerComponent(\n  state: IGatsbyState[\"queries\"],\n  componentPath: string\n): IComponentState {\n  let component = state.trackedComponents.get(componentPath)\n  if (!component) {\n    component = initialComponentState()\n    component.componentPath = componentPath\n    state.trackedComponents.set(componentPath, component)\n  }\n  return component\n}\n\nfunction trackDirtyQuery(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId\n): IGatsbyState[\"queries\"] {\n  if (process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND) {\n    state.dirtyQueriesListToEmitViaWebsocket.push(queryId)\n  }\n\n  return state\n}\n\ninterface IWorkerStateChunk {\n  workerId: number\n  queryStateChunk: IGatsbyState[\"queries\"]\n}\n\nfunction mergeWorkerDataDependencies(\n  state: IGatsbyState[\"queries\"],\n  workerStateChunk: IWorkerStateChunk\n): IGatsbyState[\"queries\"] {\n  const queryState = workerStateChunk.queryStateChunk\n\n  // First clear data dependencies for all queries tracked by worker\n  for (const queryId of queryState.trackedQueries.keys()) {\n    state = clearNodeDependencies(state, queryId)\n    state = clearConnectionDependencies(state, queryId)\n  }\n\n  // Now re-add all data deps from worker\n  for (const [nodeId, queries] of queryState.byNode) {\n    for (const queryId of queries) {\n      state = addNodeDependency(state, queryId, nodeId)\n    }\n  }\n  for (const [connectionName, queries] of queryState.byConnection) {\n    for (const queryId of queries) {\n      state = addConnectionDependency(state, queryId, connectionName)\n    }\n  }\n  return state\n}\n\nfunction assertCorrectWorkerState({\n  queryStateChunk,\n  workerId,\n}: IWorkerStateChunk): void {\n  if (queryStateChunk.deletedQueries.size !== 0) {\n    throw new Error(\n      `Assertion failed: workerState.deletedQueries.size === 0 (worker #${workerId})`\n    )\n  }\n  if (queryStateChunk.trackedComponents.size !== 0) {\n    throw new Error(\n      `Assertion failed: queryStateChunk.trackedComponents.size === 0 (worker #${workerId})`\n    )\n  }\n  for (const query of queryStateChunk.trackedQueries.values()) {\n    if (query.dirty) {\n      throw new Error(\n        `Assertion failed: all worker queries are not dirty (worker #${workerId})`\n      )\n    }\n    if (query.running) {\n      throw new Error(\n        `Assertion failed: all worker queries are not running (worker #${workerId})`\n      )\n    }\n  }\n}\n"],"mappings":"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"}