{"version":3,"file":"inference-metadata.js","names":["ignoredFields","Set","NodeInterfaceFields","initialTypeMetadata","incrementalReducer","state","action","type","typeDefs","Array","isArray","payload","ignoredTypes","reduce","typesWithoutInference","forEach","ignore","nodes","typeName","ignored","addNodes","types","disable","node","oldNode","internal","deleteNode","addNode","addedField","previousFields","fields","dirty","Object","keys","StepsEnum","initialState","step","initialBuild","typeMap","inferenceMetadataReducer","incrementalBuild"],"sources":["../../../src/redux/reducers/inference-metadata.ts"],"sourcesContent":["// Tracking structure of nodes to utilize this metadata for schema inference\n// Type descriptors stay relevant at any point in time making incremental inference trivial\nimport { omit } from \"lodash\"\nimport {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n} from \"../../schema/infer/inference-metadata\"\nimport { NodeInterfaceFields } from \"../../schema/types/node-interface\"\nimport { typesWithoutInference } from \"../../schema/types/type-defs\"\n\nimport { IGatsbyState, ActionsUnion } from \"../types\"\n\nconst ignoredFields: Set<string> = new Set(NodeInterfaceFields)\n\nconst initialTypeMetadata = (): { ignoredFields: Set<string> } => {\n  return { ignoredFields }\n}\n\nconst incrementalReducer = (\n  state: IGatsbyState[\"inferenceMetadata\"][\"typeMap\"] = {},\n  action: ActionsUnion\n): IGatsbyState[\"inferenceMetadata\"][\"typeMap\"] => {\n  switch (action.type) {\n    case `CREATE_TYPES`: {\n      const typeDefs = Array.isArray(action.payload)\n        ? action.payload\n        : [action.payload]\n      const ignoredTypes = typeDefs.reduce(typesWithoutInference, [])\n      ignoredTypes.forEach(type => {\n        state[type] = ignore(state[type] || initialTypeMetadata())\n      })\n      return state\n    }\n\n    case `BUILD_TYPE_METADATA`: {\n      // Overwrites existing metadata\n      const { nodes, typeName } = action.payload\n      if (!state[typeName]?.ignored) {\n        state[typeName] = addNodes(initialTypeMetadata(), nodes)\n      }\n      return state\n    }\n\n    case `DISABLE_TYPE_INFERENCE`: {\n      // Note: types disabled here will be re-enabled after BUILD_TYPE_METADATA\n      const types = action.payload\n      types.forEach(type => {\n        state[type] = disable(state[type] || initialTypeMetadata())\n      })\n      return state\n    }\n\n    case `CREATE_NODE`: {\n      const { payload: node, oldNode } = action\n      const { type } = node.internal\n      if (oldNode) {\n        state[type] = deleteNode(state[type] || initialTypeMetadata(), oldNode)\n      }\n      state[type] = addNode(state[type] || initialTypeMetadata(), node)\n      return state\n    }\n\n    case `DELETE_NODE`: {\n      const node = action.payload\n      if (!node) return state\n      const { type } = node.internal\n      state[type] = deleteNode(state[type] || initialTypeMetadata(), node)\n      return state\n    }\n\n    case `ADD_FIELD_TO_NODE`: {\n      const { payload: node, addedField } = action\n      const { type } = node.internal\n\n      // Must unregister previous fields first.\n      // Can't simply add { fields: { [addedField]: node.fields[addedField] } }\n      // because it will count `fields` key twice for the same node\n      const previousFields = omit(node.fields, [addedField])\n      state[type] = deleteNode(state[type], { ...node, fields: previousFields })\n      state[type] = addNode(state[type], { ...node, fields: node.fields })\n\n      // TODO: there might be an edge case when the same field is \"added\" twice.\n      //   Then we'll count it twice in metadata. The only way to avoid it as I see it\n      //   is to pass original node before modifications along with a new node\n      //   in action payload and utilize original `node.fields` in deleteNode call above\n      return state\n    }\n\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`: {\n      // Marking parent type as dirty so that it rebuilds\n      const { type } = action.payload.internal\n      state[type].dirty = true\n      return state\n    }\n\n    case `SET_SCHEMA`: {\n      Object.keys(state).forEach(type => {\n        state[type].dirty = false\n      })\n      return state\n    }\n\n    default:\n      return state\n  }\n}\n\nenum StepsEnum {\n  initialBuild = `initialBuild`,\n  incrementalBuild = `incrementalBuild`,\n}\n\nconst initialState = (): IGatsbyState[\"inferenceMetadata\"] => {\n  return {\n    step: StepsEnum.initialBuild, // `initialBuild` | `incrementalBuild`\n    typeMap: {},\n  }\n}\n\nexport const inferenceMetadataReducer = (\n  state: IGatsbyState[\"inferenceMetadata\"] = initialState(),\n  action: ActionsUnion\n): IGatsbyState[\"inferenceMetadata\"] => {\n  switch (action.type) {\n    case `CREATE_NODE`:\n    case `DELETE_NODE`:\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`:\n    case `ADD_FIELD_TO_NODE`: {\n      // Perf: disable incremental inference until the first schema build.\n      // There are plugins which create and delete lots of nodes during bootstrap,\n      // which makes this reducer to do a lot of unnecessary work.\n      // Instead we defer the initial metadata creation until the first schema build\n      // and then enable incremental updates explicitly\n      if (state.step === StepsEnum.initialBuild) {\n        return state\n      }\n      state.typeMap = incrementalReducer(state.typeMap, action)\n      return state\n    }\n\n    case `START_INCREMENTAL_INFERENCE`: {\n      return {\n        ...state,\n        step: StepsEnum.incrementalBuild,\n      }\n    }\n\n    case `DELETE_CACHE`: {\n      return initialState()\n    }\n\n    default: {\n      state.typeMap = incrementalReducer(state.typeMap, action)\n      return state\n    }\n  }\n}\n"],"mappings":"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"}