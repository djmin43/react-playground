{"version":3,"file":"add-inferred-fields.js","names":["_","require","ObjectTypeComposer","GraphQLList","invariant","report","getDataStore","addInferredFields","schemaComposer","typeComposer","exampleValue","typeMapping","parentSpan","config","getInferenceConfig","defaults","shouldAddFields","addInferredFieldsImpl","exampleObject","prefix","getTypeName","unsanitizedFieldPath","deprecatedNodeKeys","size","reportOnce","Array","from","join","module","exports","fields","Object","keys","forEach","unsanitizedKey","key","createFieldName","push","fieldsByKey","groupBy","field","possibleFields","selectedField","length","resolveMultipleFields","possibleFieldsNames","map","warn","fieldConfig","getFieldConfig","hasField","addFields","setFieldExtension","Set","selector","arrays","value","isArray","hasMapping","getFieldConfigFromMapping","includes","getFieldConfigFromFieldNameConvention","multiple","add","getSimpleFieldConfig","pop","split","extensions","proxy","type","nodeField","find","canonicalField","sortBy","mapping","path","link","by","foreignKey","replace","linkedTypesSet","linkedValues","linkedNodes","iterateNodes","node","get","has","internal","id","getNode","linkedTypes","typeName","sort","getOrCreateUTC","utc","setTypes","getOTC","setResolveType","is32BitInteger","isDate","dateformat","isFile","fileByRelativePath","Date","String","fieldTypeComposer","getFieldTC","lists","fieldType","getFieldType","ofType","createTypeName","create","setExtension","getExtension","addDerivedType","derivedTypeName","inferenceConfig","Error","suffix","slice","upperFirst","NON_ALPHA_NUMERIC_EXPR","RegExp","fieldName","replaced","match","char","index","hasExtension"],"sources":["../../../src/schema/infer/add-inferred-fields.js"],"sourcesContent":["const _ = require(`lodash`)\nconst { ObjectTypeComposer } = require(`graphql-compose`)\nconst { GraphQLList } = require(`graphql`)\nconst invariant = require(`invariant`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nimport { isFile } from \"./is-file\"\nimport { isDate } from \"../types/date\"\nimport { addDerivedType } from \"../types/derived-types\"\nimport { reportOnce } from \"../../utils/report-once\"\nimport { is32BitInteger } from \"../../utils/is-32-bit-integer\"\nconst { getDataStore } = require(`../../datastore`)\n\nconst addInferredFields = ({\n  schemaComposer,\n  typeComposer,\n  exampleValue,\n  typeMapping,\n  parentSpan,\n}) => {\n  const config = getInferenceConfig({\n    typeComposer,\n    defaults: {\n      shouldAddFields: true,\n    },\n  })\n  addInferredFieldsImpl({\n    schemaComposer,\n    typeComposer,\n    exampleObject: exampleValue,\n    prefix: typeComposer.getTypeName(),\n    unsanitizedFieldPath: [typeComposer.getTypeName()],\n    typeMapping,\n    config,\n  })\n\n  if (deprecatedNodeKeys.size > 0) {\n    reportOnce(\n      `The ___NODE convention is deprecated. Please use the @link directive instead.\\nType: ${typeComposer.getTypeName()}, Keys: ${Array.from(\n        deprecatedNodeKeys\n      ).join(`, `)}\\nMigration: https://gatsby.dev/node-convention-deprecation`,\n      `verbose`\n    )\n  }\n}\n\nmodule.exports = {\n  addInferredFields,\n}\n\nconst addInferredFieldsImpl = ({\n  schemaComposer,\n  typeComposer,\n  exampleObject,\n  typeMapping,\n  prefix,\n  unsanitizedFieldPath,\n  config,\n}) => {\n  const fields = []\n  Object.keys(exampleObject).forEach(unsanitizedKey => {\n    const key = createFieldName(unsanitizedKey)\n    fields.push({\n      key,\n      unsanitizedKey,\n      exampleValue: exampleObject[unsanitizedKey],\n    })\n  })\n\n  const fieldsByKey = _.groupBy(fields, field => field.key)\n\n  Object.keys(fieldsByKey).forEach(key => {\n    const possibleFields = fieldsByKey[key]\n    let selectedField\n    if (possibleFields.length > 1) {\n      const field = resolveMultipleFields(possibleFields)\n      const possibleFieldsNames = possibleFields\n        .map(field => `\\`${field.unsanitizedKey}\\``)\n        .join(`, `)\n      report.warn(\n        `Multiple node fields resolve to the same GraphQL field \\`${prefix}.${field.key}\\` - [${possibleFieldsNames}]. Gatsby will use \\`${field.unsanitizedKey}\\`.`\n      )\n      selectedField = field\n    } else {\n      selectedField = possibleFields[0]\n    }\n\n    const fieldConfig = getFieldConfig({\n      ...selectedField,\n      schemaComposer,\n      typeComposer,\n      prefix,\n      unsanitizedFieldPath,\n      typeMapping,\n      config,\n    })\n\n    if (!fieldConfig) return\n\n    if (!typeComposer.hasField(key)) {\n      if (config.shouldAddFields) {\n        typeComposer.addFields({ [key]: fieldConfig })\n        typeComposer.setFieldExtension(key, `createdFrom`, `inference`)\n      }\n    }\n  })\n\n  return typeComposer\n}\n\nconst deprecatedNodeKeys = new Set()\n\nconst getFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  prefix,\n  exampleValue,\n  key,\n  unsanitizedKey,\n  unsanitizedFieldPath,\n  typeMapping,\n  config,\n}) => {\n  const selector = `${prefix}.${key}`\n  unsanitizedFieldPath.push(unsanitizedKey)\n\n  let arrays = 0\n  let value = exampleValue\n  while (Array.isArray(value)) {\n    value = value[0]\n    arrays++\n  }\n\n  let fieldConfig\n  if (hasMapping(typeMapping, selector)) {\n    // TODO: Use `prefix` instead of `selector` in hasMapping and getFromMapping?\n    // i.e. does the config contain sanitized field names?\n    fieldConfig = getFieldConfigFromMapping({ typeMapping, selector })\n  } else if (unsanitizedKey.includes(`___NODE`)) {\n    // TODO(v5): Remove ability to use foreign keys like this (e.g. author___NODE___contact___email)\n    // and recommend using schema customization instead\n\n    fieldConfig = getFieldConfigFromFieldNameConvention({\n      schemaComposer,\n      value: exampleValue,\n      key: unsanitizedKey,\n    })\n    arrays = arrays + (value.multiple ? 1 : 0)\n\n    deprecatedNodeKeys.add(unsanitizedKey)\n  } else {\n    fieldConfig = getSimpleFieldConfig({\n      schemaComposer,\n      typeComposer,\n      key,\n      value,\n      selector,\n      unsanitizedFieldPath,\n      typeMapping,\n      config,\n      arrays,\n    })\n  }\n\n  unsanitizedFieldPath.pop()\n  if (!fieldConfig) return null\n\n  // Proxy resolver to unsanitized fieldName in case it contained invalid characters\n  if (key !== unsanitizedKey.split(`___NODE`)[0]) {\n    fieldConfig = {\n      ...fieldConfig,\n      extensions: {\n        ...(fieldConfig.extensions || {}),\n        proxy: { from: unsanitizedKey },\n      },\n    }\n  }\n\n  while (arrays > 0) {\n    fieldConfig = { ...fieldConfig, type: [fieldConfig.type] }\n    arrays--\n  }\n\n  return fieldConfig\n}\n\nconst resolveMultipleFields = possibleFields => {\n  const nodeField = possibleFields.find(field =>\n    field.unsanitizedKey.includes(`___NODE`)\n  )\n  if (nodeField) {\n    return nodeField\n  }\n\n  const canonicalField = possibleFields.find(\n    field => field.unsanitizedKey === field.key\n  )\n  if (canonicalField) {\n    return canonicalField\n  }\n\n  return _.sortBy(possibleFields, field => field.unsanitizedKey)[0]\n}\n\n// XXX(freiksenet): removing this as it's a breaking change\n// Deeper nested levels should be inferred as JSON.\n// const MAX_DEPTH = 5\n\nconst hasMapping = (mapping, selector) =>\n  mapping && Object.keys(mapping).includes(selector)\n\nconst getFieldConfigFromMapping = ({ typeMapping, selector }) => {\n  const [type, ...path] = typeMapping[selector].split(`.`)\n  return {\n    type,\n    extensions: {\n      link: { by: path.join(`.`) || `id` },\n    },\n  }\n}\n\n// probably should be in example value\nconst getFieldConfigFromFieldNameConvention = ({\n  schemaComposer,\n  value,\n  key,\n}) => {\n  const path = key.split(`___NODE___`)[1]\n  // Allow linking by nested fields, e.g. `author___NODE___contact___email`\n  const foreignKey = path && path.replace(/___/g, `.`)\n  const linkedTypesSet = new Set()\n\n  if (foreignKey) {\n    const linkedValues = new Set(value.linkedNodes)\n    getDataStore()\n      .iterateNodes()\n      .forEach(node => {\n        const value = _.get(node, foreignKey)\n        if (linkedValues.has(value)) {\n          linkedTypesSet.add(node.internal.type)\n        }\n      })\n  } else {\n    value.linkedNodes.forEach(id => {\n      const node = getDataStore().getNode(id)\n      if (node) {\n        linkedTypesSet.add(node.internal.type)\n      }\n    })\n  }\n\n  const linkedTypes = [...linkedTypesSet]\n\n  invariant(\n    linkedTypes.length,\n    `Encountered an error trying to infer a GraphQL type for: \\`${key}\\`. ` +\n      `There is no corresponding node with the \\`id\\` field matching: \"${value.linkedNodes}\".`\n  )\n\n  let type\n  // If the field value is an array that links to more than one type,\n  // create a GraphQLUnionType. Note that we don't support the case where\n  // scalar fields link to different types. Similarly, an array of objects\n  // with foreign-key fields will produce union types if those foreign-key\n  // fields are arrays, but not if they are scalars. See the tests for an example.\n  if (linkedTypes.length > 1) {\n    const typeName = linkedTypes.sort().join(``) + `Union`\n    type = schemaComposer.getOrCreateUTC(typeName, utc => {\n      utc.setTypes(linkedTypes.map(typeName => schemaComposer.getOTC(typeName)))\n      utc.setResolveType(node => node.internal.type)\n    })\n  } else {\n    type = linkedTypes[0]\n  }\n\n  return {\n    type,\n    extensions: {\n      link: { by: foreignKey || `id`, from: key },\n    },\n  }\n}\n\nconst getSimpleFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  key,\n  value,\n  selector,\n  unsanitizedFieldPath,\n  typeMapping,\n  config,\n  arrays,\n}) => {\n  switch (typeof value) {\n    case `boolean`:\n      return { type: `Boolean` }\n    case `number`:\n      return { type: is32BitInteger(value) ? `Int` : `Float` }\n    case `string`:\n      if (isDate(value)) {\n        return { type: `Date`, extensions: { dateformat: {} } }\n      }\n      if (isFile(unsanitizedFieldPath, value)) {\n        // NOTE: For arrays of files, where not every path references\n        // a File node in the db, it is semi-random if the field is\n        // inferred as File or String, since the exampleValue only has\n        // the first entry (which could point to an existing file or not).\n        return { type: `File`, extensions: { fileByRelativePath: {} } }\n      }\n      return { type: `String` }\n    case `object`:\n      if (value instanceof Date) {\n        return { type: `Date`, extensions: { dateformat: {} } }\n      }\n      if (value instanceof String) {\n        return { type: `String` }\n      }\n      if (value /* && depth < MAX_DEPTH*/) {\n        let fieldTypeComposer\n        if (typeComposer.hasField(key)) {\n          fieldTypeComposer = typeComposer.getFieldTC(key)\n          // If we have an object as a field value, but the field type is\n          // explicitly defined as something other than an ObjectType\n          // we can bail early.\n          if (!(fieldTypeComposer instanceof ObjectTypeComposer)) return null\n          // If the array depth of the field value and of the explicitly\n          // defined field type don't match we can also bail early.\n          let lists = 0\n          let fieldType = typeComposer.getFieldType(key)\n          while (fieldType.ofType) {\n            if (fieldType instanceof GraphQLList) lists++\n            fieldType = fieldType.ofType\n          }\n          if (lists !== arrays) return null\n        } else {\n          // When the field type has not been explicitly defined, we\n          // don't need to continue in case of @dontInfer\n          if (!config.shouldAddFields) return null\n\n          const typeName = createTypeName(selector)\n          if (schemaComposer.has(typeName)) {\n            // Type could have been already created via schema customization\n            fieldTypeComposer = schemaComposer.getOTC(typeName)\n          } else {\n            fieldTypeComposer = ObjectTypeComposer.create(\n              typeName,\n              schemaComposer\n            )\n            fieldTypeComposer.setExtension(`createdFrom`, `inference`)\n            fieldTypeComposer.setExtension(\n              `plugin`,\n              typeComposer.getExtension(`plugin`)\n            )\n            addDerivedType({\n              typeComposer,\n              derivedTypeName: fieldTypeComposer.getTypeName(),\n            })\n          }\n        }\n\n        // Inference config options are either explicitly defined on a type\n        // with directive/extension, or inherited from the parent type.\n        const inferenceConfig = getInferenceConfig({\n          typeComposer: fieldTypeComposer,\n          defaults: config,\n        })\n\n        return {\n          type: addInferredFieldsImpl({\n            schemaComposer,\n            typeComposer: fieldTypeComposer,\n            exampleObject: value,\n            typeMapping,\n            prefix: selector,\n            unsanitizedFieldPath,\n            config: inferenceConfig,\n          }),\n        }\n      }\n  }\n  throw new Error(`Can't determine type for \"${value}\" in \\`${selector}\\`.`)\n}\n\nconst createTypeName = selector => {\n  const keys = selector.split(`.`)\n  const suffix = keys.slice(1).map(_.upperFirst).join(``)\n  return `${keys[0]}${suffix}`\n}\n\nconst NON_ALPHA_NUMERIC_EXPR = new RegExp(`[^a-zA-Z0-9_]`, `g`)\n\n/**\n * GraphQL field names must be a string and cannot contain anything other than\n * alphanumeric characters and `_`. They also can't start with `__` which is\n * reserved for internal fields (`___foo` doesn't work either).\n */\nconst createFieldName = key => {\n  // Check if the key is really a string otherwise GraphQL will throw.\n  invariant(\n    typeof key === `string`,\n    `GraphQL field name (key) is not a string: \\`${key}\\`.`\n  )\n\n  const fieldName = key.split(`___NODE`)[0]\n  const replaced = fieldName.replace(NON_ALPHA_NUMERIC_EXPR, `_`)\n\n  // key is invalid; normalize with leading underscore and rest with x\n  if (replaced.match(/^__/)) {\n    return replaced.replace(/_/g, (char, index) => (index === 0 ? `_` : `x`))\n  }\n\n  // key is invalid (starts with numeric); normalize with leading underscore\n  if (replaced.match(/^[0-9]/)) {\n    return `_` + replaced\n  }\n\n  return replaced\n}\n\nconst getInferenceConfig = ({ typeComposer, defaults }) => {\n  return {\n    shouldAddFields: typeComposer.hasExtension(`infer`)\n      ? typeComposer.getExtension(`infer`)\n      : defaults.shouldAddFields,\n  }\n}\n"],"mappings":"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"}