{"version":3,"file":"inference-metadata.js","names":["getType","value","key","is32BitInteger","includes","looksLikeADate","Date","String","Array","isArray","length","Object","keys","updateValueDescriptorObject","typeInfo","nodeId","operation","metadata","path","push","dprops","forEach","v","descriptor","undefined","updateValueDescriptor","pop","updateValueDescriptorArray","item","updateValueDescriptorRelNodes","listOfNodeIds","delta","nodes","dirty","updateValueDescriptorString","empty","example","typeName","total","first","mergeObjectKeys","dpropsKeysA","dpropsKeysB","otherProps","Set","concat","descriptorsAreEqual","otherDescriptor","types","possibleTypes","otherTypes","childDescriptorsAreEqual","type","array","dpropsKeys","object","every","prop","nodeIds","relatedNode","id","Boolean","relatedNodeList","nodeFields","node","ignoredFields","filter","has","updateTypeMetadata","initialMetadata","disabled","ignored","fieldMap","field","ignore","set","disable","addNode","deleteNode","addNodes","state","isEmpty","hasNodes","typeMetadata","haveEqualFields","otherFieldMap","fields"],"sources":["../../../src/schema/infer/inference-metadata.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\n/*\n## Incrementally track the structure of nodes with metadata\n\nThis metadata can be later utilized for schema inference\n(via building `exampleValue` or directly)\n\n### Usage example:\n\n```javascript\n  const node1 = { id: '1', foo: 25, bar: 'str' }\n  const node2 = { id: '1', foo: 'conflict' }\n\n  let meta = { ignoredFields: new Set(['id']) }\n  meta = addNode(meta, node1)\n  meta = addNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 1, example: 'conflict' },\n  //   },\n  //   bar: {\n  //     string: { total: 1, example: 'str' },\n  //   },\n  // }\n\n  const example1 = getExampleObject({ meta, typeName, typeConflictReporter })\n  console.log(example1)\n  // outputs { bar: 'str' }\n  // and reports conflicts discovered\n\n  meta = deleteNode(meta, node2)\n  console.log(meta.fieldMap)\n  // outputs: {\n  //   foo: {\n  //     int: { total: 1, example: 25 },\n  //     string: { total: 0, example: 'conflict' },\n  //   },\n  //   bar: { string: { total: 1, example: 'str' } },\n  // }\n\n  const example2 = getExampleObject({ meta, typeName, typeConflictReporter })\n  // outputs: { foo: 25, bar: 'str' }\n```\n\n`addNode`, `deleteNode`, `getExampleObject` are O(N) where N is the number\nof fields in the node object (including nested fields)\n\n### Caveats\n\n* Conflict tracking for arrays is tricky, i.e.: { a: [5, \"foo\"] } and { a: [5] }, { a: [\"foo\"] }\n  are represented identically in metadata. To workaround it we additionally track first NodeId:\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `1` } }}\n  { a: { array: { item: { int: { total: 1, first: `1` }, string: { total: 1, first: `2` } }}\n  This way we can produce more useful conflict reports\n  (still rare edge cases possible when reporting may be confusing, i.e. when node is deleted)\n*/\n\nimport { isEqual } from \"lodash\"\nimport { is32BitInteger } from \"../../utils/is-32-bit-integer\"\nimport { looksLikeADate } from \"../types/date\"\nimport { Node } from \"../../../index\"\nimport { TypeConflictReporter } from \"./type-conflict-reporter\"\n\nexport interface ITypeInfo {\n  first?: string\n  total: number\n  example?: unknown\n}\n\nexport interface ITypeInfoString extends ITypeInfo {\n  empty: number\n  example: string\n}\n\nexport interface ITypeInfoDate extends ITypeInfo {\n  example: string | Date\n}\n\nexport interface ITypeInfoNumber extends ITypeInfo {\n  example: number\n}\n\nexport interface ITypeInfoBoolean extends ITypeInfo {\n  example: boolean\n}\n\nexport interface ITypeInfoArray extends ITypeInfo {\n  item: IValueDescriptor\n}\n\nexport interface ITypeInfoRelatedNodes extends ITypeInfo {\n  nodes: { [key: string]: number }\n}\n\nexport interface ITypeInfoObject extends ITypeInfo {\n  dprops: {\n    [name: string]: IValueDescriptor\n  }\n}\n\nexport interface IValueDescriptor {\n  int?: ITypeInfoNumber\n  float?: ITypeInfoNumber\n  date?: ITypeInfoDate\n  string?: ITypeInfoString\n  boolean?: ITypeInfoBoolean\n  array?: ITypeInfoArray\n  relatedNode?: ITypeInfoRelatedNodes\n  relatedNodeList?: ITypeInfoRelatedNodes\n  object?: ITypeInfoObject\n}\n\nexport type ValueType = keyof IValueDescriptor\n\nexport interface ITypeMetadata {\n  typeName?: string\n  disabled?: boolean\n  ignored?: boolean\n  dirty?: boolean\n  total?: number\n  ignoredFields?: Set<string>\n  fieldMap?: Record<string, IValueDescriptor>\n  typeConflictReporter?: TypeConflictReporter\n  [key: string]: unknown\n}\n\ntype Operation = \"add\" | \"del\"\n\nconst getType = (value: unknown, key: string): ValueType | \"null\" => {\n  // Staying as close as possible to GraphQL types\n  switch (typeof value) {\n    case `number`:\n      return is32BitInteger(value) ? `int` : `float`\n    case `string`:\n      if (key.includes(`___NODE`)) {\n        return `relatedNode`\n      }\n      return looksLikeADate(value) ? `date` : `string`\n    case `boolean`:\n      return `boolean`\n    case `object`:\n      if (value === null) return `null`\n      if (value instanceof Date) return `date`\n      if (value instanceof String) return `string`\n      if (Array.isArray(value)) {\n        if (value.length === 0) {\n          return `null`\n        }\n        return key.includes(`___NODE`) ? `relatedNodeList` : `array`\n      }\n      if (!Object.keys(value).length) return `null`\n      return `object`\n    default:\n      // bigint, symbol, function, unknown (host objects in IE were typeof \"unknown\", for example)\n      return `null`\n  }\n}\n\nconst updateValueDescriptorObject = (\n  value: Record<string, unknown>,\n  typeInfo: ITypeInfoObject,\n  nodeId: string,\n  operation: Operation,\n  metadata: ITypeMetadata,\n  path: Array<Record<string, unknown>>\n): void => {\n  path.push(value)\n\n  const { dprops = {} } = typeInfo\n  typeInfo.dprops = dprops\n\n  Object.keys(value).forEach(key => {\n    const v = value[key]\n\n    let descriptor = dprops[key]\n    if (descriptor === undefined) {\n      descriptor = {}\n      dprops[key] = descriptor\n    }\n\n    updateValueDescriptor(nodeId, key, v, operation, descriptor, metadata, path)\n  })\n\n  path.pop()\n}\n\nconst updateValueDescriptorArray = (\n  value: Array<unknown>,\n  key: string,\n  typeInfo: ITypeInfoArray,\n  nodeId: string,\n  operation: Operation,\n  metadata: ITypeMetadata,\n  path: Array<Record<string, unknown>>\n): void => {\n  value.forEach(item => {\n    let descriptor = typeInfo.item\n    if (descriptor === undefined) {\n      descriptor = {}\n      typeInfo.item = descriptor\n    }\n\n    updateValueDescriptor(\n      nodeId,\n      key,\n      item,\n      operation,\n      descriptor,\n      metadata,\n      path\n    )\n  })\n}\n\nconst updateValueDescriptorRelNodes = (\n  listOfNodeIds: Array<string>,\n  delta: number,\n  operation: Operation,\n  typeInfo: ITypeInfoRelatedNodes,\n  metadata: ITypeMetadata\n): void => {\n  const { nodes = {} } = typeInfo\n  typeInfo.nodes = nodes\n\n  listOfNodeIds.forEach(nodeId => {\n    nodes[nodeId] = (nodes[nodeId] || 0) + delta\n\n    // Treat any new related node addition or removal as a structural change\n    // FIXME: this will produce false positives as this node can be\n    //  of the same type as another node already in the map (but we don't know it here)\n    if (nodes[nodeId] === 0 || (operation === `add` && nodes[nodeId] === 1)) {\n      metadata.dirty = true\n    }\n  })\n}\n\nconst updateValueDescriptorString = (\n  value: string,\n  delta: number,\n  typeInfo: ITypeInfoString\n): void => {\n  if (value === ``) {\n    const { empty = 0 } = typeInfo\n    typeInfo.empty = empty + delta\n  }\n  typeInfo.example =\n    typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n}\n\nconst updateValueDescriptor = (\n  nodeId: string,\n  key: string,\n  value: unknown,\n  operation: Operation = `add`,\n  descriptor: IValueDescriptor,\n  metadata: ITypeMetadata,\n  path: Array<Record<string, unknown>>\n): void => {\n  // The object may be traversed multiple times from root.\n  // Each time it does it should not revisit the same node twice\n  if (path.includes(value as Record<string, unknown>)) {\n    return\n  }\n\n  const typeName = getType(value, key)\n\n  if (typeName === `null`) {\n    return\n  }\n\n  const delta = operation === `del` ? -1 : 1\n\n  let typeInfo: ITypeInfo | undefined = descriptor[typeName]\n  if (typeInfo === undefined) {\n    // eslint-disable-next-line no-undef\n    typeInfo = (descriptor[typeName] as ITypeInfo) = { total: 0 }\n  }\n  typeInfo.total += delta\n\n  // Keeping track of structural changes\n  // (when value of a new type is added or an existing type has no more values assigned)\n  if (typeInfo.total === 0 || (operation === `add` && typeInfo.total === 1)) {\n    metadata.dirty = true\n  }\n\n  // Keeping track of the first node for this type. Only used for better conflict reporting.\n  // (see Caveats section in the header comments)\n  if (operation === `add`) {\n    if (!typeInfo.first) {\n      typeInfo.first = nodeId\n    }\n  } else if (operation === `del`) {\n    if (typeInfo.first === nodeId || typeInfo.total === 0) {\n      typeInfo.first = undefined\n    }\n  }\n\n  switch (typeName) {\n    case `object`:\n      updateValueDescriptorObject(\n        value as Record<string, unknown>,\n        typeInfo as ITypeInfoObject,\n        nodeId,\n        operation,\n        metadata,\n        path\n      )\n      return\n    case `array`:\n      updateValueDescriptorArray(\n        value as Array<unknown>,\n        key,\n        typeInfo as ITypeInfoArray,\n        nodeId,\n        operation,\n        metadata,\n        path\n      )\n      return\n    case `relatedNode`:\n      updateValueDescriptorRelNodes(\n        [value as string],\n        delta,\n        operation,\n        typeInfo as ITypeInfoRelatedNodes,\n        metadata\n      )\n      return\n    case `relatedNodeList`:\n      updateValueDescriptorRelNodes(\n        value as Array<string>,\n        delta,\n        operation,\n        typeInfo as ITypeInfoRelatedNodes,\n        metadata\n      )\n      return\n    case `string`:\n      updateValueDescriptorString(\n        value as string,\n        delta,\n        typeInfo as ITypeInfoString\n      )\n      return\n  }\n\n  // int, float, boolean, null\n\n  typeInfo.example =\n    typeof typeInfo.example !== `undefined` ? typeInfo.example : value\n}\n\nconst mergeObjectKeys = (\n  dpropsKeysA: Record<string, unknown> = {},\n  dpropsKeysB: Record<string, unknown> = {}\n): Array<string> => {\n  const dprops = Object.keys(dpropsKeysA)\n  const otherProps = Object.keys(dpropsKeysB)\n  return [...new Set(dprops.concat(otherProps))]\n}\n\nconst descriptorsAreEqual = (\n  descriptor?: IValueDescriptor,\n  otherDescriptor?: IValueDescriptor\n): boolean => {\n  const types = possibleTypes(descriptor)\n  const otherTypes = possibleTypes(otherDescriptor)\n\n  const childDescriptorsAreEqual = (type: string): boolean => {\n    switch (type) {\n      case `array`:\n        return descriptorsAreEqual(\n          descriptor?.array?.item,\n          otherDescriptor?.array?.item\n        )\n      case `object`: {\n        const dpropsKeys = mergeObjectKeys(\n          descriptor?.object?.dprops,\n          otherDescriptor?.object?.dprops\n        )\n        return dpropsKeys.every(prop =>\n          descriptorsAreEqual(\n            descriptor?.object?.dprops[prop],\n            otherDescriptor?.object?.dprops[prop]\n          )\n        )\n      }\n      case `relatedNode`: {\n        const nodeIds = mergeObjectKeys(\n          descriptor?.relatedNode?.nodes,\n          otherDescriptor?.relatedNode?.nodes\n        )\n        // Must be present in both descriptors or absent in both\n        // in order to be considered equal\n        return nodeIds.every(\n          id =>\n            Boolean(descriptor?.relatedNode?.nodes[id]) ===\n            Boolean(otherDescriptor?.relatedNode?.nodes[id])\n        )\n      }\n      case `relatedNodeList`: {\n        const nodeIds = mergeObjectKeys(\n          descriptor?.relatedNodeList?.nodes,\n          otherDescriptor?.relatedNodeList?.nodes\n        )\n        return nodeIds.every(\n          id =>\n            Boolean(descriptor?.relatedNodeList?.nodes[id]) ===\n            Boolean(otherDescriptor?.relatedNodeList?.nodes[id])\n        )\n      }\n      default:\n        return true\n    }\n  }\n\n  // Equal when all possible types are equal (including conflicts)\n  return isEqual(types, otherTypes) && types.every(childDescriptorsAreEqual)\n}\n\nconst nodeFields = (node: Node, ignoredFields = new Set()): Array<string> =>\n  Object.keys(node).filter(key => !ignoredFields.has(key))\n\nconst updateTypeMetadata = (\n  metadata = initialMetadata(),\n  operation: Operation,\n  node: Node\n): ITypeMetadata => {\n  if (metadata.disabled) {\n    return metadata\n  }\n  metadata.total = (metadata.total || 0) + (operation === `add` ? 1 : -1)\n  if (metadata.ignored) {\n    return metadata\n  }\n  const { ignoredFields, fieldMap = {} } = metadata\n\n  nodeFields(node, ignoredFields).forEach(field => {\n    let descriptor = fieldMap[field]\n    if (descriptor === undefined) {\n      descriptor = {}\n      fieldMap[field] = descriptor\n    }\n\n    updateValueDescriptor(\n      node.id,\n      field,\n      node[field],\n      operation,\n      descriptor,\n      metadata,\n      []\n    )\n  })\n  metadata.fieldMap = fieldMap\n  return metadata\n}\n\nconst ignore = (metadata = initialMetadata(), set = true): ITypeMetadata => {\n  metadata.ignored = set\n  metadata.fieldMap = {}\n  return metadata\n}\n\nconst disable = (metadata = initialMetadata(), set = true): ITypeMetadata => {\n  metadata.disabled = set\n  return metadata\n}\n\nconst addNode = (metadata: ITypeMetadata, node: Node): ITypeMetadata =>\n  updateTypeMetadata(metadata, `add`, node)\n\nconst deleteNode = (metadata: ITypeMetadata, node: Node): ITypeMetadata =>\n  updateTypeMetadata(metadata, `del`, node)\n\nconst addNodes = (\n  metadata = initialMetadata(),\n  nodes: Iterable<Node>\n): ITypeMetadata => {\n  let state = metadata\n  for (const node of nodes) {\n    state = addNode(state, node)\n  }\n  return state\n}\n\nconst possibleTypes = (descriptor: IValueDescriptor = {}): Array<ValueType> =>\n  Object.keys(descriptor).filter(\n    type => descriptor[type].total > 0\n  ) as Array<ValueType>\n\nconst isEmpty = ({ fieldMap }): boolean =>\n  Object.keys(fieldMap).every(\n    field => possibleTypes(fieldMap[field]).length === 0\n  )\n\n// Even empty type may still have nodes\nconst hasNodes = (typeMetadata: ITypeMetadata): boolean =>\n  (typeMetadata.total ?? 0) > 0\n\nconst haveEqualFields = (\n  { fieldMap = {} } = {},\n  { fieldMap: otherFieldMap = {} } = {}\n): boolean => {\n  const fields = mergeObjectKeys(fieldMap, otherFieldMap)\n  return fields.every(field =>\n    descriptorsAreEqual(fieldMap[field], otherFieldMap[field])\n  )\n}\n\nconst initialMetadata = (state?: Record<string, unknown>): ITypeMetadata => {\n  return {\n    typeName: undefined,\n    disabled: false,\n    ignored: false,\n    dirty: false,\n    total: 0,\n    ignoredFields: undefined,\n    fieldMap: {},\n    ...state,\n  }\n}\n\nexport {\n  addNode,\n  addNodes,\n  deleteNode,\n  ignore,\n  disable,\n  isEmpty,\n  hasNodes,\n  haveEqualFields,\n  initialMetadata,\n}\n"],"mappings":"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"}