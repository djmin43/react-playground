{"version":3,"file":"schema.js","names":["_","require","invariant","isSpecifiedScalarType","isIntrospectionType","assertValidName","GraphQLNonNull","GraphQLList","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","ObjectTypeComposer","InterfaceTypeComposer","UnionTypeComposer","InputTypeComposer","ScalarTypeComposer","EnumTypeComposer","getDataStore","getNode","getNodesByType","apiRunner","report","addNodeInterfaceFields","overridableBuiltInTypeNames","builtInScalarTypeNames","addInferredTypes","addRemoteFileInterfaceFields","findOne","findManyPaginated","wrappingResolver","defaultResolver","processFieldExtensions","internalExtensionNames","isASTDocument","parseTypeDef","reportParsingError","printTypeDefinitions","buildSchema","schemaComposer","types","typeMapping","fieldExtensions","thirdPartySchemas","printConfig","enginePrintConfig","typeConflictReporter","inferenceMetadata","parentSpan","ready","updateSchemaComposer","schema","freezeTypeComposers","module","exports","excluded","Set","Array","from","values","forEach","tc","isCompositeTC","has","getTypeName","type","getType","activity","phantomActivity","start","addTypes","span","end","addInferredChildOfExtensions","process","env","GATSBY_SKIP_WRITING_SCHEMA_TO_FILE","config","addSetFieldsOnGraphQLNodeTypeFields","addConvenienceChildrenFields","Promise","all","map","typeComposer","processTypeComposer","checkQueryableInterfaces","addThirdPartySchemas","addCustomResolveFunctions","attachTracingResolver","hasInterface","determineSearchableFields","addTypeToRootQuery","isNodeInterface","fieldNames","query","typeName","camelCase","queryAll","convenienceChild","convenienceChildren","typeOrTypeDef","plugin","parsedTypes","createdFrom","parseTypes","doc","error","processAddedType","isGatsbyType","createTypeComposerFromGatsbyType","checkIsAllowedTypeName","get","mergeTypes","name","typeOwner","getExtension","isOverridableBuiltInType","isSafeMerge","hasExtension","warn","mergeFields","fields","getFields","getInterfaces","iface","addInterface","mergeResolveType","extensions","isNamedTypeComposer","convertDirectivesToExtensions","getDirectives","extendExtensions","getExtensions","addExtensions","add","getResolveType","setResolveType","node","internal","addSchemaMustHaveType","directives","args","setExtension","hasCorrectIdField","hasField","getFieldType","toString","panic","getFieldNames","fieldName","setFieldExtension","getFieldDirectives","getFieldExtensions","Object","keys","filter","includes","definition","getDirective","defaultValue","undefined","arg","argumentDef","find","value","validate","message","endsWith","kind","GatsbyGraphQLTypeKind","OBJECT","createTemp","typeMapper","convertOutputFieldConfigMap","interfaces","tmpComposer","createInterfaceTC","getIFTC","INPUT_OBJECT","convertInputFieldConfigMap","UNION","createObjectTC","getOTC","INTERFACE","ENUM","SCALAR","JSON","stringify","result","nodes","traceId","addNestedFields","schemaQueryType","getQueryType","queryTC","createTempTC","processThirdPartyTypeFields","Query","addFields","getTypeMap","typeHasFields","_fields","createTC","resetOverriddenThirdPartyTypeFields","getFieldExtension","removeField","fieldType","String","replace","extendField","intermediateSchema","createResolvers","resolvers","ignoreNonexistentTypes","fieldConfig","originalFieldConfig","getFieldConfig","originalTypeName","originalResolver","resolve","fieldTypeName","isArray","stringifyArray","newConfig","source","context","info","defaultFieldResolver","extendFieldExtensions","needsResolve","field","getField","resolver","dateformat","searchable","SEARCHABLE_ENUM","SEARCHABLE","sortable","SORTABLE_ENUM","SORTABLE","proxy","isEmpty","DEPRECATED_SEARCHABLE","DEPRECATED_SORTABLE","parentTypesToChildren","Map","mimeTypesToChildren","typesHandlingMimeTypes","mimeType","set","mimeTypes","parentType","children","parent","getAnyTC","child","createChildrenField","createChildField","parentTypes","isExplicitChild","childTypeComposer","childOfExtension","parentMimeTypes","some","addInferredChildOfExtension","shouldInfer","parentTypeName","childNodeTypes","iterateNodesByType","childNode","push","description","path","nodeModel","getNodesByIds","ids","length","sortInputTC","getSortInput","filterInputTC","getFilterInput","paginationTC","getPagination","queryName","queryNamePlural","sort","skip","limit","makeFieldNonNull","definitions","def","parsedType","makeSchemaDef","ifaceName","_gqType","delete","arr","item","Error","ofType","v","parseValue","interfaceTypeComposer","queryableInterfaces","incorrectTypes","size","t","join","entries","setField","resolveType"],"sources":["../../src/schema/schema.js"],"sourcesContent":["const _ = require(`lodash`)\nconst invariant = require(`invariant`)\nconst {\n  isSpecifiedScalarType,\n  isIntrospectionType,\n  assertValidName,\n  GraphQLNonNull,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n} = require(`graphql`)\nconst {\n  ObjectTypeComposer,\n  InterfaceTypeComposer,\n  UnionTypeComposer,\n  InputTypeComposer,\n  ScalarTypeComposer,\n  EnumTypeComposer,\n} = require(`graphql-compose`)\nconst { getDataStore, getNode, getNodesByType } = require(`../datastore`)\n\nconst apiRunner = require(`../utils/api-runner-node`)\nconst report = require(`gatsby-cli/lib/reporter`)\nconst { addNodeInterfaceFields } = require(`./types/node-interface`)\nconst {\n  overridableBuiltInTypeNames,\n  builtInScalarTypeNames,\n} = require(`./types/built-in-types`)\nconst { addInferredTypes } = require(`./infer`)\nconst {\n  addRemoteFileInterfaceFields,\n} = require(`./types/remote-file-interface`)\n\nconst {\n  findOne,\n  findManyPaginated,\n  wrappingResolver,\n  defaultResolver,\n} = require(`./resolvers`)\nconst {\n  processFieldExtensions,\n  internalExtensionNames,\n} = require(`./extensions`)\nimport { getPagination } from \"./types/pagination\"\nimport { getSortInput, SORTABLE_ENUM } from \"./types/sort\"\nimport { getFilterInput, SEARCHABLE_ENUM } from \"./types/filter\"\nimport { isGatsbyType, GatsbyGraphQLTypeKind } from \"./types/type-builders\"\n\nconst {\n  isASTDocument,\n  parseTypeDef,\n  reportParsingError,\n} = require(`./types/type-defs`)\nconst { printTypeDefinitions } = require(`./print`)\n\nconst buildSchema = async ({\n  schemaComposer,\n  types,\n  typeMapping,\n  fieldExtensions,\n  thirdPartySchemas,\n  printConfig,\n  enginePrintConfig,\n  typeConflictReporter,\n  inferenceMetadata,\n  parentSpan,\n}) => {\n  // FIXME: consider removing .ready here - it is needed for various tests to pass (although probably harmless)\n  await getDataStore().ready()\n  await updateSchemaComposer({\n    schemaComposer,\n    types,\n    typeMapping,\n    fieldExtensions,\n    thirdPartySchemas,\n    printConfig,\n    enginePrintConfig,\n    typeConflictReporter,\n    inferenceMetadata,\n    parentSpan,\n  })\n  // const { printSchema } = require(`graphql`)\n  const schema = schemaComposer.buildSchema()\n  freezeTypeComposers(schemaComposer)\n\n  // console.log(printSchema(schema))\n  return schema\n}\n\nmodule.exports = {\n  buildSchema,\n}\n\n// Workaround for https://github.com/graphql-compose/graphql-compose/issues/319\n//  FIXME: remove this when fixed in graphql-compose\nconst freezeTypeComposers = (schemaComposer, excluded = new Set()) => {\n  Array.from(schemaComposer.values()).forEach(tc => {\n    const isCompositeTC =\n      tc instanceof ObjectTypeComposer || tc instanceof InterfaceTypeComposer\n\n    if (isCompositeTC && !excluded.has(tc.getTypeName())) {\n      // typeComposer.getType() actually mutates the underlying GraphQL type\n      //   and always re-assigns type._fields with a thunk.\n      //   It causes continuous redundant field re-definitions when running queries\n      //   (affects performance significantly).\n      //   Prevent the mutation and \"freeze\" the type:\n      const type = tc.getType()\n      tc.getType = () => type\n    }\n  })\n}\n\nconst updateSchemaComposer = async ({\n  schemaComposer,\n  types,\n  typeMapping,\n  fieldExtensions,\n  thirdPartySchemas,\n  printConfig,\n  enginePrintConfig,\n  typeConflictReporter,\n  inferenceMetadata,\n  parentSpan,\n}) => {\n  let activity = report.phantomActivity(`Add explicit types`, {\n    parentSpan: parentSpan,\n  })\n  activity.start()\n  await addTypes({ schemaComposer, parentSpan: activity.span, types })\n  activity.end()\n\n  activity = report.phantomActivity(`Add inferred types`, {\n    parentSpan: parentSpan,\n  })\n  activity.start()\n  await addInferredTypes({\n    schemaComposer,\n    typeConflictReporter,\n    typeMapping,\n    inferenceMetadata,\n    parentSpan: activity.span,\n  })\n  addInferredChildOfExtensions({\n    schemaComposer,\n  })\n  activity.end()\n\n  activity = report.phantomActivity(`Processing types`, {\n    parentSpan: parentSpan,\n  })\n  activity.start()\n  if (!process.env.GATSBY_SKIP_WRITING_SCHEMA_TO_FILE) {\n    await printTypeDefinitions({\n      config: printConfig,\n      schemaComposer,\n      parentSpan: activity.span,\n    })\n    if (enginePrintConfig) {\n      // make sure to print schema that will be used when bundling graphql-engine\n      await printTypeDefinitions({\n        config: enginePrintConfig,\n        schemaComposer,\n        parentSpan: activity.span,\n      })\n    }\n  }\n  await addSetFieldsOnGraphQLNodeTypeFields({\n    schemaComposer,\n    parentSpan: activity.span,\n  })\n  await addConvenienceChildrenFields({\n    schemaComposer,\n    parentSpan: activity.span,\n  })\n  await Promise.all(\n    Array.from(new Set(schemaComposer.values())).map(typeComposer =>\n      processTypeComposer({\n        schemaComposer,\n        typeComposer,\n        fieldExtensions,\n        parentSpan: activity.span,\n      })\n    )\n  )\n  checkQueryableInterfaces({ schemaComposer, parentSpan: activity.span })\n  await addThirdPartySchemas({\n    schemaComposer,\n    thirdPartySchemas,\n    parentSpan: activity.span,\n  })\n  await addCustomResolveFunctions({ schemaComposer, parentSpan: activity.span })\n  attachTracingResolver({ schemaComposer, parentSpan: activity.span })\n  activity.end()\n}\n\nconst processTypeComposer = async ({\n  schemaComposer,\n  typeComposer,\n  fieldExtensions,\n  parentSpan,\n}) => {\n  if (typeComposer instanceof ObjectTypeComposer) {\n    await processFieldExtensions({\n      schemaComposer,\n      typeComposer,\n      fieldExtensions,\n      parentSpan,\n    })\n\n    if (typeComposer.hasInterface(`Node`)) {\n      await addNodeInterfaceFields({ schemaComposer, typeComposer })\n    }\n\n    if (typeComposer.hasInterface(`RemoteFile`)) {\n      addRemoteFileInterfaceFields(schemaComposer, typeComposer)\n    }\n\n    await determineSearchableFields({\n      schemaComposer,\n      typeComposer,\n      parentSpan,\n    })\n\n    if (typeComposer.hasInterface(`Node`)) {\n      await addTypeToRootQuery({ schemaComposer, typeComposer, parentSpan })\n    }\n  } else if (typeComposer instanceof InterfaceTypeComposer) {\n    if (isNodeInterface(typeComposer)) {\n      await addNodeInterfaceFields({ schemaComposer, typeComposer, parentSpan })\n\n      // We only process field extensions for queryable Node interfaces, so we get\n      // the input args on the root query type, e.g. `formatString` etc. for `dateformat`\n      await processFieldExtensions({\n        schemaComposer,\n        typeComposer,\n        fieldExtensions,\n        parentSpan,\n      })\n      await determineSearchableFields({\n        schemaComposer,\n        typeComposer,\n        parentSpan,\n      })\n      await addTypeToRootQuery({ schemaComposer, typeComposer, parentSpan })\n    }\n  }\n}\n\nconst fieldNames = {\n  query: typeName => _.camelCase(typeName),\n  queryAll: typeName => _.camelCase(`all ${typeName}`),\n  convenienceChild: typeName => _.camelCase(`child ${typeName}`),\n  convenienceChildren: typeName => _.camelCase(`children ${typeName}`),\n}\n\nconst addTypes = ({ schemaComposer, types, parentSpan }) => {\n  types.forEach(({ typeOrTypeDef, plugin }) => {\n    if (typeof typeOrTypeDef === `string`) {\n      typeOrTypeDef = parseTypeDef(typeOrTypeDef)\n    }\n\n    if (isASTDocument(typeOrTypeDef)) {\n      let parsedTypes\n      const createdFrom = `sdl`\n      try {\n        parsedTypes = parseTypes({\n          doc: typeOrTypeDef,\n          plugin,\n          createdFrom,\n          schemaComposer,\n          parentSpan,\n        })\n      } catch (error) {\n        reportParsingError(error)\n        return\n      }\n      parsedTypes.forEach(type => {\n        processAddedType({\n          schemaComposer,\n          type,\n          parentSpan,\n          createdFrom,\n          plugin,\n        })\n      })\n    } else if (isGatsbyType(typeOrTypeDef)) {\n      const type = createTypeComposerFromGatsbyType({\n        schemaComposer,\n        type: typeOrTypeDef,\n        parentSpan,\n      })\n\n      if (type) {\n        const typeName = type.getTypeName()\n        const createdFrom = `typeBuilder`\n        checkIsAllowedTypeName(typeName)\n        if (schemaComposer.has(typeName)) {\n          const typeComposer = schemaComposer.get(typeName)\n          mergeTypes({\n            schemaComposer,\n            typeComposer,\n            type,\n            plugin,\n            createdFrom,\n            parentSpan,\n          })\n        } else {\n          processAddedType({\n            schemaComposer,\n            type,\n            parentSpan,\n            createdFrom,\n            plugin,\n          })\n        }\n      }\n    } else {\n      const typeName = typeOrTypeDef.name\n      const createdFrom = `graphql-js`\n      checkIsAllowedTypeName(typeName)\n      if (schemaComposer.has(typeName)) {\n        const typeComposer = schemaComposer.get(typeName)\n        mergeTypes({\n          schemaComposer,\n          typeComposer,\n          type: typeOrTypeDef,\n          plugin,\n          createdFrom,\n          parentSpan,\n        })\n      } else {\n        processAddedType({\n          schemaComposer,\n          type: typeOrTypeDef,\n          parentSpan,\n          createdFrom,\n          plugin,\n        })\n      }\n    }\n  })\n}\n\nconst mergeTypes = ({\n  schemaComposer,\n  typeComposer,\n  type,\n  plugin,\n  createdFrom,\n  parentSpan,\n}) => {\n  // The merge is considered safe when a user or a plugin owning the type extend this type\n  // TODO: add proper conflicts detection and reporting (on the field level)\n  const typeOwner = typeComposer.getExtension(`plugin`)\n  const isOverridableBuiltInType =\n    !typeOwner && overridableBuiltInTypeNames.has(typeComposer.getTypeName())\n\n  const isSafeMerge =\n    !plugin ||\n    plugin.name === `default-site-plugin` ||\n    plugin.name === typeOwner ||\n    typeComposer.hasExtension(`isPlaceholder`) ||\n    isOverridableBuiltInType\n\n  if (!isSafeMerge) {\n    if (typeOwner) {\n      report.warn(\n        `Plugin \\`${plugin.name}\\` has customized the GraphQL type ` +\n          `\\`${typeComposer.getTypeName()}\\`, which has already been defined ` +\n          `by the plugin \\`${typeOwner}\\`. ` +\n          `This could potentially cause conflicts.`\n      )\n    } else {\n      report.warn(\n        `Plugin \\`${plugin.name}\\` has customized the built-in Gatsby GraphQL type ` +\n          `\\`${typeComposer.getTypeName()}\\`. ` +\n          `This is allowed, but could potentially cause conflicts.`\n      )\n    }\n  }\n\n  if (\n    type instanceof ObjectTypeComposer ||\n    type instanceof InterfaceTypeComposer ||\n    type instanceof GraphQLObjectType ||\n    type instanceof GraphQLInterfaceType\n  ) {\n    mergeFields({ typeComposer, fields: type.getFields() })\n    type.getInterfaces().forEach(iface => typeComposer.addInterface(iface))\n  }\n\n  if (\n    type instanceof GraphQLInterfaceType ||\n    type instanceof InterfaceTypeComposer ||\n    type instanceof GraphQLUnionType ||\n    type instanceof UnionTypeComposer\n  ) {\n    mergeResolveType({ typeComposer, type })\n  }\n\n  let extensions = {}\n  if (isNamedTypeComposer(type)) {\n    if (createdFrom === `sdl`) {\n      extensions = convertDirectivesToExtensions(type, type.getDirectives())\n    } else {\n      typeComposer.extendExtensions(type.getExtensions())\n    }\n  }\n\n  addExtensions({\n    schemaComposer,\n    typeComposer,\n    extensions,\n    plugin,\n    createdFrom,\n  })\n\n  return true\n}\n\nconst processAddedType = ({\n  schemaComposer,\n  type,\n  parentSpan,\n  createdFrom,\n  plugin,\n}) => {\n  const typeName = schemaComposer.add(type)\n  const typeComposer = schemaComposer.get(typeName)\n  if (\n    typeComposer instanceof InterfaceTypeComposer ||\n    typeComposer instanceof UnionTypeComposer\n  ) {\n    if (!typeComposer.getResolveType()) {\n      typeComposer.setResolveType(node => node.internal.type)\n    }\n  }\n  schemaComposer.addSchemaMustHaveType(typeComposer)\n  let extensions = {}\n  if (createdFrom === `sdl`) {\n    extensions = convertDirectivesToExtensions(\n      typeComposer,\n      typeComposer.getDirectives()\n    )\n  }\n\n  addExtensions({\n    schemaComposer,\n    typeComposer,\n    extensions,\n    plugin,\n    createdFrom,\n  })\n\n  return typeComposer\n}\n\n/**\n * @param {import(\"graphql-compose\").AnyTypeComposer} typeComposer\n * @param {Array<import(\"graphql-compose\").Directive>} directives\n * @return {{infer?: boolean, mimeTypes?: { types: Array<string> }, childOf?: { types: Array<string> }, nodeInterface?: boolean}}\n */\nconst convertDirectivesToExtensions = (typeComposer, directives) => {\n  const extensions = {}\n  directives.forEach(({ name, args }) => {\n    switch (name) {\n      case `infer`:\n      case `dontInfer`: {\n        extensions[`infer`] = name === `infer`\n        break\n      }\n      case `mimeTypes`:\n        extensions[`mimeTypes`] = args\n        break\n      case `childOf`:\n        extensions[`childOf`] = args\n        break\n      case `nodeInterface`:\n        if (typeComposer instanceof InterfaceTypeComposer) {\n          extensions[`nodeInterface`] = true\n        }\n        break\n      default:\n    }\n  })\n\n  return extensions\n}\n\nconst addExtensions = ({\n  schemaComposer,\n  typeComposer,\n  extensions = {},\n  plugin,\n  createdFrom,\n}) => {\n  typeComposer.setExtension(`createdFrom`, createdFrom)\n  typeComposer.setExtension(`plugin`, plugin ? plugin.name : null)\n  typeComposer.extendExtensions(extensions)\n\n  if (\n    typeComposer instanceof InterfaceTypeComposer &&\n    isNodeInterface(typeComposer)\n  ) {\n    const hasCorrectIdField =\n      typeComposer.hasField(`id`) &&\n      typeComposer.getFieldType(`id`).toString() === `ID!`\n\n    if (!hasCorrectIdField) {\n      report.panic(\n        `Interfaces with the \\`nodeInterface\\` extension must have a field ` +\n          `\\`id\\` of type \\`ID!\\`. Check the type definition of ` +\n          `\\`${typeComposer.getTypeName()}\\`.`\n      )\n    }\n  }\n\n  if (\n    typeComposer instanceof ObjectTypeComposer ||\n    typeComposer instanceof InterfaceTypeComposer ||\n    typeComposer instanceof InputTypeComposer\n  ) {\n    typeComposer.getFieldNames().forEach(fieldName => {\n      typeComposer.setFieldExtension(fieldName, `createdFrom`, createdFrom)\n      typeComposer.setFieldExtension(\n        fieldName,\n        `plugin`,\n        plugin ? plugin.name : null\n      )\n\n      if (createdFrom === `sdl`) {\n        const directives = typeComposer.getFieldDirectives(fieldName)\n        directives.forEach(({ name, args }) => {\n          typeComposer.setFieldExtension(fieldName, name, args)\n        })\n      }\n\n      // Validate field extension args. `graphql-compose` already checks the\n      // type of directive args in `parseDirectives`, but we want to check\n      // extensions provided with type builders as well. Also, we warn if an\n      // extension option was provided which does not exist in the field\n      // extension definition.\n      const fieldExtensions = typeComposer.getFieldExtensions(fieldName)\n      const typeName = typeComposer.getTypeName()\n      Object.keys(fieldExtensions)\n        .filter(name => !internalExtensionNames.includes(name))\n        .forEach(name => {\n          const args = fieldExtensions[name]\n\n          if (!args || typeof args !== `object`) {\n            report.error(\n              `Field extension arguments must be provided as an object. ` +\n                `Received \"${args}\" on \\`${typeName}.${fieldName}\\`.`\n            )\n            return\n          }\n\n          try {\n            const definition = schemaComposer.getDirective(name)\n\n            // Handle `defaultValue` when not provided as directive\n            definition.args.forEach(({ name, defaultValue }) => {\n              if (args[name] === undefined && defaultValue !== undefined) {\n                args[name] = defaultValue\n              }\n            })\n\n            Object.keys(args).forEach(arg => {\n              const argumentDef = definition.args.find(\n                ({ name }) => name === arg\n              )\n              if (!argumentDef) {\n                report.error(\n                  `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                    `has invalid argument \\`${arg}\\`.`\n                )\n                return\n              }\n              const value = args[arg]\n              try {\n                validate(argumentDef.type, value)\n              } catch (error) {\n                report.error(\n                  `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                    `has argument \\`${arg}\\` with invalid value \"${value}\". ` +\n                    error.message\n                )\n              }\n            })\n          } catch (error) {\n            report.error(\n              `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                `is not available.`\n            )\n          }\n        })\n    })\n  }\n\n  return typeComposer\n}\n\nconst checkIsAllowedTypeName = name => {\n  invariant(\n    name !== `Node`,\n    `The GraphQL type \\`Node\\` is reserved for internal use.`\n  )\n  invariant(\n    !name.endsWith(`FilterInput`) && !name.endsWith(`SortInput`),\n    `GraphQL type names ending with \"FilterInput\" or \"SortInput\" are ` +\n      `reserved for internal use. Please rename \\`${name}\\`.`\n  )\n  invariant(\n    !builtInScalarTypeNames.includes(name),\n    `The GraphQL type \\`${name}\\` is reserved for internal use by ` +\n      `built-in scalar types.`\n  )\n  assertValidName(name)\n}\n\nconst createTypeComposerFromGatsbyType = ({\n  schemaComposer,\n  type,\n  parentSpan,\n}) => {\n  let typeComposer\n  switch (type.kind) {\n    case GatsbyGraphQLTypeKind.OBJECT: {\n      typeComposer = ObjectTypeComposer.createTemp({\n        ...type.config,\n        fields: () =>\n          schemaComposer.typeMapper.convertOutputFieldConfigMap(\n            type.config.fields\n          ),\n        interfaces: () => {\n          if (type.config.interfaces) {\n            return type.config.interfaces.map(iface => {\n              if (typeof iface === `string`) {\n                // Sadly, graphql-compose runs this function too early - before we have\n                // all of those interfaces actually created in the schema, so have to create\n                // a temporary placeholder composer :/\n                if (!schemaComposer.has(iface)) {\n                  const tmpComposer = schemaComposer.createInterfaceTC(iface)\n                  tmpComposer.setExtension(`isPlaceholder`, true)\n                  return tmpComposer\n                }\n                return schemaComposer.getIFTC(iface)\n              } else {\n                return iface\n              }\n            })\n          } else {\n            return []\n          }\n        },\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.INPUT_OBJECT: {\n      typeComposer = InputTypeComposer.createTemp({\n        ...type.config,\n        fields: schemaComposer.typeMapper.convertInputFieldConfigMap(\n          type.config.fields\n        ),\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.UNION: {\n      typeComposer = UnionTypeComposer.createTemp({\n        ...type.config,\n        types: () => {\n          if (type.config.types) {\n            return type.config.types.map(typeName => {\n              if (!schemaComposer.has(typeName)) {\n                // Sadly, graphql-compose runs this function too early - before we have\n                // all of those types actually created in the schema, so have to create\n                // a temporary placeholder composer :/\n                const tmpComposer = schemaComposer.createObjectTC(typeName)\n                tmpComposer.setExtension(`isPlaceholder`, true)\n                return tmpComposer\n              }\n              return schemaComposer.getOTC(typeName)\n            })\n          } else {\n            return []\n          }\n        },\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.INTERFACE: {\n      typeComposer = InterfaceTypeComposer.createTemp({\n        ...type.config,\n        fields: () =>\n          schemaComposer.typeMapper.convertOutputFieldConfigMap(\n            type.config.fields\n          ),\n        interfaces: () => {\n          if (type.config.interfaces) {\n            return type.config.interfaces.map(iface => {\n              if (typeof iface === `string`) {\n                // Sadly, graphql-compose runs this function too early - before we have\n                // all of those interfaces actually created in the schema, so have to create\n                // a temporary placeholder composer :/\n                if (!schemaComposer.has(iface)) {\n                  const tmpComposer = schemaComposer.createInterfaceTC(iface)\n                  tmpComposer.setExtension(`isPlaceholder`, true)\n                  return tmpComposer\n                }\n                return schemaComposer.getIFTC(iface)\n              } else {\n                return iface\n              }\n            })\n          } else {\n            return []\n          }\n        },\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.ENUM: {\n      typeComposer = EnumTypeComposer.createTemp(type.config)\n      break\n    }\n    case GatsbyGraphQLTypeKind.SCALAR: {\n      typeComposer = ScalarTypeComposer.createTemp(type.config)\n      break\n    }\n    default: {\n      report.warn(`Illegal type definition: ${JSON.stringify(type.config)}`)\n      typeComposer = null\n    }\n  }\n  if (typeComposer) {\n    // Workaround for https://github.com/graphql-compose/graphql-compose/issues/311\n    typeComposer.schemaComposer = schemaComposer\n  }\n  return typeComposer\n}\n\nconst addSetFieldsOnGraphQLNodeTypeFields = ({ schemaComposer, parentSpan }) =>\n  Promise.all(\n    Array.from(schemaComposer.values()).map(async tc => {\n      if (tc instanceof ObjectTypeComposer && tc.hasInterface(`Node`)) {\n        const typeName = tc.getTypeName()\n        const result = await apiRunner(`setFieldsOnGraphQLNodeType`, {\n          type: {\n            name: typeName,\n            get nodes() {\n              // TODO STRICT_MODE: return iterator instead of array\n              return getNodesByType(typeName)\n            },\n          },\n          traceId: `initial-setFieldsOnGraphQLNodeType`,\n          parentSpan,\n        })\n        if (result) {\n          // NOTE: `setFieldsOnGraphQLNodeType` only allows setting\n          // nested fields with a path as property name, i.e.\n          // `{ 'frontmatter.published': 'Boolean' }`, but not in the form\n          // `{ frontmatter: { published: 'Boolean' }}`\n          result.forEach(fields => tc.addNestedFields(fields))\n        }\n      }\n    })\n  )\n\nconst addThirdPartySchemas = ({\n  schemaComposer,\n  thirdPartySchemas,\n  parentSpan,\n}) => {\n  thirdPartySchemas.forEach(schema => {\n    const schemaQueryType = schema.getQueryType()\n    const queryTC = schemaComposer.createTempTC(schemaQueryType)\n    processThirdPartyTypeFields({\n      typeComposer: queryTC,\n      type: schemaQueryType,\n      schemaQueryType,\n    })\n    schemaComposer.Query.addFields(queryTC.getFields())\n\n    // Explicitly add the third-party schema's types, so they can be targeted\n    // in `createResolvers` API.\n    const types = schema.getTypeMap()\n    Object.keys(types).forEach(typeName => {\n      const type = types[typeName]\n      if (\n        type !== schemaQueryType &&\n        !isSpecifiedScalarType(type) &&\n        !isIntrospectionType(type) &&\n        type.name !== `Date` &&\n        type.name !== `JSON`\n      ) {\n        const typeHasFields =\n          type instanceof GraphQLObjectType ||\n          type instanceof GraphQLInterfaceType\n\n        // Workaround for an edge case typical for Relay Classic-compatible schemas.\n        // For example, GitHub API contains this piece:\n        //   type Query { relay: Query }\n        // And gatsby-source-graphql transforms it to:\n        //   type Query { github: GitHub }\n        //   type GitHub { relay: Query }\n        // The problem:\n        //   schemaComposer.createTC(type) for type `GitHub` will eagerly create type composers\n        //   for all fields (including `relay` and it's type: `Query` of the third-party schema)\n        //   This unexpected `Query` composer messes up with our own Query type composer and produces duplicate types.\n        //   The workaround is to make sure fields of the GitHub type are lazy and are evaluated only when\n        //   this Query type is already replaced with our own root `Query` type (see processThirdPartyTypeFields):\n        if (typeHasFields && typeof type._fields === `object`) {\n          const fields = type._fields\n          type._fields = () => fields\n        }\n        // ^^^ workaround done\n        const typeComposer = schemaComposer.createTC(type)\n        if (typeHasFields) {\n          processThirdPartyTypeFields({\n            typeComposer,\n            type,\n            schemaQueryType,\n          })\n        }\n        typeComposer.setExtension(`createdFrom`, `thirdPartySchema`)\n        schemaComposer.addSchemaMustHaveType(typeComposer)\n      }\n    })\n  })\n}\n\nconst resetOverriddenThirdPartyTypeFields = ({ typeComposer }) => {\n  // The problem: createResolvers API mutates third party schema instance.\n  //   For example it can add a new field referencing a type from our main schema\n  //   Then if we rebuild the schema this old type instance will sneak into\n  //   the new schema and produce the famous error:\n  //   \"Schema must contain uniquely named types but contains multiple types named X\"\n  // This function only affects schema rebuilding pathway.\n  //   It cleans up artifacts created by the `createResolvers` API of the previous build\n  //   so that we return the third party schema to its initial state (hence can safely re-add)\n  // TODO: the right way to fix this would be not to mutate the third party schema in\n  //   the first place. But unfortunately mutation happens in the `graphql-compose`\n  //   and we don't have an easy way to avoid it without major rework\n  typeComposer.getFieldNames().forEach(fieldName => {\n    const createdFrom = typeComposer.getFieldExtension(fieldName, `createdFrom`)\n    if (createdFrom === `createResolvers`) {\n      typeComposer.removeField(fieldName)\n      return\n    }\n    const config = typeComposer.getFieldExtension(\n      fieldName,\n      `originalFieldConfig`\n    )\n    if (config) {\n      typeComposer.removeField(fieldName)\n      typeComposer.addFields({\n        [fieldName]: config,\n      })\n    }\n  })\n}\n\nconst processThirdPartyTypeFields = ({\n  typeComposer,\n  type,\n  schemaQueryType,\n}) => {\n  // Fix for types that refer to Query. Thanks Relay Classic!\n  const fields = type.getFields()\n  Object.keys(fields).forEach(fieldName => {\n    // Remove customization that we could have added via `createResolvers`\n    // to make it work with schema rebuilding\n    const fieldType = String(fields[fieldName].type)\n    if (fieldType.replace(/[[\\]!]/g, ``) === schemaQueryType.name) {\n      typeComposer.extendField(fieldName, {\n        type: fieldType.replace(schemaQueryType.name, `Query`),\n      })\n    }\n  })\n  resetOverriddenThirdPartyTypeFields({ typeComposer })\n}\n\nconst addCustomResolveFunctions = async ({ schemaComposer, parentSpan }) => {\n  const intermediateSchema = schemaComposer.buildSchema()\n  const createResolvers = (\n    resolvers,\n    { ignoreNonexistentTypes = false } = {}\n  ) => {\n    Object.keys(resolvers).forEach(typeName => {\n      const fields = resolvers[typeName]\n      if (schemaComposer.has(typeName)) {\n        const tc = schemaComposer.getOTC(typeName)\n        Object.keys(fields).forEach(fieldName => {\n          const fieldConfig = fields[fieldName]\n          if (tc.hasField(fieldName)) {\n            const originalFieldConfig = tc.getFieldConfig(fieldName)\n            const originalTypeName = originalFieldConfig.type.toString()\n            const originalResolver = originalFieldConfig.resolve\n            let fieldTypeName\n            if (fieldConfig.type) {\n              fieldTypeName = Array.isArray(fieldConfig.type)\n                ? stringifyArray(fieldConfig.type)\n                : fieldConfig.type.toString()\n            }\n\n            if (\n              !fieldTypeName ||\n              fieldTypeName.replace(/!/g, ``) ===\n                originalTypeName.replace(/!/g, ``) ||\n              tc.getExtension(`createdFrom`) === `thirdPartySchema`\n            ) {\n              const newConfig = {}\n              if (fieldConfig.type) {\n                newConfig.type = fieldConfig.type\n              }\n              if (fieldConfig.args) {\n                newConfig.args = fieldConfig.args\n              }\n              if (fieldConfig.resolve) {\n                newConfig.resolve = (source, args, context, info) =>\n                  fieldConfig.resolve(source, args, context, {\n                    ...info,\n                    originalResolver:\n                      originalResolver || context.defaultFieldResolver,\n                  })\n                tc.extendFieldExtensions(fieldName, {\n                  needsResolve: true,\n                })\n              }\n              tc.extendField(fieldName, newConfig)\n\n              // See resetOverriddenThirdPartyTypeFields for explanation\n              if (tc.getExtension(`createdFrom`) === `thirdPartySchema`) {\n                tc.setFieldExtension(\n                  fieldName,\n                  `originalFieldConfig`,\n                  originalFieldConfig\n                )\n              }\n            } else if (fieldTypeName) {\n              report.warn(\n                `\\`createResolvers\\` passed resolvers for field ` +\n                  `\\`${typeName}.${fieldName}\\` with type \\`${fieldTypeName}\\`. ` +\n                  `Such a field with type \\`${originalTypeName}\\` already exists ` +\n                  `on the type. Use \\`createTypes\\` to override type fields.`\n              )\n            }\n          } else {\n            tc.addFields({\n              [fieldName]: fieldConfig,\n            })\n            // See resetOverriddenThirdPartyTypeFields for explanation\n            tc.setFieldExtension(fieldName, `createdFrom`, `createResolvers`)\n          }\n        })\n      } else if (!ignoreNonexistentTypes) {\n        report.warn(\n          `\\`createResolvers\\` passed resolvers for type \\`${typeName}\\` that ` +\n            `doesn't exist in the schema. Use \\`createTypes\\` to add the type ` +\n            `before adding resolvers.`\n        )\n      }\n    })\n  }\n  await apiRunner(`createResolvers`, {\n    intermediateSchema,\n    createResolvers,\n    traceId: `initial-createResolvers`,\n    parentSpan,\n  })\n}\n\nfunction attachTracingResolver({ schemaComposer }) {\n  schemaComposer.forEach(typeComposer => {\n    if (\n      typeComposer instanceof ObjectTypeComposer ||\n      typeComposer instanceof InterfaceTypeComposer\n    ) {\n      typeComposer.getFieldNames().forEach(fieldName => {\n        const field = typeComposer.getField(fieldName)\n        const resolver = wrappingResolver(field.resolve || defaultResolver)\n        typeComposer.extendField(fieldName, {\n          resolve: resolver,\n        })\n      })\n    }\n  })\n}\n\nconst determineSearchableFields = ({ schemaComposer, typeComposer }) => {\n  typeComposer.getFieldNames().forEach(fieldName => {\n    const field = typeComposer.getField(fieldName)\n    const extensions = typeComposer.getFieldExtensions(fieldName)\n    if (field.resolve) {\n      if (extensions.dateformat) {\n        typeComposer.extendFieldExtensions(fieldName, {\n          searchable: SEARCHABLE_ENUM.SEARCHABLE,\n          sortable: SORTABLE_ENUM.SORTABLE,\n          needsResolve: extensions.proxy ? true : false,\n        })\n      } else if (!_.isEmpty(field.args)) {\n        typeComposer.extendFieldExtensions(fieldName, {\n          searchable: SEARCHABLE_ENUM.DEPRECATED_SEARCHABLE,\n          sortable: SORTABLE_ENUM.DEPRECATED_SORTABLE,\n          needsResolve: true,\n        })\n      } else {\n        typeComposer.extendFieldExtensions(fieldName, {\n          searchable: SEARCHABLE_ENUM.SEARCHABLE,\n          sortable: SORTABLE_ENUM.SORTABLE,\n          needsResolve: true,\n        })\n      }\n    } else {\n      typeComposer.extendFieldExtensions(fieldName, {\n        searchable: SEARCHABLE_ENUM.SEARCHABLE,\n        sortable: SORTABLE_ENUM.SORTABLE,\n        needsResolve: false,\n      })\n    }\n  })\n}\n\nconst addConvenienceChildrenFields = ({ schemaComposer }) => {\n  const parentTypesToChildren = new Map()\n  const mimeTypesToChildren = new Map()\n  const typesHandlingMimeTypes = new Map()\n\n  schemaComposer.forEach(type => {\n    if (\n      (type instanceof ObjectTypeComposer ||\n        type instanceof InterfaceTypeComposer) &&\n      type.hasExtension(`mimeTypes`)\n    ) {\n      const { types } = type.getExtension(`mimeTypes`)\n      new Set(types).forEach(mimeType => {\n        if (!typesHandlingMimeTypes.has(mimeType)) {\n          typesHandlingMimeTypes.set(mimeType, new Set())\n        }\n        typesHandlingMimeTypes.get(mimeType).add(type)\n      })\n    }\n\n    if (\n      (type instanceof ObjectTypeComposer ||\n        type instanceof InterfaceTypeComposer) &&\n      type.hasExtension(`childOf`)\n    ) {\n      if (type instanceof ObjectTypeComposer && !type.hasInterface(`Node`)) {\n        report.error(\n          `The \\`childOf\\` extension can only be used on types that implement the \\`Node\\` interface.\\n` +\n            `Check the type definition of \\`${type.getTypeName()}\\`.`\n        )\n        return\n      }\n      if (type instanceof InterfaceTypeComposer && !isNodeInterface(type)) {\n        report.error(\n          `The \\`childOf\\` extension can only be used on types that implement the \\`Node\\` interface.\\n` +\n            `Check the type definition of \\`${type.getTypeName()}\\`.`\n        )\n        return\n      }\n\n      const { types, mimeTypes } = type.getExtension(`childOf`)\n\n      new Set(types).forEach(parentType => {\n        if (!parentTypesToChildren.has(parentType)) {\n          parentTypesToChildren.set(parentType, new Set())\n        }\n        parentTypesToChildren.get(parentType).add(type)\n      })\n      new Set(mimeTypes).forEach(mimeType => {\n        if (!mimeTypesToChildren.has(mimeType)) {\n          mimeTypesToChildren.set(mimeType, new Set())\n        }\n        mimeTypesToChildren.get(mimeType).add(type)\n      })\n    }\n  })\n\n  parentTypesToChildren.forEach((children, parent) => {\n    if (!schemaComposer.has(parent)) return\n    const typeComposer = schemaComposer.getAnyTC(parent)\n    if (\n      typeComposer instanceof InterfaceTypeComposer &&\n      !isNodeInterface(typeComposer)\n    ) {\n      report.error(\n        `With the \\`childOf\\` extension, children fields can only be added to ` +\n          `interfaces which implement the \\`Node\\` interface.\\n` +\n          `Check the type definition of \\`${typeComposer.getTypeName()}\\`.`\n      )\n      return\n    }\n    children.forEach(child => {\n      typeComposer.addFields(createChildrenField(child.getTypeName()))\n      typeComposer.addFields(createChildField(child.getTypeName()))\n    })\n  })\n\n  mimeTypesToChildren.forEach((children, mimeType) => {\n    const parentTypes = typesHandlingMimeTypes.get(mimeType)\n    if (parentTypes) {\n      parentTypes.forEach(typeComposer => {\n        if (\n          typeComposer instanceof InterfaceTypeComposer &&\n          !isNodeInterface(typeComposer)\n        ) {\n          report.error(\n            `With the \\`childOf\\` extension, children fields can only be added to ` +\n              `interfaces which implement the \\`Node\\` interface.\\n` +\n              `Check the type definition of \\`${typeComposer.getTypeName()}\\`.`\n          )\n          return\n        }\n        children.forEach(child => {\n          typeComposer.addFields(createChildrenField(child.getTypeName()))\n          typeComposer.addFields(createChildField(child.getTypeName()))\n        })\n      })\n    }\n  })\n}\n\nconst isExplicitChild = ({ typeComposer, childTypeComposer }) => {\n  if (!childTypeComposer.hasExtension(`childOf`)) {\n    return false\n  }\n  const childOfExtension = childTypeComposer.getExtension(`childOf`)\n  const { types: parentMimeTypes = [] } =\n    typeComposer.getExtension(`mimeTypes`) ?? {}\n\n  return (\n    childOfExtension?.types?.includes(typeComposer.getTypeName()) ||\n    childOfExtension?.mimeTypes?.some(mimeType =>\n      parentMimeTypes.includes(mimeType)\n    )\n  )\n}\n\nconst addInferredChildOfExtensions = ({ schemaComposer }) => {\n  schemaComposer.forEach(typeComposer => {\n    if (\n      typeComposer instanceof ObjectTypeComposer &&\n      typeComposer.hasInterface(`Node`)\n    ) {\n      addInferredChildOfExtension({\n        schemaComposer,\n        typeComposer,\n      })\n    }\n  })\n}\n\nconst addInferredChildOfExtension = ({ schemaComposer, typeComposer }) => {\n  const shouldInfer = typeComposer.getExtension(`infer`)\n  // With `@dontInfer`, only parent-child\n  // relations explicitly set with the `@childOf` extension are added.\n  if (shouldInfer === false) return\n\n  const parentTypeName = typeComposer.getTypeName()\n\n  // This is expensive.\n  // TODO: We should probably collect this info during inference metadata pass\n  const childNodeTypes = new Set()\n  for (const node of getDataStore().iterateNodesByType(parentTypeName)) {\n    const children = (node.children || []).map(getNode)\n    for (const childNode of children) {\n      if (childNode?.internal?.type) {\n        childNodeTypes.add(childNode.internal.type)\n      }\n    }\n  }\n\n  childNodeTypes.forEach(typeName => {\n    const childTypeComposer = schemaComposer.getAnyTC(typeName)\n    let childOfExtension = childTypeComposer.getExtension(`childOf`)\n\n    if (isExplicitChild({ typeComposer, childTypeComposer })) {\n      return\n    }\n    // Set `@childOf` extension automatically\n    // This will cause convenience children fields like `childImageSharp`\n    // to be added in `addConvenienceChildrenFields` method.\n    // Also required for proper printing of the `@childOf` directive in the snapshot plugin\n    if (!childOfExtension) {\n      childOfExtension = {}\n    }\n    if (!childOfExtension.types) {\n      childOfExtension.types = []\n    }\n    childOfExtension.types.push(parentTypeName)\n    childTypeComposer.setExtension(`childOf`, childOfExtension)\n  })\n}\n\nconst createChildrenField = typeName => {\n  return {\n    [fieldNames.convenienceChildren(typeName)]: {\n      type: () => [typeName],\n      description: `Returns all children nodes filtered by type ${typeName}`,\n      resolve(source, args, context) {\n        const { path } = context\n        return context.nodeModel.getNodesByIds(\n          { ids: source.children, type: typeName },\n          { path }\n        )\n      },\n    },\n  }\n}\n\nconst createChildField = typeName => {\n  return {\n    [fieldNames.convenienceChild(typeName)]: {\n      type: () => typeName,\n      description:\n        `Returns the first child node of type ${typeName} ` +\n        `or null if there are no children of given type on this node`,\n      resolve(source, args, context) {\n        const { path } = context\n        const result = context.nodeModel.getNodesByIds(\n          { ids: source.children, type: typeName },\n          { path }\n        )\n        if (result && result.length > 0) {\n          return result[0]\n        } else {\n          return null\n        }\n      },\n    },\n  }\n}\n\nconst addTypeToRootQuery = ({ schemaComposer, typeComposer }) => {\n  const sortInputTC = getSortInput({\n    schemaComposer,\n    typeComposer,\n  })\n  const filterInputTC = getFilterInput({\n    schemaComposer,\n    typeComposer,\n  })\n  const paginationTC = getPagination({\n    schemaComposer,\n    typeComposer,\n  })\n\n  const typeName = typeComposer.getTypeName()\n  // not strictly correctly, result is `npmPackage` and `allNpmPackage` from type `NPMPackage`\n  const queryName = fieldNames.query(typeName)\n  const queryNamePlural = fieldNames.queryAll(typeName)\n\n  schemaComposer.Query.addFields({\n    [queryName]: {\n      type: typeComposer,\n      args: {\n        ...filterInputTC.getFields(),\n      },\n      resolve: findOne(typeName),\n    },\n    [queryNamePlural]: {\n      type: paginationTC,\n      args: {\n        filter: filterInputTC,\n        sort: sortInputTC,\n        skip: `Int`,\n        limit: `Int`,\n      },\n      resolve: findManyPaginated(typeName),\n    },\n  }).makeFieldNonNull(queryNamePlural)\n}\n\nconst parseTypes = ({\n  doc,\n  plugin,\n  createdFrom,\n  schemaComposer,\n  parentSpan,\n}) => {\n  const types = []\n  doc.definitions.forEach(def => {\n    const name = def.name.value\n    checkIsAllowedTypeName(name)\n\n    if (schemaComposer.has(name)) {\n      // We don't check if ast.kind matches composer type, but rely\n      // that this will throw when something is wrong and get\n      // reported by `reportParsingError`.\n\n      // Keep the original type composer around\n      const typeComposer = schemaComposer.get(name)\n\n      // After this, the parsed type composer will be registered as the composer\n      // handling the type name (requires cleanup after merging, see below)\n      const parsedType = schemaComposer.typeMapper.makeSchemaDef(def)\n\n      // Merging types require implemented interfaces to already exist.\n      // Depending on type creation order, interface might have not been\n      // processed yet. We check if interface already exist and create\n      // placeholder for it, if it doesn't exist yet.\n      if (parsedType.getInterfaces) {\n        parsedType.getInterfaces().forEach(iface => {\n          const ifaceName = iface.getTypeName()\n          if (!schemaComposer.has(ifaceName)) {\n            const tmpComposer = schemaComposer.createInterfaceTC(ifaceName)\n            tmpComposer.setExtension(`isPlaceholder`, true)\n          }\n        })\n      }\n\n      // Merge the parsed type with the original\n      mergeTypes({\n        schemaComposer,\n        typeComposer,\n        type: parsedType,\n        plugin,\n        createdFrom,\n        parentSpan,\n      })\n\n      // Cleanup:\n      // Set the original type composer (with the merged fields added)\n      // as the correct composer for the type name and remove the temporary one\n      // `graphql-compose` doesn't make that easy 🤯\n      // TODO: clean this up when this issue is fixed:\n      //  https://github.com/graphql-compose/graphql-compose/issues/311\n      schemaComposer.set(typeComposer.getTypeName(), typeComposer)\n      schemaComposer.set(typeComposer._gqType, typeComposer)\n      schemaComposer.delete(parsedType._gqType)\n      schemaComposer.delete(parsedType)\n    } else {\n      const parsedType = schemaComposer.typeMapper.makeSchemaDef(def)\n      types.push(parsedType)\n    }\n  })\n  return types\n}\n\nconst stringifyArray = arr =>\n  `[${arr.map(item =>\n    Array.isArray(item) ? stringifyArray(item) : item.toString()\n  )}]`\n\n// TODO: Import this directly from graphql-compose once we update to v7\nconst isNamedTypeComposer = type =>\n  type instanceof ObjectTypeComposer ||\n  type instanceof InputTypeComposer ||\n  type instanceof ScalarTypeComposer ||\n  type instanceof EnumTypeComposer ||\n  type instanceof InterfaceTypeComposer ||\n  type instanceof UnionTypeComposer\n\nconst validate = (type, value) => {\n  if (type instanceof GraphQLNonNull) {\n    if (value == null) {\n      throw new Error(`Expected non-null field value.`)\n    }\n    return validate(type.ofType, value)\n  } else if (type instanceof GraphQLList) {\n    if (!Array.isArray(value)) {\n      throw new Error(`Expected array field value.`)\n    }\n    return value.map(v => validate(type.ofType, v))\n  } else {\n    return type.parseValue(value)\n  }\n}\n\nconst isNodeInterface = interfaceTypeComposer =>\n  interfaceTypeComposer.hasInterface(`Node`)\n\nconst checkQueryableInterfaces = ({ schemaComposer }) => {\n  const queryableInterfaces = new Set()\n  schemaComposer.forEach(type => {\n    if (type instanceof InterfaceTypeComposer && isNodeInterface(type)) {\n      queryableInterfaces.add(type.getTypeName())\n    }\n  })\n  const incorrectTypes = new Set()\n  schemaComposer.forEach(type => {\n    if (type instanceof ObjectTypeComposer) {\n      const interfaces = type.getInterfaces()\n      if (\n        interfaces.some(iface =>\n          queryableInterfaces.has(iface.getTypeName())\n        ) &&\n        !type.hasInterface(`Node`)\n      ) {\n        incorrectTypes.add(type.getTypeName())\n      }\n    }\n  })\n  if (incorrectTypes.size) {\n    report.panic(\n      `Types implementing queryable interfaces must also implement the \\`Node\\` ` +\n        `interface. Check the type definition of ` +\n        `${Array.from(incorrectTypes)\n          .map(t => `\\`${t}\\``)\n          .join(`, `)}.`\n    )\n  }\n}\n\nconst mergeFields = ({ typeComposer, fields }) =>\n  Object.entries(fields).forEach(([fieldName, fieldConfig]) => {\n    if (typeComposer.hasField(fieldName)) {\n      typeComposer.extendField(fieldName, fieldConfig)\n    } else {\n      typeComposer.setField(fieldName, fieldConfig)\n    }\n  })\n\nconst mergeResolveType = ({ typeComposer, type }) => {\n  if (\n    (type instanceof GraphQLInterfaceType ||\n      type instanceof GraphQLUnionType) &&\n    type.resolveType\n  ) {\n    typeComposer.setResolveType(type.resolveType)\n  }\n  if (\n    (type instanceof InterfaceTypeComposer ||\n      type instanceof UnionTypeComposer) &&\n    type.getResolveType()\n  ) {\n    typeComposer.setResolveType(type.getResolveType())\n  }\n  if (!typeComposer.getResolveType()) {\n    typeComposer.setResolveType(node => node?.internal?.type)\n  }\n}\n"],"mappings":"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"}