{"version":3,"file":"type-defs.js","names":["parse","Kind","GraphQLASTNodeKind","require","inferExtensionName","dontInferExtensionName","report","isASTDocument","typeOrTypeDef","kind","DOCUMENT","parseTypeDef","error","reportParsingError","message","source","locations","length","codeFrameColumns","frame","body","start","linesAbove","linesBelow","panic","typesWithoutInference","typeNames","definitions","forEach","def","directives","directive","name","value","push","isGatsbyType","config","extensions","module","exports"],"sources":["../../../src/schema/types/type-defs.js"],"sourcesContent":["const { parse, Kind: GraphQLASTNodeKind } = require(`graphql`)\nimport { isGatsbyType } from \"./type-builders\"\nconst { inferExtensionName, dontInferExtensionName } = require(`../extensions`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nconst isASTDocument = typeOrTypeDef =>\n  typeof typeOrTypeDef === `object` &&\n  typeOrTypeDef.kind &&\n  GraphQLASTNodeKind.DOCUMENT === typeOrTypeDef.kind\n\n/**\n * Parses type definition represented as an SDL string into an AST Document.\n * Type definitions of other formats (other than SDL) are returned as is\n */\nconst parseTypeDef = typeOrTypeDef => {\n  if (typeof typeOrTypeDef === `string`) {\n    try {\n      return parse(typeOrTypeDef)\n    } catch (error) {\n      reportParsingError(error)\n    }\n  }\n  return typeOrTypeDef\n}\n\nconst reportParsingError = error => {\n  const { message, source, locations } = error\n\n  if (source && locations && locations.length) {\n    const { codeFrameColumns } = require(`@babel/code-frame`)\n\n    const frame = codeFrameColumns(\n      source.body,\n      { start: locations[0] },\n      { linesAbove: 5, linesBelow: 5 }\n    )\n    report.panic(\n      `Encountered an error parsing the provided GraphQL type definitions:\\n` +\n        message +\n        `\\n\\n` +\n        frame +\n        `\\n`\n    )\n  } else {\n    throw error\n  }\n}\n\n/**\n * Given a type definition, collects type names that should skip the inference process\n */\nconst typesWithoutInference = (typeNames = [], typeOrTypeDef) => {\n  if (typeof typeOrTypeDef === `string`) {\n    typeOrTypeDef = parseTypeDef(typeOrTypeDef)\n  }\n  if (isASTDocument(typeOrTypeDef)) {\n    typeOrTypeDef.definitions.forEach(def => {\n      if (!def.directives) return\n\n      def.directives.forEach(directive => {\n        if (directive.name.value === dontInferExtensionName && def.name.value) {\n          typeNames.push(def.name.value)\n        }\n      })\n    })\n    return typeNames\n  }\n  if (isGatsbyType(typeOrTypeDef) && typeOrTypeDef.config) {\n    const { extensions = {}, name } = typeOrTypeDef.config\n    if (\n      name &&\n      (extensions[dontInferExtensionName] ||\n        extensions[inferExtensionName] === false)\n    ) {\n      typeNames.push(name)\n    }\n  }\n  return typeNames\n}\n\nmodule.exports = {\n  parseTypeDef,\n  reportParsingError,\n  typesWithoutInference,\n  isASTDocument,\n}\n"],"mappings":";;AACA;;AADA,MAAM;EAAEA,KAAF;EAASC,IAAI,EAAEC;AAAf,IAAsCC,OAAO,CAAE,SAAF,CAAnD;;AAEA,MAAM;EAAEC,kBAAF;EAAsBC;AAAtB,IAAiDF,OAAO,CAAE,eAAF,CAA9D;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAE,yBAAF,CAAtB;;AAEA,MAAMI,aAAa,GAAGC,aAAa,IACjC,OAAOA,aAAP,KAA0B,QAA1B,IACAA,aAAa,CAACC,IADd,IAEAP,kBAAkB,CAACQ,QAAnB,KAAgCF,aAAa,CAACC,IAHhD;AAKA;AACA;AACA;AACA;;;AACA,MAAME,YAAY,GAAGH,aAAa,IAAI;EACpC,IAAI,OAAOA,aAAP,KAA0B,QAA9B,EAAuC;IACrC,IAAI;MACF,OAAOR,KAAK,CAACQ,aAAD,CAAZ;IACD,CAFD,CAEE,OAAOI,KAAP,EAAc;MACdC,kBAAkB,CAACD,KAAD,CAAlB;IACD;EACF;;EACD,OAAOJ,aAAP;AACD,CATD;;AAWA,MAAMK,kBAAkB,GAAGD,KAAK,IAAI;EAClC,MAAM;IAAEE,OAAF;IAAWC,MAAX;IAAmBC;EAAnB,IAAiCJ,KAAvC;;EAEA,IAAIG,MAAM,IAAIC,SAAV,IAAuBA,SAAS,CAACC,MAArC,EAA6C;IAC3C,MAAM;MAAEC;IAAF,IAAuBf,OAAO,CAAE,mBAAF,CAApC;;IAEA,MAAMgB,KAAK,GAAGD,gBAAgB,CAC5BH,MAAM,CAACK,IADqB,EAE5B;MAAEC,KAAK,EAAEL,SAAS,CAAC,CAAD;IAAlB,CAF4B,EAG5B;MAAEM,UAAU,EAAE,CAAd;MAAiBC,UAAU,EAAE;IAA7B,CAH4B,CAA9B;IAKAjB,MAAM,CAACkB,KAAP,CACG,uEAAD,GACEV,OADF,GAEG,MAFH,GAGEK,KAHF,GAIG,IALL;EAOD,CAfD,MAeO;IACL,MAAMP,KAAN;EACD;AACF,CArBD;AAuBA;AACA;AACA;;;AACA,MAAMa,qBAAqB,GAAG,CAACC,SAAS,GAAG,EAAb,EAAiBlB,aAAjB,KAAmC;EAC/D,IAAI,OAAOA,aAAP,KAA0B,QAA9B,EAAuC;IACrCA,aAAa,GAAGG,YAAY,CAACH,aAAD,CAA5B;EACD;;EACD,IAAID,aAAa,CAACC,aAAD,CAAjB,EAAkC;IAChCA,aAAa,CAACmB,WAAd,CAA0BC,OAA1B,CAAkCC,GAAG,IAAI;MACvC,IAAI,CAACA,GAAG,CAACC,UAAT,EAAqB;MAErBD,GAAG,CAACC,UAAJ,CAAeF,OAAf,CAAuBG,SAAS,IAAI;QAClC,IAAIA,SAAS,CAACC,IAAV,CAAeC,KAAf,KAAyB5B,sBAAzB,IAAmDwB,GAAG,CAACG,IAAJ,CAASC,KAAhE,EAAuE;UACrEP,SAAS,CAACQ,IAAV,CAAeL,GAAG,CAACG,IAAJ,CAASC,KAAxB;QACD;MACF,CAJD;IAKD,CARD;IASA,OAAOP,SAAP;EACD;;EACD,IAAI,IAAAS,0BAAA,EAAa3B,aAAb,KAA+BA,aAAa,CAAC4B,MAAjD,EAAyD;IACvD,MAAM;MAAEC,UAAU,GAAG,EAAf;MAAmBL;IAAnB,IAA4BxB,aAAa,CAAC4B,MAAhD;;IACA,IACEJ,IAAI,KACHK,UAAU,CAAChC,sBAAD,CAAV,IACCgC,UAAU,CAACjC,kBAAD,CAAV,KAAmC,KAFjC,CADN,EAIE;MACAsB,SAAS,CAACQ,IAAV,CAAeF,IAAf;IACD;EACF;;EACD,OAAON,SAAP;AACD,CA3BD;;AA6BAY,MAAM,CAACC,OAAP,GAAiB;EACf5B,YADe;EAEfE,kBAFe;EAGfY,qBAHe;EAIflB;AAJe,CAAjB"}