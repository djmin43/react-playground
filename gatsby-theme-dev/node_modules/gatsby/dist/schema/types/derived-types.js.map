{"version":3,"file":"derived-types.js","names":["getDerivedTypes","typeComposer","derivedTypes","getExtension","Set","deleteFieldsOfDerivedTypes","getFieldNames","forEach","fieldName","fieldType","getField","type","has","getTypeName","removeField","removeTypeFromSchemaComposer","schemaComposer","delete","_gqType","clearDerivedTypes","typeName","values","derivedTypeComposer","getAnyTC","ObjectTypeComposer","InterfaceTypeComposer","inputTypeComposer","getInputTypeComposer","removeInputTypeComposer","setExtension","addDerivedType","derivedTypeName","add"],"sources":["../../../src/schema/types/derived-types.ts"],"sourcesContent":["/**\n * Derived types are types that make sense only when their base type exists\n *\n * Take this node for example:\n * {\n *   internal: { type: 'Foo' },\n *   fields: {\n *     bar: \"string\",\n *   }\n * }\n *\n * It will produce following types:\n * Foo\n * FooFields\n *\n * FooInputFilter\n * FooSortInput\n *\n * FooFieldsInputFilter\n * FooFieldsSortFilter\n * etc\n *\n * Derived types:\n *   Foo: FooFields, FooInputFilter, FooSortInput\n *   FooFields: FooFieldsInputFilter, FooFieldsSortFilter\n *\n * Caveats:\n *   Only types created via inference are marked as derived. So if in the example above\n *   user explicitly defines `FooFields` type (via `createTypes` call) it won't be considered\n *   a derived type\n */\nimport {\n  ObjectTypeComposer,\n  InterfaceTypeComposer,\n  ScalarTypeComposer,\n  SchemaComposer,\n  InputTypeComposer,\n  EnumTypeComposer,\n  UnionTypeComposer,\n} from \"graphql-compose\"\n\ntype AllTypeComposer =\n  | ObjectTypeComposer\n  | InputTypeComposer\n  | EnumTypeComposer\n  | InterfaceTypeComposer\n  | UnionTypeComposer\n  | ScalarTypeComposer\n\nconst getDerivedTypes = ({\n  typeComposer,\n}: {\n  typeComposer: AllTypeComposer\n}): Set<string> => {\n  const derivedTypes = typeComposer.getExtension(`derivedTypes`)\n  if (derivedTypes) {\n    return derivedTypes as Set<string>\n  }\n\n  return new Set()\n}\n\nexport const deleteFieldsOfDerivedTypes = ({ typeComposer }): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n\n  typeComposer.getFieldNames().forEach(fieldName => {\n    const fieldType = typeComposer.getField(fieldName).type\n\n    if (derivedTypes.has(fieldType.getTypeName())) {\n      typeComposer.removeField(fieldName)\n    }\n  })\n}\n\nconst removeTypeFromSchemaComposer = ({\n  schemaComposer,\n  typeComposer,\n}): void => {\n  schemaComposer.delete(typeComposer.getTypeName())\n  schemaComposer.delete((typeComposer as any)._gqType)\n  schemaComposer.delete(typeComposer)\n}\n\nexport const clearDerivedTypes = ({\n  schemaComposer,\n  typeComposer,\n}: {\n  schemaComposer: SchemaComposer<any>\n  typeComposer: AllTypeComposer\n}): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n\n  for (const typeName of derivedTypes.values()) {\n    const derivedTypeComposer = schemaComposer.getAnyTC(typeName)\n    clearDerivedTypes({ schemaComposer, typeComposer: derivedTypeComposer })\n    removeTypeFromSchemaComposer({\n      schemaComposer,\n      typeComposer: derivedTypeComposer,\n    })\n  }\n\n  if (\n    typeComposer instanceof ObjectTypeComposer ||\n    typeComposer instanceof InterfaceTypeComposer\n  ) {\n    const inputTypeComposer = typeComposer.getInputTypeComposer()\n    removeTypeFromSchemaComposer({\n      schemaComposer,\n      typeComposer: inputTypeComposer,\n    })\n    typeComposer.removeInputTypeComposer()\n  }\n\n  typeComposer.setExtension(`derivedTypes`, new Set())\n}\n\nexport const addDerivedType = ({\n  typeComposer,\n  derivedTypeName,\n}: {\n  typeComposer: AllTypeComposer\n  derivedTypeName: string\n}): void => {\n  const derivedTypes = getDerivedTypes({ typeComposer })\n  typeComposer.setExtension(`derivedTypes`, derivedTypes.add(derivedTypeName))\n}\n"],"mappings":";;;;;AA+BA;;AA/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmBA,MAAMA,eAAe,GAAG,CAAC;EACvBC;AADuB,CAAD,KAIL;EACjB,MAAMC,YAAY,GAAGD,YAAY,CAACE,YAAb,CAA2B,cAA3B,CAArB;;EACA,IAAID,YAAJ,EAAkB;IAChB,OAAOA,YAAP;EACD;;EAED,OAAO,IAAIE,GAAJ,EAAP;AACD,CAXD;;AAaO,MAAMC,0BAA0B,GAAG,CAAC;EAAEJ;AAAF,CAAD,KAA4B;EACpE,MAAMC,YAAY,GAAGF,eAAe,CAAC;IAAEC;EAAF,CAAD,CAApC;EAEAA,YAAY,CAACK,aAAb,GAA6BC,OAA7B,CAAqCC,SAAS,IAAI;IAChD,MAAMC,SAAS,GAAGR,YAAY,CAACS,QAAb,CAAsBF,SAAtB,EAAiCG,IAAnD;;IAEA,IAAIT,YAAY,CAACU,GAAb,CAAiBH,SAAS,CAACI,WAAV,EAAjB,CAAJ,EAA+C;MAC7CZ,YAAY,CAACa,WAAb,CAAyBN,SAAzB;IACD;EACF,CAND;AAOD,CAVM;;;;AAYP,MAAMO,4BAA4B,GAAG,CAAC;EACpCC,cADoC;EAEpCf;AAFoC,CAAD,KAGzB;EACVe,cAAc,CAACC,MAAf,CAAsBhB,YAAY,CAACY,WAAb,EAAtB;EACAG,cAAc,CAACC,MAAf,CAAuBhB,YAAD,CAAsBiB,OAA5C;EACAF,cAAc,CAACC,MAAf,CAAsBhB,YAAtB;AACD,CAPD;;AASO,MAAMkB,iBAAiB,GAAG,CAAC;EAChCH,cADgC;EAEhCf;AAFgC,CAAD,KAMrB;EACV,MAAMC,YAAY,GAAGF,eAAe,CAAC;IAAEC;EAAF,CAAD,CAApC;;EAEA,KAAK,MAAMmB,QAAX,IAAuBlB,YAAY,CAACmB,MAAb,EAAvB,EAA8C;IAC5C,MAAMC,mBAAmB,GAAGN,cAAc,CAACO,QAAf,CAAwBH,QAAxB,CAA5B;IACAD,iBAAiB,CAAC;MAAEH,cAAF;MAAkBf,YAAY,EAAEqB;IAAhC,CAAD,CAAjB;IACAP,4BAA4B,CAAC;MAC3BC,cAD2B;MAE3Bf,YAAY,EAAEqB;IAFa,CAAD,CAA5B;EAID;;EAED,IACErB,YAAY,YAAYuB,kCAAxB,IACAvB,YAAY,YAAYwB,qCAF1B,EAGE;IACA,MAAMC,iBAAiB,GAAGzB,YAAY,CAAC0B,oBAAb,EAA1B;IACAZ,4BAA4B,CAAC;MAC3BC,cAD2B;MAE3Bf,YAAY,EAAEyB;IAFa,CAAD,CAA5B;IAIAzB,YAAY,CAAC2B,uBAAb;EACD;;EAED3B,YAAY,CAAC4B,YAAb,CAA2B,cAA3B,EAA0C,IAAIzB,GAAJ,EAA1C;AACD,CA/BM;;;;AAiCA,MAAM0B,cAAc,GAAG,CAAC;EAC7B7B,YAD6B;EAE7B8B;AAF6B,CAAD,KAMlB;EACV,MAAM7B,YAAY,GAAGF,eAAe,CAAC;IAAEC;EAAF,CAAD,CAApC;EACAA,YAAY,CAAC4B,YAAb,CAA2B,cAA3B,EAA0C3B,YAAY,CAAC8B,GAAb,CAAiBD,eAAjB,CAA1C;AACD,CATM"}