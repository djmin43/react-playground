{"version":3,"file":"utils.js","names":["toNodeTypeNames","schema","gqlTypeName","gqlType","getType","isObjectType","isAbstractType","possibleTypes","getPossibleTypes","filter","type","getInterfaces","some","iface","name","map","isObjectOrInterfaceTypeComposer","ObjectTypeComposer","InterfaceTypeComposer","fieldNeedToResolve","typeComposer","schemaComposer","fieldName","nodeTypeNames","possibleTCs","getAnyTC","tc","getFieldExtension","fieldPathNeedToResolve","selector","schemaCustomization","composer","store","getState","Error","selectors","split","isInterfaceType","i","length","nextType","getNamedType","getFields","getResolvedFields","node","typeName","internal","resolvedNodes","resolvedNodesCache","get","id"],"sources":["../../src/schema/utils.ts"],"sourcesContent":["import {\n  isAbstractType,\n  getNamedType,\n  GraphQLSchema,\n  isObjectType,\n  isInterfaceType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n} from \"graphql\"\nimport {\n  InterfaceTypeComposer,\n  NamedTypeComposer,\n  ObjectTypeComposer,\n  SchemaComposer,\n} from \"graphql-compose\"\n\nimport type { IGatsbyNodePartial } from \"../datastore/in-memory/indexing\"\nimport { IGatsbyNode } from \"../internal\"\nimport { store } from \"../redux\"\n\nexport const toNodeTypeNames = (\n  schema: GraphQLSchema,\n  gqlTypeName:\n    | string\n    | GraphQLObjectType\n    | GraphQLInterfaceType\n    | GraphQLUnionType\n): Array<string> => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName\n\n  if (!gqlType || !(isObjectType(gqlType) || isAbstractType(gqlType))) {\n    return []\n  }\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType]\n\n  return possibleTypes\n    .filter(type => type.getInterfaces().some(iface => iface.name === `Node`))\n    .map(type => type.name)\n}\n\nexport function isObjectOrInterfaceTypeComposer(\n  type: NamedTypeComposer<any>\n): type is ObjectTypeComposer | InterfaceTypeComposer {\n  return (\n    type instanceof ObjectTypeComposer || type instanceof InterfaceTypeComposer\n  )\n}\n\nexport const fieldNeedToResolve = ({\n  schema,\n  gqlType,\n  typeComposer,\n  schemaComposer,\n  fieldName,\n}: {\n  schema: GraphQLSchema\n  gqlType: GraphQLObjectType | GraphQLInterfaceType\n  typeComposer: ObjectTypeComposer<any> | InterfaceTypeComposer<any>\n  schemaComposer: SchemaComposer<any>\n  fieldName: string\n}): boolean => {\n  const nodeTypeNames = toNodeTypeNames(schema, gqlType)\n\n  const possibleTCs: Array<ObjectTypeComposer | InterfaceTypeComposer> = [\n    typeComposer,\n    ...nodeTypeNames\n      .map(name => schemaComposer.getAnyTC(name))\n      .filter(isObjectOrInterfaceTypeComposer),\n  ]\n\n  for (const tc of possibleTCs) {\n    if (tc.getFieldExtension(fieldName, `needsResolve`) || false) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport const fieldPathNeedToResolve = ({\n  selector,\n  type,\n}: {\n  selector: string\n  type: string | GraphQLObjectType | GraphQLInterfaceType\n}): boolean => {\n  const {\n    schema,\n    schemaCustomization: { composer: schemaComposer },\n  } = store.getState()\n\n  if (!schemaComposer) {\n    throw new Error(`Schema composer isn't set yet`)\n  }\n\n  const selectors =\n    typeof selector === `string` ? selector.split(`.`) : selector\n\n  let gqlType = typeof type === `string` ? schema.getType(type) : type\n\n  if (!gqlType || !(isObjectType(gqlType) || isInterfaceType(gqlType))) {\n    return false\n  }\n\n  for (let i = 0; i < selectors.length; i++) {\n    const fieldName = selectors[i]\n    const typeComposer = schemaComposer.getAnyTC(gqlType.name)\n\n    if (!isObjectOrInterfaceTypeComposer(typeComposer)) {\n      return false\n    }\n\n    if (\n      fieldNeedToResolve({\n        schema,\n        gqlType,\n        typeComposer,\n        schemaComposer,\n        fieldName,\n      })\n    ) {\n      return true\n    }\n\n    const nextType = getNamedType(gqlType.getFields()[fieldName].type)\n    if (!nextType || !(isObjectType(nextType) || isInterfaceType(nextType))) {\n      return false\n    } else {\n      gqlType = nextType\n    }\n  }\n\n  return false\n}\n\nexport function getResolvedFields(\n  node: IGatsbyNode | IGatsbyNodePartial\n): undefined | Record<string, any> {\n  const typeName = node.internal.type\n  const resolvedNodes = store.getState().resolvedNodesCache.get(typeName)\n  return resolvedNodes?.get(node.id)\n}\n"],"mappings":"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"}