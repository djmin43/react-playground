{"version":3,"file":"find-page-by-path.js","names":["findBestMatchingPage","pages","path","pagesByMatchPath","page","values","matchPath","routes","Object","keys","map","picked","pick","route","findPageByPath","state","fallbackTo404","decodeURIComponent","get","hasLeadingSlash","startsWith","hasTrailingSlash","endsWith","bare","slice","length","some","potentialPath","matchingPage","undefined"],"sources":["../../src/utils/find-page-by-path.ts"],"sourcesContent":["import { IGatsbyPage, IGatsbyState } from \"../redux/types\"\nimport { pick } from \"@gatsbyjs/reach-router/lib/utils\"\n\n// Ranks and picks the best page to match. Each segment gets the highest\n// amount of points, then the type of segment gets an additional amount of\n// points where\n//\n//     static > dynamic > splat > root\n//\n// This way we don't have to worry about the order of our pages, let the\n// computers do it.\n//\n// In the future, we could move this pagesByMatchPath computation outside this\n// function and save some processing power\nconst findBestMatchingPage = (\n  pages: Map<string, IGatsbyPage>,\n  path: string\n): IGatsbyPage | null => {\n  // Pick only routes with matchPath for better performance.\n  // Exact match should have already been checked\n  const pagesByMatchPath: Record<string, IGatsbyPage> = {}\n  for (const page of pages.values()) {\n    const matchPath = page.matchPath\n    if (matchPath) {\n      pagesByMatchPath[matchPath] = page\n    }\n  }\n\n  const routes = Object.keys(pagesByMatchPath).map(path => {\n    return { path }\n  })\n\n  // picks best matching route with reach router's algorithm\n  const picked = pick(routes, path)\n\n  if (picked) {\n    return pagesByMatchPath[picked.route.path]\n  }\n\n  return null\n}\n\nexport function findPageByPath(\n  state: IGatsbyState,\n  path: string,\n  fallbackTo404: boolean = false\n): IGatsbyPage | undefined {\n  const { pages } = state\n\n  path = decodeURIComponent(path)\n\n  // first check by exact path\n  let page = pages.get(path)\n  if (page) {\n    return page\n  }\n\n  if (path === ``) {\n    // from my tests I never was able to make request with\n    // completely empty pathname, but just for the sake\n    // of completeness - try available alternative\n    page = pages.get(`/`)\n    if (page) {\n      return page\n    }\n  }\n  // Gatsby doesn't allow for page path to be empty string,\n  // so skipping trying to get page for \"\" path if we can't\n  // find page for `/`\n  else if (path !== `/`) {\n    // check various trailing/leading slashes combinations\n    const hasLeadingSlash = path.startsWith(`/`)\n    const hasTrailingSlash = path.endsWith(`/`)\n\n    const bare = path.slice(\n      hasLeadingSlash ? 1 : 0,\n      hasTrailingSlash ? -1 : path.length\n    )\n\n    ;[bare, `/` + bare, bare + `/`, `/` + bare + `/`].some(potentialPath => {\n      page = pages.get(potentialPath)\n      return !!page\n    })\n    if (page) {\n      return page\n    }\n  }\n\n  // we didn't find exact static page, time to check matchPaths\n  // TODO: consider using `match-paths.json` generated by `requires-writer`\n  // to avoid looping through all pages again. Ideally generate smaller `match-paths.json`\n  // variant that doesn't including overlapping static pages in `requires-writer` as well\n  // as this function already checked static paths at this point\n  const matchingPage = findBestMatchingPage(pages, path)\n\n  if (matchingPage) {\n    return matchingPage\n  }\n\n  if (fallbackTo404) {\n    return (\n      findPageByPath(state, `/dev-404-page/`, false) ??\n      findPageByPath(state, `/404.html`, false)\n    )\n  }\n  return undefined\n}\n"],"mappings":";;;;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,oBAAoB,GAAG,CAC3BC,KAD2B,EAE3BC,IAF2B,KAGJ;EACvB;EACA;EACA,MAAMC,gBAA6C,GAAG,EAAtD;;EACA,KAAK,MAAMC,IAAX,IAAmBH,KAAK,CAACI,MAAN,EAAnB,EAAmC;IACjC,MAAMC,SAAS,GAAGF,IAAI,CAACE,SAAvB;;IACA,IAAIA,SAAJ,EAAe;MACbH,gBAAgB,CAACG,SAAD,CAAhB,GAA8BF,IAA9B;IACD;EACF;;EAED,MAAMG,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYN,gBAAZ,EAA8BO,GAA9B,CAAkCR,IAAI,IAAI;IACvD,OAAO;MAAEA;IAAF,CAAP;EACD,CAFc,CAAf,CAXuB,CAevB;;EACA,MAAMS,MAAM,GAAG,IAAAC,WAAA,EAAKL,MAAL,EAAaL,IAAb,CAAf;;EAEA,IAAIS,MAAJ,EAAY;IACV,OAAOR,gBAAgB,CAACQ,MAAM,CAACE,KAAP,CAAaX,IAAd,CAAvB;EACD;;EAED,OAAO,IAAP;AACD,CA1BD;;AA4BO,SAASY,cAAT,CACLC,KADK,EAELb,IAFK,EAGLc,aAAsB,GAAG,KAHpB,EAIoB;EACzB,MAAM;IAAEf;EAAF,IAAYc,KAAlB;EAEAb,IAAI,GAAGe,kBAAkB,CAACf,IAAD,CAAzB,CAHyB,CAKzB;;EACA,IAAIE,IAAI,GAAGH,KAAK,CAACiB,GAAN,CAAUhB,IAAV,CAAX;;EACA,IAAIE,IAAJ,EAAU;IACR,OAAOA,IAAP;EACD;;EAED,IAAIF,IAAI,KAAM,EAAd,EAAiB;IACf;IACA;IACA;IACAE,IAAI,GAAGH,KAAK,CAACiB,GAAN,CAAW,GAAX,CAAP;;IACA,IAAId,IAAJ,EAAU;MACR,OAAOA,IAAP;IACD;EACF,CARD,CASA;EACA;EACA;EAXA,KAYK,IAAIF,IAAI,KAAM,GAAd,EAAkB;IACrB;IACA,MAAMiB,eAAe,GAAGjB,IAAI,CAACkB,UAAL,CAAiB,GAAjB,CAAxB;IACA,MAAMC,gBAAgB,GAAGnB,IAAI,CAACoB,QAAL,CAAe,GAAf,CAAzB;IAEA,MAAMC,IAAI,GAAGrB,IAAI,CAACsB,KAAL,CACXL,eAAe,GAAG,CAAH,GAAO,CADX,EAEXE,gBAAgB,GAAG,CAAC,CAAJ,GAAQnB,IAAI,CAACuB,MAFlB,CAAb;IAKC,CAACF,IAAD,EAAQ,GAAD,GAAMA,IAAb,EAAmBA,IAAI,GAAI,GAA3B,EAAgC,GAAD,GAAMA,IAAN,GAAc,GAA7C,EAAiDG,IAAjD,CAAsDC,aAAa,IAAI;MACtEvB,IAAI,GAAGH,KAAK,CAACiB,GAAN,CAAUS,aAAV,CAAP;MACA,OAAO,CAAC,CAACvB,IAAT;IACD,CAHA;;IAID,IAAIA,IAAJ,EAAU;MACR,OAAOA,IAAP;IACD;EACF,CAxCwB,CA0CzB;EACA;EACA;EACA;EACA;;;EACA,MAAMwB,YAAY,GAAG5B,oBAAoB,CAACC,KAAD,EAAQC,IAAR,CAAzC;;EAEA,IAAI0B,YAAJ,EAAkB;IAChB,OAAOA,YAAP;EACD;;EAED,IAAIZ,aAAJ,EAAmB;IAAA;;IACjB,0BACEF,cAAc,CAACC,KAAD,EAAS,gBAAT,EAA0B,KAA1B,CADhB,6DAEED,cAAc,CAACC,KAAD,EAAS,WAAT,EAAqB,KAArB,CAFhB;EAID;;EACD,OAAOc,SAAP;AACD"}