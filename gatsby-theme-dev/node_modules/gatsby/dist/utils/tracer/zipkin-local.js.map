{"version":3,"file":"zipkin-local.js","names":["logger","recorder","create","HttpLogger","endpoint","zipkin","BatchRecorder","timeout","tracer","ZipkinTracer","localServiceName","serviceName","sampler","CountingSampler","traceId128Bit","kind","_processQueue","queue","length","postBody","join","response","fetch","method","body","headers","status","err","errorListenerSet","emit","Error","console","error","stop","partialSpans","forEach","span","id","_timedOut","_writeSpan"],"sources":["../../../src/utils/tracer/zipkin-local.ts"],"sourcesContent":["import zipkin from \"zipkin\"\nimport { HttpLogger } from \"zipkin-transport-http\"\nimport ZipkinTracer from \"zipkin-javascript-opentracing\"\nimport fetch from \"node-fetch\"\nimport { ZipkinBatchRecorder, ZipkinHttpLogger } from \"./zipkin-types\"\n\nlet logger: ZipkinHttpLogger\nlet recorder: ZipkinBatchRecorder\n\n/**\n * Create and return an open-tracing compatible tracer. See\n * https://github.com/opentracing/opentracing-javascript/blob/master/src/tracer.ts\n */\nexport const create = (): ZipkinTracer => {\n  logger = new HttpLogger({\n    // endpoint of local docker zipkin instance\n    endpoint: `http://localhost:9411/api/v1/spans`,\n  }) as ZipkinHttpLogger\n\n  recorder = new zipkin.BatchRecorder({\n    logger,\n    // timeout = 60 hours, must be longer than site's build time\n    timeout: 60 * 60 * 60 * 1000000,\n  }) as ZipkinBatchRecorder\n\n  const tracer = new ZipkinTracer({\n    localServiceName: `gatsby`,\n    serviceName: `gatsby`,\n    // Sample 1 out of 1 spans (100%). When tracing production\n    // services, it is normal to sample 1 out of 10 requests so that\n    // tracing information doesn't impact site performance. But Gatsby\n    // is a build tool and only has \"1\" request (the\n    // build). Therefore, we must set this to 100% so that spans\n    // aren't missing\n    sampler: new zipkin.sampler.CountingSampler(1),\n    traceId128Bit: true,\n    recorder,\n    kind: `client`,\n  })\n\n  return tracer\n}\n\n// Workaround for issue in Zipkin HTTP Logger where Spans are not\n// cleared off their processing queue before the node.js process\n// exits. Code is mostly the same as the zipkin processQueue\n// implementation.\nconst _processQueue = async (): Promise<void> => {\n  if (logger.queue.length > 0) {\n    const postBody = `[${logger.queue.join(`,`)}]`\n    try {\n      const response = await fetch(logger.endpoint, {\n        method: `POST`,\n        body: postBody,\n        headers: logger.headers,\n        timeout: logger.timeout,\n      })\n\n      if (response.status !== 202) {\n        const err =\n          `Unexpected response while sending Zipkin data, status:` +\n          `${response.status}, body: ${postBody}`\n\n        if (logger.errorListenerSet) logger.emit(`error`, new Error(err))\n        else console.error(err)\n      }\n    } catch (error) {\n      const err = `Error sending Zipkin data ${error}`\n      if (logger.errorListenerSet) logger.emit(`error`, new Error(err))\n      else console.error(err)\n    }\n  }\n}\n\n/**\n * Run any tracer cleanup required before the node.js process\n * exits. For Zipkin HTTP, we must manually process any spans still on\n * the queue\n */\nexport const stop = async (): Promise<void> => {\n  // First, write all partial spans to the http logger\n  recorder.partialSpans.forEach((span, id) => {\n    if (recorder._timedOut(span)) {\n      recorder._writeSpan(id)\n    }\n  })\n\n  // Then tell http logger to process all spans in its queue\n  await _processQueue()\n}\n"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AAGA,IAAIA,MAAJ;AACA,IAAIC,QAAJ;AAEA;AACA;AACA;AACA;;AACO,MAAMC,MAAM,GAAG,MAAoB;EACxCF,MAAM,GAAG,IAAIG,+BAAJ,CAAe;IACtB;IACAC,QAAQ,EAAG;EAFW,CAAf,CAAT;EAKAH,QAAQ,GAAG,IAAII,eAAA,CAAOC,aAAX,CAAyB;IAClCN,MADkC;IAElC;IACAO,OAAO,EAAE,KAAK,EAAL,GAAU,EAAV,GAAe;EAHU,CAAzB,CAAX;EAMA,MAAMC,MAAM,GAAG,IAAIC,oCAAJ,CAAiB;IAC9BC,gBAAgB,EAAG,QADW;IAE9BC,WAAW,EAAG,QAFgB;IAG9B;IACA;IACA;IACA;IACA;IACA;IACAC,OAAO,EAAE,IAAIP,eAAA,CAAOO,OAAP,CAAeC,eAAnB,CAAmC,CAAnC,CATqB;IAU9BC,aAAa,EAAE,IAVe;IAW9Bb,QAX8B;IAY9Bc,IAAI,EAAG;EAZuB,CAAjB,CAAf;EAeA,OAAOP,MAAP;AACD,CA5BM,C,CA8BP;AACA;AACA;AACA;;;;;AACA,MAAMQ,aAAa,GAAG,YAA2B;EAC/C,IAAIhB,MAAM,CAACiB,KAAP,CAAaC,MAAb,GAAsB,CAA1B,EAA6B;IAC3B,MAAMC,QAAQ,GAAI,IAAGnB,MAAM,CAACiB,KAAP,CAAaG,IAAb,CAAmB,GAAnB,CAAuB,GAA5C;;IACA,IAAI;MACF,MAAMC,QAAQ,GAAG,MAAM,IAAAC,kBAAA,EAAMtB,MAAM,CAACI,QAAb,EAAuB;QAC5CmB,MAAM,EAAG,MADmC;QAE5CC,IAAI,EAAEL,QAFsC;QAG5CM,OAAO,EAAEzB,MAAM,CAACyB,OAH4B;QAI5ClB,OAAO,EAAEP,MAAM,CAACO;MAJ4B,CAAvB,CAAvB;;MAOA,IAAIc,QAAQ,CAACK,MAAT,KAAoB,GAAxB,EAA6B;QAC3B,MAAMC,GAAG,GACN,wDAAD,GACC,GAAEN,QAAQ,CAACK,MAAO,WAAUP,QAAS,EAFxC;QAIA,IAAInB,MAAM,CAAC4B,gBAAX,EAA6B5B,MAAM,CAAC6B,IAAP,CAAa,OAAb,EAAqB,IAAIC,KAAJ,CAAUH,GAAV,CAArB,EAA7B,KACKI,OAAO,CAACC,KAAR,CAAcL,GAAd;MACN;IACF,CAhBD,CAgBE,OAAOK,KAAP,EAAc;MACd,MAAML,GAAG,GAAI,6BAA4BK,KAAM,EAA/C;MACA,IAAIhC,MAAM,CAAC4B,gBAAX,EAA6B5B,MAAM,CAAC6B,IAAP,CAAa,OAAb,EAAqB,IAAIC,KAAJ,CAAUH,GAAV,CAArB,EAA7B,KACKI,OAAO,CAACC,KAAR,CAAcL,GAAd;IACN;EACF;AACF,CAzBD;AA2BA;AACA;AACA;AACA;AACA;;;AACO,MAAMM,IAAI,GAAG,YAA2B;EAC7C;EACAhC,QAAQ,CAACiC,YAAT,CAAsBC,OAAtB,CAA8B,CAACC,IAAD,EAAOC,EAAP,KAAc;IAC1C,IAAIpC,QAAQ,CAACqC,SAAT,CAAmBF,IAAnB,CAAJ,EAA8B;MAC5BnC,QAAQ,CAACsC,UAAT,CAAoBF,EAApB;IACD;EACF,CAJD,EAF6C,CAQ7C;;EACA,MAAMrB,aAAa,EAAnB;AACD,CAVM"}