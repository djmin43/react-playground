{"version":3,"file":"utils.js","names":["stabilizeSchema","schema","lexicographicSortSchema","sortDefinitions","a","b","name","localeCompare","guessIfUnnnamedQuery","isStaticQuery","filePath","queryType","generatedQueryName","slugify","replacement","lower","pattern","startsWith","guessIfThirdpartyDefinition","test","isFragmentDefinition","def","isFragment","isThirdpartyFragment","isTargetDefinition","filterTargetDefinitions","defMap","defs","push","Map"],"sources":["../../../src/utils/graphql-typegen/utils.ts"],"sourcesContent":["import slugify from \"slugify\"\nimport _ from \"lodash\"\nimport { lexicographicSortSchema } from \"graphql\"\nimport type { GraphQLSchema } from \"graphql\"\nimport { IDefinitionMeta } from \"../../redux/types\"\n\ntype DefinitionName = string\ntype DefinitionMap = Map<DefinitionName, IDefinitionMeta>\n\n/**\n * Makes the schema deterministic by sorting it (so on new saves the whole file doesn't change, only the change that was made). It can be used for e.g. tests when two schema diffs should be compared.\n */\nexport function stabilizeSchema(schema: GraphQLSchema): GraphQLSchema {\n  return lexicographicSortSchema(schema)\n}\n\nexport function sortDefinitions(\n  a: IDefinitionMeta,\n  b: IDefinitionMeta\n): number {\n  return a.name.localeCompare(b.name)\n}\n\n/**\n * Internally in Gatsby we use the function generateQueryName:\n * packages/gatsby/src/query/file-parser.js\n * This function re-implements this partially to guess if a query is unnamed\n */\nfunction guessIfUnnnamedQuery({\n  isStaticQuery,\n  name,\n  filePath,\n}: IDefinitionMeta): boolean {\n  const queryType = isStaticQuery ? `static` : `page`\n  const generatedQueryName = slugify(filePath, {\n    replacement: ` `,\n    lower: false,\n  })\n  const pattern = _.camelCase(`${queryType}-${generatedQueryName}`)\n  return name.startsWith(pattern)\n}\n\nfunction guessIfThirdpartyDefinition({ filePath }: IDefinitionMeta): boolean {\n  return /(node_modules|\\.yarn|\\.cache)/.test(filePath)\n}\n\nfunction isFragmentDefinition(def: IDefinitionMeta): boolean {\n  return def.isFragment\n}\n\nfunction isThirdpartyFragment(def: IDefinitionMeta): boolean {\n  return isFragmentDefinition(def) && guessIfThirdpartyDefinition(def)\n}\n\n/**\n * We don't want third-party definitions/queries unless it's a fragment.\n * We also don't want unnamed queries ending up in the TS types.\n */\nfunction isTargetDefinition(def: IDefinitionMeta): boolean {\n  if (isThirdpartyFragment(def)) {\n    return true\n  }\n  return !(guessIfThirdpartyDefinition(def) || guessIfUnnnamedQuery(def))\n}\n\nexport function filterTargetDefinitions(\n  defMap: DefinitionMap\n): Map<string, IDefinitionMeta> {\n  const defs: Array<[name: string, def: IDefinitionMeta]> = []\n  for (const [name, def] of defMap) {\n    if (isTargetDefinition(def)) {\n      defs.push([name, def])\n    }\n  }\n  return new Map(defs)\n}\n"],"mappings":";;;;;;;;;;;AAAA;;AAEA;;AAOA;AACA;AACA;AACO,SAASA,eAAT,CAAyBC,MAAzB,EAA+D;EACpE,OAAO,IAAAC,gCAAA,EAAwBD,MAAxB,CAAP;AACD;;AAEM,SAASE,eAAT,CACLC,CADK,EAELC,CAFK,EAGG;EACR,OAAOD,CAAC,CAACE,IAAF,CAAOC,aAAP,CAAqBF,CAAC,CAACC,IAAvB,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASE,oBAAT,CAA8B;EAC5BC,aAD4B;EAE5BH,IAF4B;EAG5BI;AAH4B,CAA9B,EAI6B;EAC3B,MAAMC,SAAS,GAAGF,aAAa,GAAI,QAAJ,GAAe,MAA9C;EACA,MAAMG,kBAAkB,GAAG,IAAAC,gBAAA,EAAQH,QAAR,EAAkB;IAC3CI,WAAW,EAAG,GAD6B;IAE3CC,KAAK,EAAE;EAFoC,CAAlB,CAA3B;EAIA,MAAMC,OAAO,GAAG,yBAAa,GAAEL,SAAU,IAAGC,kBAAmB,EAA/C,CAAhB;EACA,OAAON,IAAI,CAACW,UAAL,CAAgBD,OAAhB,CAAP;AACD;;AAED,SAASE,2BAAT,CAAqC;EAAER;AAAF,CAArC,EAA6E;EAC3E,OAAO,gCAAgCS,IAAhC,CAAqCT,QAArC,CAAP;AACD;;AAED,SAASU,oBAAT,CAA8BC,GAA9B,EAA6D;EAC3D,OAAOA,GAAG,CAACC,UAAX;AACD;;AAED,SAASC,oBAAT,CAA8BF,GAA9B,EAA6D;EAC3D,OAAOD,oBAAoB,CAACC,GAAD,CAApB,IAA6BH,2BAA2B,CAACG,GAAD,CAA/D;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASG,kBAAT,CAA4BH,GAA5B,EAA2D;EACzD,IAAIE,oBAAoB,CAACF,GAAD,CAAxB,EAA+B;IAC7B,OAAO,IAAP;EACD;;EACD,OAAO,EAAEH,2BAA2B,CAACG,GAAD,CAA3B,IAAoCb,oBAAoB,CAACa,GAAD,CAA1D,CAAP;AACD;;AAEM,SAASI,uBAAT,CACLC,MADK,EAEyB;EAC9B,MAAMC,IAAiD,GAAG,EAA1D;;EACA,KAAK,MAAM,CAACrB,IAAD,EAAOe,GAAP,CAAX,IAA0BK,MAA1B,EAAkC;IAChC,IAAIF,kBAAkB,CAACH,GAAD,CAAtB,EAA6B;MAC3BM,IAAI,CAACC,IAAL,CAAU,CAACtB,IAAD,EAAOe,GAAP,CAAV;IACD;EACF;;EACD,OAAO,IAAIQ,GAAJ,CAAQF,IAAR,CAAP;AACD"}