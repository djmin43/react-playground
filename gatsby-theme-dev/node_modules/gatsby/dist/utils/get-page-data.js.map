{"version":3,"file":"get-page-data.js","names":["DEFAULT_WAIT_TIMEOUT","RETRY_INTERVAL","getPageData","pagePath","waitForMS","doGetPageData","initialWaitForMs","queries","pendingPageDataWrites","pages","store","getState","has","Error","query","trackedQueries","get","running","waitNextPageData","dirty","emitter","emit","pagePaths","readPageData","remainingTime","Promise","resolve","on","listener","timeout","setTimeout","off","Math","max","min","data","payload","page","clearTimeout","process","nextTick","catch","toFixed","program","readPageDataUtil","path","join","directory","err"],"sources":["../../src/utils/get-page-data.ts"],"sourcesContent":["import * as path from \"path\"\nimport { store, emitter } from \"../redux\"\nimport { IClearPendingPageDataWriteAction } from \"../redux/types\"\nimport {\n  IPageDataWithQueryResult,\n  readPageData as readPageDataUtil,\n} from \"./page-data\"\n\nconst DEFAULT_WAIT_TIMEOUT = 15 * 1000\nexport const RETRY_INTERVAL = 5 * 1000\n\nexport async function getPageData(\n  pagePath: string,\n  waitForMS: number = DEFAULT_WAIT_TIMEOUT\n): Promise<IPageDataWithQueryResult> {\n  return doGetPageData(pagePath, waitForMS, waitForMS)\n}\n\nasync function doGetPageData(\n  pagePath: string,\n  waitForMS: number,\n  initialWaitForMs: number\n): Promise<IPageDataWithQueryResult> {\n  const { queries, pendingPageDataWrites, pages } = store.getState()\n\n  if (!pages.has(pagePath)) {\n    throw new Error(\n      `Page \"${pagePath}\" doesn't exist. It might have been deleted recently.`\n    )\n  }\n\n  const query = queries.trackedQueries.get(pagePath)\n\n  if (!query) {\n    throw new Error(`Could not find query ${pagePath}`)\n  }\n  if (query.running !== 0) {\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  if (query.dirty !== 0) {\n    emitter.emit(`QUERY_RUN_REQUESTED`, { pagePath })\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  if (pendingPageDataWrites.pagePaths.has(pagePath)) {\n    return waitNextPageData(pagePath, waitForMS, initialWaitForMs)\n  }\n  // Results are up-to-date\n  return readPageData(pagePath)\n}\n\nasync function waitNextPageData(\n  pagePath: string,\n  remainingTime: number,\n  initialWaitForMs: number\n): Promise<IPageDataWithQueryResult> {\n  if (remainingTime > 0) {\n    return new Promise(resolve => {\n      emitter.on(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n\n      const timeout = setTimeout((): void => {\n        emitter.off(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n        resolve(\n          doGetPageData(\n            pagePath,\n            Math.max(remainingTime - RETRY_INTERVAL, 0),\n            initialWaitForMs\n          )\n        )\n      }, Math.min(RETRY_INTERVAL, remainingTime))\n\n      function listener(data: IClearPendingPageDataWriteAction): void {\n        if (data.payload.page === pagePath) {\n          clearTimeout(timeout)\n          emitter.off(`CLEAR_PENDING_PAGE_DATA_WRITE`, listener)\n          // page-data was flushed, but we don't know if query wasn't marked as stale in meantime\n          // so we call `doGetPageData` again that will make checks and wait for fresh result\n          // or resolve immediately if it's not stale.\n          // Remaining time change is not actually \"correct\", but timeout overall is meant to ensure\n          // we do resolve (or reject) eventually, it doesn't have to be 100% correct - we do decrease\n          // it slightly to not end up in infinite loop situations.\n          // We also need to delay calling `doGetPageData` because it can cause adding another `CLEAR_PENDING_PAGE_DATA_WRITE`\n          // callback in same tick and `mett` will run this callback (because it will happen before current callback finishes\n          // and `mett` doesn't guarantee it will only run callbacks registered before message was emitted)\n          process.nextTick(() =>\n            resolve(\n              doGetPageData(\n                pagePath,\n                Math.max(remainingTime - RETRY_INTERVAL / 5, 0),\n                initialWaitForMs\n              )\n            )\n          )\n        }\n      }\n    })\n  } else {\n    // not ideal ... but try to push results we might have (stale)\n    // or fail/reject\n    return readPageData(pagePath).catch(() => {\n      throw new Error(\n        `Couldn't get query results for \"${pagePath}\" in ${(\n          initialWaitForMs / 1000\n        ).toFixed(3)}s.`\n      )\n    })\n  }\n}\n\nasync function readPageData(pagePath): Promise<IPageDataWithQueryResult> {\n  const { program } = store.getState()\n\n  try {\n    return await readPageDataUtil(\n      path.join(program.directory, `public`),\n      pagePath\n    )\n  } catch (err) {\n    throw new Error(\n      `Error loading a result for the page query in \"${pagePath}\". Query was not run and no cached result was found.`\n    )\n  }\n}\n"],"mappings":"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"}