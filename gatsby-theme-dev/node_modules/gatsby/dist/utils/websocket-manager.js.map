{"version":3,"file":"websocket-manager.js","names":["hashPaths","paths","map","path","createHash","update","digest","WebsocketManager","activePaths","Set","clients","errors","Map","pageResults","staticQueryResults","init","server","websocket","SocketIO","pingTimeout","cors","origin","cookie","updateServerActivePaths","serverActivePaths","client","activePath","add","on","socket","clientInfo","setActivePath","newActivePath","fallbackTo404","activePagePath","page","findPageByPath","store","getState","getPageMode","handshake","headers","referer","url","parse","forEach","message","errorID","send","type","payload","id","delete","_path","process","env","GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND","boundEmitStalePageDataPathsFromDirtyQueryTracking","emitStalePageDataPathsFromDirtyQueryTracking","bind","emitter","emitStalePageDataPathsFromStaticQueriesAssignment","getSocket","emitStaticQueryData","data","set","size","telemetry","trackCli","siteMeasurements","clientsCount","Array","from","debounce","emitPageData","emitError","dirtyQueries","queries","dirtyQueriesListToEmitViaWebsocket","emitStalePageDataPaths","dispatch","clearDirtyQueriesListToEmitViaWebsocket","pendingTemplateDataWrite","pages","stalePageDataPaths","length","emitStaleServerData","websocketManager"],"sources":["../../src/utils/websocket-manager.ts"],"sourcesContent":["/* eslint-disable no-invalid-this */\n\nimport { store, emitter } from \"../redux\"\nimport { IAddPendingTemplateDataWriteAction } from \"../redux/types\"\nimport { clearDirtyQueriesListToEmitViaWebsocket } from \"../redux/actions/internal\"\nimport { Server as HTTPSServer } from \"https\"\nimport { Server as HTTPServer } from \"http\"\nimport { IPageDataWithQueryResult } from \"../utils/page-data\"\nimport telemetry from \"gatsby-telemetry\"\nimport url from \"url\"\nimport { createHash } from \"crypto\"\nimport { findPageByPath } from \"./find-page-by-path\"\nimport { Server as SocketIO, Socket } from \"socket.io\"\nimport { getPageMode } from \"./page-mode\"\n\nexport interface IPageQueryResult {\n  id: string\n  result?: IPageDataWithQueryResult\n}\n\nexport interface IStaticQueryResult {\n  id: string\n  result: unknown // TODO: Improve this once we understand what the type is\n}\n\ntype PageResultsMap = Map<string, IPageQueryResult>\ntype QueryResultsMap = Map<string, IStaticQueryResult>\n\nfunction hashPaths(paths: Array<string>): Array<string> {\n  return paths.map(path => createHash(`sha256`).update(path).digest(`hex`))\n}\n\ninterface IClientInfo {\n  activePath: string | null\n  socket: Socket\n}\n\nexport class WebsocketManager {\n  activePaths: Set<string> = new Set()\n  clients: Set<IClientInfo> = new Set()\n  errors: Map<string, string> = new Map()\n  pageResults: PageResultsMap = new Map()\n  staticQueryResults: QueryResultsMap = new Map()\n  websocket: SocketIO | undefined\n\n  init = ({ server }: { server: HTTPSServer | HTTPServer }): SocketIO => {\n    // make typescript happy, else it complained about this.websocket being undefined\n    const websocket = new SocketIO(server, {\n      // we see ping-pong timeouts on gatsby-cloud when socket.io is running for a while\n      // increasing it should help\n      // @see https://github.com/socketio/socket.io/issues/3259#issuecomment-448058937\n      pingTimeout: 30000,\n      // whitelist all (https://github.com/expressjs/cors#configuration-options)\n      cors: {\n        origin: true,\n      },\n      cookie: true,\n    })\n    this.websocket = websocket\n\n    const updateServerActivePaths = (): void => {\n      const serverActivePaths = new Set<string>()\n      for (const client of this.clients) {\n        if (client.activePath) {\n          serverActivePaths.add(client.activePath)\n        }\n      }\n      this.activePaths = serverActivePaths\n    }\n\n    websocket.on(`connection`, socket => {\n      const clientInfo: IClientInfo = {\n        activePath: null,\n        socket,\n      }\n      this.clients.add(clientInfo)\n\n      const setActivePath = (\n        newActivePath: string | null,\n        fallbackTo404: boolean = false\n      ): void => {\n        let activePagePath: string | null = null\n        if (newActivePath) {\n          const page = findPageByPath(\n            store.getState(),\n            newActivePath,\n            fallbackTo404\n          )\n\n          if (page) {\n            // when it's SSR we don't want to return the page path but the actualy url used,\n            // this is necessary when matchPaths are used.\n            if (getPageMode(page) === `SSR`) {\n              activePagePath = newActivePath\n            } else {\n              activePagePath = page.path\n            }\n          }\n        }\n        clientInfo.activePath = activePagePath\n        updateServerActivePaths()\n      }\n\n      if (socket?.handshake?.headers?.referer) {\n        const path = url.parse(socket.handshake.headers.referer).path\n        setActivePath(path, true)\n      }\n\n      this.errors.forEach((message, errorID) => {\n        socket.send({\n          type: `overlayError`,\n          payload: {\n            id: errorID,\n            message,\n          },\n        })\n      })\n\n      socket.on(`registerPath`, (path: string): void => {\n        setActivePath(path, true)\n      })\n\n      socket.on(`disconnect`, (): void => {\n        setActivePath(null)\n        this.clients.delete(clientInfo)\n      })\n\n      socket.on(`unregisterPath`, (_path: string): void => {\n        setActivePath(null)\n      })\n    })\n\n    if (process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND) {\n      // page-data marked stale due to dirty query tracking\n      const boundEmitStalePageDataPathsFromDirtyQueryTracking =\n        this.emitStalePageDataPathsFromDirtyQueryTracking.bind(this)\n      emitter.on(\n        `CREATE_PAGE`,\n        boundEmitStalePageDataPathsFromDirtyQueryTracking\n      )\n      emitter.on(\n        `CREATE_NODE`,\n        boundEmitStalePageDataPathsFromDirtyQueryTracking\n      )\n      emitter.on(\n        `DELETE_NODE`,\n        boundEmitStalePageDataPathsFromDirtyQueryTracking\n      )\n      emitter.on(\n        `QUERY_EXTRACTED`,\n        boundEmitStalePageDataPathsFromDirtyQueryTracking\n      )\n    }\n\n    // page-data marked stale due to static query hashes change\n    emitter.on(\n      `ADD_PENDING_TEMPLATE_DATA_WRITE`,\n      this.emitStalePageDataPathsFromStaticQueriesAssignment.bind(this)\n    )\n\n    return websocket\n  }\n\n  getSocket = (): SocketIO | undefined => this.websocket\n\n  emitStaticQueryData = (data: IStaticQueryResult): void => {\n    this.staticQueryResults.set(data.id, data)\n\n    if (this.websocket) {\n      this.websocket.send({ type: `staticQueryResult`, payload: data })\n\n      if (this.clients.size > 0) {\n        telemetry.trackCli(\n          `WEBSOCKET_EMIT_STATIC_PAGE_DATA_UPDATE`,\n          {\n            siteMeasurements: {\n              clientsCount: this.clients.size,\n              paths: hashPaths(Array.from(this.activePaths)),\n            },\n          },\n          { debounce: true }\n        )\n      }\n    }\n  }\n\n  emitPageData = (data: IPageQueryResult): void => {\n    this.pageResults.set(data.id, data)\n\n    if (this.websocket) {\n      this.websocket.send({ type: `pageQueryResult`, payload: data })\n\n      if (this.clients.size > 0) {\n        telemetry.trackCli(\n          `WEBSOCKET_EMIT_PAGE_DATA_UPDATE`,\n          {\n            siteMeasurements: {\n              clientsCount: this.clients.size,\n              paths: hashPaths(Array.from(this.activePaths)),\n            },\n          },\n          { debounce: true }\n        )\n      }\n    }\n  }\n\n  emitError = (id: string, message?: string): void => {\n    if (message) {\n      this.errors.set(id, message)\n    } else {\n      this.errors.delete(id)\n    }\n\n    if (this.websocket) {\n      this.websocket.send({\n        type: `overlayError`,\n        payload: { id, message },\n      })\n    }\n  }\n\n  emitStalePageDataPathsFromDirtyQueryTracking(): void {\n    const dirtyQueries =\n      store.getState().queries.dirtyQueriesListToEmitViaWebsocket\n\n    if (this.emitStalePageDataPaths(dirtyQueries)) {\n      store.dispatch(clearDirtyQueriesListToEmitViaWebsocket())\n    }\n  }\n\n  emitStalePageDataPathsFromStaticQueriesAssignment(\n    pendingTemplateDataWrite: IAddPendingTemplateDataWriteAction\n  ): void {\n    this.emitStalePageDataPaths(\n      Array.from(pendingTemplateDataWrite.payload.pages)\n    )\n  }\n\n  emitStalePageDataPaths(stalePageDataPaths: Array<string>): boolean {\n    if (stalePageDataPaths.length > 0) {\n      if (this.websocket) {\n        this.websocket.send({\n          type: `stalePageData`,\n          payload: { stalePageDataPaths },\n        })\n\n        return true\n      }\n    }\n    return false\n  }\n\n  emitStaleServerData(): boolean {\n    if (this.websocket) {\n      this.websocket.send({ type: `staleServerData` })\n      return true\n    }\n    return false\n  }\n}\n\nexport const websocketManager: WebsocketManager = new WebsocketManager()\n"],"mappings":"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"}