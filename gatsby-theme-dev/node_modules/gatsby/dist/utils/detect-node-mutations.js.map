{"version":3,"file":"detect-node-mutations.js","names":["reported","Set","genericProxy","createProxyHandler","nodeInternalProxy","onGet","key","value","undefined","onSet","target","nodeProxy","memoizedProxy","referenceMap","WeakMap","handler","alreadyWrapped","get","wrapped","Proxy","set","result","error","Error","captureStackTrace","stack","has","add","codeFrame","getNonGatsbyCodeFrameFormatted","reporter","warn","replace","fieldDescriptor","Object","getOwnPropertyDescriptor","writable","shouldWrapNodesInProxies","process","env","GATSBY_DETECT_NODE_MUTATIONS","enableNodeMutationsDetection","wrapNode","node","wrapNodes","nodes","length","map"],"sources":["../../src/utils/detect-node-mutations.ts"],"sourcesContent":["import reporter from \"gatsby-cli/lib/reporter\"\nimport { getNonGatsbyCodeFrameFormatted } from \"./stack-trace-utils\"\nimport type { IGatsbyNode } from \"../redux/types\"\n\nconst reported = new Set<string>()\n\nconst genericProxy = createProxyHandler()\nconst nodeInternalProxy = createProxyHandler({\n  onGet(key, value) {\n    if (key === `fieldOwners` || key === `content`) {\n      // all allowed in here\n      return value\n    }\n    return undefined\n  },\n  onSet(target, key, value) {\n    if (key === `fieldOwners` || key === `content`) {\n      target[key] = value\n      return true\n    }\n    return undefined\n  },\n})\n\nconst nodeProxy = createProxyHandler({\n  onGet(key, value) {\n    if (key === `internal`) {\n      return memoizedProxy(value, nodeInternalProxy)\n    } else if (key === `fields` || key === `children`) {\n      // all allowed in here\n      return value\n    }\n    return undefined\n  },\n  onSet(target, key, value) {\n    if (key === `fields` || key === `children`) {\n      target[key] = value\n      return true\n    }\n    return undefined\n  },\n})\n\n/**\n * Every time we create proxy for object, we store it in WeakMap,\n * so that we reuse it for that object instead of creating new Proxy.\n * This also ensures reference equality: `memoizedProxy(obj) === memoizedProxy(obj)`.\n * If we didn't reuse already created proxy above comparison would return false.\n */\nconst referenceMap = new WeakMap<any, any>()\nfunction memoizedProxy<T>(target: T, handler: ProxyHandler<any>): T {\n  const alreadyWrapped = referenceMap.get(target)\n  if (alreadyWrapped) {\n    return alreadyWrapped\n  } else {\n    const wrapped = new Proxy(target, handler)\n    referenceMap.set(target, wrapped)\n    return wrapped\n  }\n}\n\nfunction createProxyHandler({\n  onGet,\n  onSet,\n}: {\n  onGet?: (key: string | symbol, value: any) => any\n  onSet?: (target: any, key: string | symbol, value: any) => boolean | undefined\n} = {}): ProxyHandler<any> {\n  function set(target, key, value): boolean {\n    if (onSet) {\n      const result = onSet(target, key, value)\n      if (result !== undefined) {\n        return result\n      }\n    }\n\n    const error = new Error(`Stack trace:`)\n    Error.captureStackTrace(error, set)\n\n    if (error.stack && !reported.has(error.stack)) {\n      reported.add(error.stack)\n      const codeFrame = getNonGatsbyCodeFrameFormatted({\n        stack: error.stack,\n      })\n      reporter.warn(\n        `Node mutation detected\\n\\n${\n          codeFrame ? `${codeFrame}\\n\\n` : ``\n        }${error.stack.replace(/^Error:?\\s*/, ``)}`\n      )\n    }\n    return true\n  }\n\n  function get(target, key): any {\n    const value = target[key]\n\n    if (onGet) {\n      const result = onGet(key, value)\n      if (result !== undefined) {\n        return result\n      }\n    }\n\n    const fieldDescriptor = Object.getOwnPropertyDescriptor(target, key)\n    if (fieldDescriptor && !fieldDescriptor.writable) {\n      // this is to prevent errors like:\n      // ```\n      // TypeError: 'get' on proxy: property 'constants' is a read - only and\n      // non - configurable data property on the proxy target but the proxy\n      // did not return its actual value\n      // (expected '[object Object]' but got '[object Object]')\n      // ```\n      return value\n    }\n\n    if (typeof value === `object` && value !== null) {\n      return memoizedProxy(value, genericProxy)\n    }\n\n    return value\n  }\n\n  return {\n    get,\n    set,\n  }\n}\n\nlet shouldWrapNodesInProxies = !!process.env.GATSBY_DETECT_NODE_MUTATIONS\nexport function enableNodeMutationsDetection(): void {\n  shouldWrapNodesInProxies = true\n\n  reporter.warn(\n    `Node mutation detection is enabled. Remember to disable it after you are finished with diagnostic as it will cause build performance degradation.`\n  )\n}\n\nexport function wrapNode<T extends IGatsbyNode | undefined>(node: T): T {\n  if (node && shouldWrapNodesInProxies) {\n    return memoizedProxy(node, nodeProxy)\n  } else {\n    return node\n  }\n}\n\nexport function wrapNodes<T extends Array<IGatsbyNode> | undefined>(\n  nodes: T\n): T {\n  if (nodes && shouldWrapNodesInProxies && nodes.length > 0) {\n    return nodes.map(node => memoizedProxy(node, nodeProxy)) as T\n  } else {\n    return nodes\n  }\n}\n"],"mappings":"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"}