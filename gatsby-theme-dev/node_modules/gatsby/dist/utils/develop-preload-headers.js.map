{"version":3,"file":"develop-preload-headers.js","names":["appendPreloadHeaders","requestPath","res","append","page","findPageByPath","store","getState","pagePathsToPreload","getPageMode","includes","path","unshift","staticQueriesToPreload","Set","pagePath","join","encodeURI","fixedPagePath","pageData","readPageData","program","directory","staticQueryHash","staticQueryHashes","add","e"],"sources":["../../src/utils/develop-preload-headers.ts"],"sourcesContent":["import { Response } from \"express\"\nimport * as path from \"path\"\nimport { fixedPagePath } from \"gatsby-core-utils\"\nimport { findPageByPath } from \"./find-page-by-path\"\nimport { readPageData } from \"./page-data\"\nimport { store } from \"../redux\"\nimport { getPageMode } from \"./page-mode\"\n\n/**\n * Add preload link headers to responses for .html files. This allows browser to schedule fetching critical resources\n * to render a page faster. Without them it would result in network waterfall (fetch js script -> parse and execute -> start downloading data)\n * With them we can start downloading data before JS executes.\n */\nexport async function appendPreloadHeaders(\n  requestPath: string,\n  res: Response\n): Promise<void> {\n  // add common.js and socket.io.js preload headers\n  // TODO: make socket.io part not blocking - we don't need it anymore to render the page\n  res.append(`Link`, `</commons.js>; rel=preload; as=script`)\n  res.append(`Link`, `</socket.io/socket.io.js>; rel=preload; as=script`)\n\n  const page = findPageByPath(store.getState(), requestPath, true)\n  // we fallback to 404 pages - so there should always be a page (at worst dev-404)\n  // this is just sanity check to not crash server in case it doesn't find anything\n  if (page) {\n    // add app-data.json preload\n    res.append(\n      `Link`,\n      `</page-data/app-data.json>; rel=preload; as=fetch ; crossorigin`\n    )\n\n    // add page-data.json preload\n    // our runtime also demands 404 and dev-404 page-data to be fetched to even render (see cache-dir/app.js)\n    const pagePathsToPreload = [`/404.html`, `/dev-404-page/`]\n    if (\n      getPageMode(page) !== `SSR` &&\n      !pagePathsToPreload.includes(page.path)\n    ) {\n      // let's make sure page path is first one (order shouldn't matter, just for reasonable order)\n      pagePathsToPreload.unshift(page.path)\n    }\n\n    const staticQueriesToPreload = new Set<string>()\n    for (const pagePath of pagePathsToPreload) {\n      res.append(\n        `Link`,\n        `</${path.join(\n          `page-data`,\n          encodeURI(fixedPagePath(pagePath)),\n          `page-data.json`\n        )}>; rel=preload; as=fetch ; crossorigin`\n      )\n\n      try {\n        const pageData = await readPageData(\n          path.join(store.getState().program.directory, `public`),\n          pagePath\n        )\n\n        // iterate over needed static queries and add them to Set of static queries to preload\n        // Set will guarantee uniqueness in case queries are shared by requested page and 404 page.\n        for (const staticQueryHash of pageData.staticQueryHashes) {\n          staticQueriesToPreload.add(staticQueryHash)\n        }\n      } catch (e) {\n        // there might be timing reasons why this fails - page-data file is not created yet\n        // as page was just recently added (so page exists already but page-data doesn't yet)\n        // in those cases we just do nothing\n      }\n    }\n\n    // append accumulated static queries from pages we load\n    for (const staticQueryHash of staticQueriesToPreload) {\n      res.append(\n        `Link`,\n        `</page-data/sq/d/${staticQueryHash}.json>; rel=preload; as=fetch ; crossorigin`\n      )\n    }\n  } else {\n    // should we track cases when there is actually nothing returned to find cases\n    // where we don't add preload headers if above assumption turns out to be wrong?\n  }\n}\n"],"mappings":";;;;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;AAEA;AACA;AACA;AACA;AACA;AACO,eAAeA,oBAAf,CACLC,WADK,EAELC,GAFK,EAGU;EACf;EACA;EACAA,GAAG,CAACC,MAAJ,CAAY,MAAZ,EAAoB,uCAApB;EACAD,GAAG,CAACC,MAAJ,CAAY,MAAZ,EAAoB,mDAApB;EAEA,MAAMC,IAAI,GAAG,IAAAC,8BAAA,EAAeC,YAAA,CAAMC,QAAN,EAAf,EAAiCN,WAAjC,EAA8C,IAA9C,CAAb,CANe,CAOf;EACA;;EACA,IAAIG,IAAJ,EAAU;IACR;IACAF,GAAG,CAACC,MAAJ,CACG,MADH,EAEG,iEAFH,EAFQ,CAOR;IACA;;IACA,MAAMK,kBAAkB,GAAG,CAAE,WAAF,EAAe,gBAAf,CAA3B;;IACA,IACE,IAAAC,qBAAA,EAAYL,IAAZ,MAAuB,KAAvB,IACA,CAACI,kBAAkB,CAACE,QAAnB,CAA4BN,IAAI,CAACO,IAAjC,CAFH,EAGE;MACA;MACAH,kBAAkB,CAACI,OAAnB,CAA2BR,IAAI,CAACO,IAAhC;IACD;;IAED,MAAME,sBAAsB,GAAG,IAAIC,GAAJ,EAA/B;;IACA,KAAK,MAAMC,QAAX,IAAuBP,kBAAvB,EAA2C;MACzCN,GAAG,CAACC,MAAJ,CACG,MADH,EAEG,KAAIQ,IAAI,CAACK,IAAL,CACF,WADE,EAEHC,SAAS,CAAC,IAAAC,8BAAA,EAAcH,QAAd,CAAD,CAFN,EAGF,gBAHE,CAIH,wCANJ;;MASA,IAAI;QACF,MAAMI,QAAQ,GAAG,MAAM,IAAAC,sBAAA,EACrBT,IAAI,CAACK,IAAL,CAAUV,YAAA,CAAMC,QAAN,GAAiBc,OAAjB,CAAyBC,SAAnC,EAA+C,QAA/C,CADqB,EAErBP,QAFqB,CAAvB,CADE,CAMF;QACA;;QACA,KAAK,MAAMQ,eAAX,IAA8BJ,QAAQ,CAACK,iBAAvC,EAA0D;UACxDX,sBAAsB,CAACY,GAAvB,CAA2BF,eAA3B;QACD;MACF,CAXD,CAWE,OAAOG,CAAP,EAAU,CACV;QACA;QACA;MACD;IACF,CA7CO,CA+CR;;;IACA,KAAK,MAAMH,eAAX,IAA8BV,sBAA9B,EAAsD;MACpDX,GAAG,CAACC,MAAJ,CACG,MADH,EAEG,oBAAmBoB,eAAgB,6CAFtC;IAID;EACF,CAtDD,MAsDO,CACL;IACA;EACD;AACF"}