{"version":3,"file":"js-chunk-names.js","names":["kebabCase","memoize","pathRelative","path","relative","replaceUnifiedRoutesKeys","kebabedName","filePath","newString","split","sep","forEach","part","match","exec","replace","chunkNameCache","Map","generateComponentChunkName","componentPath","has","get","program","store","getState","directory","name","chunkName","set"],"sources":["../../src/utils/js-chunk-names.ts"],"sourcesContent":["import memoize from \"memoizee\"\nimport { kebabCase as _kebabCase } from \"lodash\"\nimport path from \"path\"\nimport { store } from \"../redux\"\n\nconst kebabCase = memoize(_kebabCase)\nconst pathRelative = memoize(path.relative)\n\n// unified routes adds support for files with [] and {},\n// the problem with our generateComponentChunkName is that when you\n// call kebabCase, is strips off characters like that. This means\n// that when you have a app with this sort of setup, the resolutions fail\n//\n// src/pages/products/{id}.js (collection route)\n// src/pages/products/[...id].js (should render when a non-matched id is passed in)\n//\n// without this function, what happens is that all visits to /products/__ resolve to only one\n// of these because the componentChunkName ends up being duplicate. This function ensures that\n// the {} and [] are kept in the componentChunkName. Also there are tests for this.\nfunction replaceUnifiedRoutesKeys(\n  kebabedName: string,\n  filePath: string\n): string {\n  let newString = kebabedName\n\n  filePath.split(path.sep).forEach(part => {\n    if (part[0] === `[` || part[0] === `{`) {\n      const match = /(\\[(.*)\\]|\\{(.*)\\})/.exec(part)\n      newString = newString.replace(\n        `-${match![2] || match![3]}-`,\n        `-${match![0]}-`\n      )\n    }\n  })\n\n  return newString\n}\n\nconst chunkNameCache = new Map()\nexport function generateComponentChunkName(componentPath: string): string {\n  if (chunkNameCache.has(componentPath)) {\n    return chunkNameCache.get(componentPath)\n  } else {\n    const { program } = store.getState()\n    const directory = program?.directory || `/`\n    const name = pathRelative(directory, componentPath)\n\n    const chunkName = `component---${replaceUnifiedRoutesKeys(\n      kebabCase(name),\n      name\n    )}`\n\n    chunkNameCache.set(componentPath, chunkName)\n\n    return chunkName\n  }\n}\n"],"mappings":";;;;;;;;;AAAA;;AAEA;;AACA;;AAEA,MAAMA,SAAS,GAAG,IAAAC,iBAAA,sBAAlB;AACA,MAAMC,YAAY,GAAG,IAAAD,iBAAA,EAAQE,aAAA,CAAKC,QAAb,CAArB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,wBAAT,CACEC,WADF,EAEEC,QAFF,EAGU;EACR,IAAIC,SAAS,GAAGF,WAAhB;EAEAC,QAAQ,CAACE,KAAT,CAAeN,aAAA,CAAKO,GAApB,EAAyBC,OAAzB,CAAiCC,IAAI,IAAI;IACvC,IAAIA,IAAI,CAAC,CAAD,CAAJ,KAAa,GAAb,IAAmBA,IAAI,CAAC,CAAD,CAAJ,KAAa,GAApC,EAAwC;MACtC,MAAMC,KAAK,GAAG,sBAAsBC,IAAtB,CAA2BF,IAA3B,CAAd;MACAJ,SAAS,GAAGA,SAAS,CAACO,OAAV,CACT,IAAGF,KAAK,CAAE,CAAF,CAAL,IAAaA,KAAK,CAAE,CAAF,CAAK,GADjB,EAET,IAAGA,KAAK,CAAE,CAAF,CAAK,GAFJ,CAAZ;IAID;EACF,CARD;EAUA,OAAOL,SAAP;AACD;;AAED,MAAMQ,cAAc,GAAG,IAAIC,GAAJ,EAAvB;;AACO,SAASC,0BAAT,CAAoCC,aAApC,EAAmE;EACxE,IAAIH,cAAc,CAACI,GAAf,CAAmBD,aAAnB,CAAJ,EAAuC;IACrC,OAAOH,cAAc,CAACK,GAAf,CAAmBF,aAAnB,CAAP;EACD,CAFD,MAEO;IACL,MAAM;MAAEG;IAAF,IAAcC,YAAA,CAAMC,QAAN,EAApB;;IACA,MAAMC,SAAS,GAAG,CAAAH,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEG,SAAT,KAAuB,GAAzC;IACA,MAAMC,IAAI,GAAGxB,YAAY,CAACuB,SAAD,EAAYN,aAAZ,CAAzB;IAEA,MAAMQ,SAAS,GAAI,eAActB,wBAAwB,CACvDL,SAAS,CAAC0B,IAAD,CAD8C,EAEvDA,IAFuD,CAGvD,EAHF;IAKAV,cAAc,CAACY,GAAf,CAAmBT,aAAnB,EAAkCQ,SAAlC;IAEA,OAAOA,SAAP;EACD;AACF"}