{"version":3,"file":"index.js","names":["NODE_MUTATION_BATCH_SIZE","NODE_MUTATION_BATCH_TIMEOUT","FILE_CHANGE_AGGREGATION_TIMEOUT","waitingStates","id","initial","context","nodeMutationBatch","runningBatch","states","idle","always","cond","ctx","length","target","sourceFilesDirty","Boolean","on","ADD_NODE_MUTATION","actions","SOURCE_FILE_CHANGED","aggregatingFileChanges","after","undefined","internal","batchingNodeMutations","committingBatch","entry","assign","invoke","src","onDone","rebuild","type","data","waitingMachine","createMachine","waitingActions","services","waitingServices"],"sources":["../../../src/state-machines/waiting/index.ts"],"sourcesContent":["import { MachineConfig, assign, createMachine } from \"xstate\"\nimport { IWaitingContext } from \"./types\"\nimport { waitingActions } from \"./actions\"\nimport { waitingServices } from \"./services\"\n\nconst NODE_MUTATION_BATCH_SIZE = 100\nconst NODE_MUTATION_BATCH_TIMEOUT = 500\nconst FILE_CHANGE_AGGREGATION_TIMEOUT = 200\n\nexport type WaitingResult = Pick<IWaitingContext, \"nodeMutationBatch\">\n\n/**\n * This idle state also handles batching of node mutations and running of\n * mutations when we first start it\n */\nexport const waitingStates: MachineConfig<IWaitingContext, any, any> = {\n  id: `waitingMachine`,\n  initial: `idle`,\n  context: {\n    nodeMutationBatch: [],\n    runningBatch: [],\n  },\n  states: {\n    idle: {\n      always: [\n        {\n          // If we already have queued node mutations, move\n          // immediately to batching\n          cond: (ctx): boolean => !!ctx.nodeMutationBatch.length,\n          target: `batchingNodeMutations`,\n        },\n        {\n          // If source files are dirty upon entering this state,\n          // move immediately to aggregatingFileChanges to force re-compilation\n          // See https://github.com/gatsbyjs/gatsby/issues/27609\n          target: `aggregatingFileChanges`,\n          cond: ({ sourceFilesDirty }): boolean => Boolean(sourceFilesDirty),\n        },\n      ],\n      on: {\n        ADD_NODE_MUTATION: {\n          actions: `addNodeMutation`,\n          target: `batchingNodeMutations`,\n        },\n        // We only listen for this when idling because if we receive it at any\n        // other point we're already going to create pages etc\n        SOURCE_FILE_CHANGED: {\n          target: `aggregatingFileChanges`,\n        },\n      },\n    },\n    aggregatingFileChanges: {\n      // Sigh. This is because webpack doesn't expose the Watchpack\n      // aggregated file invalidation events. If we compile immediately,\n      // we won't pick up the changed files\n      after: {\n        // The aggregation timeout\n        [FILE_CHANGE_AGGREGATION_TIMEOUT]: {\n          actions: `extractQueries`,\n          target: `idle`,\n        },\n      },\n      on: {\n        ADD_NODE_MUTATION: {\n          actions: `addNodeMutation`,\n          target: `batchingNodeMutations`,\n        },\n        SOURCE_FILE_CHANGED: {\n          target: undefined,\n          // External self-transition reset the timer\n          internal: false,\n        },\n      },\n    },\n    batchingNodeMutations: {\n      // Check if the batch is already full on entry\n      always: {\n        cond: (ctx): boolean =>\n          ctx.nodeMutationBatch.length >= NODE_MUTATION_BATCH_SIZE,\n        target: `committingBatch`,\n      },\n      on: {\n        // More mutations added to batch\n        ADD_NODE_MUTATION: [\n          // You know the score: only run the first matching transition\n          {\n            // If this fills the batch then commit it\n            actions: `addNodeMutation`,\n            cond: (ctx): boolean =>\n              ctx.nodeMutationBatch.length >= NODE_MUTATION_BATCH_SIZE,\n            target: `committingBatch`,\n          },\n          {\n            // ...otherwise just add it to the batch\n            actions: `addNodeMutation`,\n          },\n        ],\n      },\n      after: {\n        // Time's up\n        [NODE_MUTATION_BATCH_TIMEOUT]: `committingBatch`,\n      },\n    },\n    committingBatch: {\n      entry: assign<IWaitingContext>(({ nodeMutationBatch }) => {\n        return {\n          nodeMutationBatch: [],\n          runningBatch: nodeMutationBatch,\n        }\n      }),\n      on: {\n        // While we're running the batch we will also run new actions, as these may be cascades\n        ADD_NODE_MUTATION: {\n          actions: `callApi`,\n        },\n      },\n      invoke: {\n        src: `runMutationBatch`,\n        // When we're done, clear the running batch ready for next time\n        onDone: {\n          actions: assign<IWaitingContext, any>({\n            runningBatch: [],\n          }),\n          target: `rebuild`,\n        },\n      },\n    },\n    rebuild: {\n      type: `final`,\n      // This is returned to the parent. The batch includes\n      // any mutations that arrived while we were running the other batch\n      data: ({ nodeMutationBatch }): WaitingResult => {\n        return { nodeMutationBatch }\n      },\n    },\n  },\n}\n\nexport const waitingMachine = createMachine(waitingStates, {\n  actions: waitingActions,\n  services: waitingServices,\n})\n"],"mappings":"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"}