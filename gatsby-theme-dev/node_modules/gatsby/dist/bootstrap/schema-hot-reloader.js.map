{"version":3,"file":"schema-hot-reloader.js","names":["inferredTypesChanged","typeMap","prevTypeMap","Object","keys","some","type","dirty","haveEqualFields","lastMetadata","maybeRebuildSchema","inferenceMetadata","store","getState","activity","report","activityTimer","start","rebuild","parentSpan","updateStateAndRunQueries","span","end","snapshotInferenceMetadata","bootstrapSchemaHotReloader","emitter","on","startSchemaHotReloader","stopSchemaHotReloader","off","cancel"],"sources":["../../src/bootstrap/schema-hot-reloader.ts"],"sourcesContent":["import { debounce, cloneDeep } from \"lodash\"\nimport { emitter, store } from \"../redux\"\nimport { rebuild } from \"../schema\"\nimport { haveEqualFields } from \"../schema/infer/inference-metadata\"\nimport { updateStateAndRunQueries } from \"../query/query-watcher\"\nimport report from \"gatsby-cli/lib/reporter\"\nimport { IGatsbyState } from \"../redux/types\"\n\ntype TypeMap = IGatsbyState[\"inferenceMetadata\"][\"typeMap\"]\ntype InferenceMetadata = IGatsbyState[\"inferenceMetadata\"]\n\nconst inferredTypesChanged = (\n  typeMap: TypeMap,\n  prevTypeMap: TypeMap\n): boolean =>\n  Object.keys(typeMap).some(\n    type =>\n      typeMap[type].dirty && !haveEqualFields(typeMap[type], prevTypeMap[type])\n  )\n\nlet lastMetadata: InferenceMetadata\n\n// API_RUNNING_QUEUE_EMPTY could be emitted multiple types\n// in a short period of time, so debounce seems reasonable\nconst maybeRebuildSchema = debounce(async (): Promise<void> => {\n  const { inferenceMetadata } = store.getState()\n\n  if (!inferredTypesChanged(inferenceMetadata.typeMap, lastMetadata.typeMap)) {\n    return\n  }\n\n  const activity = report.activityTimer(`rebuild schema`)\n  activity.start()\n  await rebuild({ parentSpan: activity })\n  await updateStateAndRunQueries(false, { parentSpan: activity.span })\n  activity.end()\n}, 1000)\n\nfunction snapshotInferenceMetadata(): void {\n  const { inferenceMetadata } = store.getState()\n  lastMetadata = cloneDeep(inferenceMetadata)\n}\n\nexport function bootstrapSchemaHotReloader(): void {\n  // Snapshot inference metadata at the time of the last schema rebuild\n  // (even if schema was rebuilt elsewhere)\n  // Using the snapshot later to check if inferred types actually changed since the last rebuild\n  snapshotInferenceMetadata()\n  emitter.on(`SET_SCHEMA`, snapshotInferenceMetadata)\n\n  startSchemaHotReloader()\n}\n\nexport function startSchemaHotReloader(): void {\n  // Listen for node changes outside of a regular sourceNodes API call,\n  // e.g. markdown file update via watcher\n  emitter.on(`API_RUNNING_QUEUE_EMPTY`, maybeRebuildSchema)\n}\n\nexport function stopSchemaHotReloader(): void {\n  emitter.off(`API_RUNNING_QUEUE_EMPTY`, maybeRebuildSchema)\n  maybeRebuildSchema.cancel()\n}\n"],"mappings":";;;;;;;;;;;;;AACA;;AACA;;AACA;;AACA;;AACA;;AAMA,MAAMA,oBAAoB,GAAG,CAC3BC,OAD2B,EAE3BC,WAF2B,KAI3BC,MAAM,CAACC,IAAP,CAAYH,OAAZ,EAAqBI,IAArB,CACEC,IAAI,IACFL,OAAO,CAACK,IAAD,CAAP,CAAcC,KAAd,IAAuB,CAAC,IAAAC,kCAAA,EAAgBP,OAAO,CAACK,IAAD,CAAvB,EAA+BJ,WAAW,CAACI,IAAD,CAA1C,CAF5B,CAJF;;AASA,IAAIG,YAAJ,C,CAEA;AACA;;AACA,MAAMC,kBAAkB,GAAG,wBAAS,YAA2B;EAC7D,MAAM;IAAEC;EAAF,IAAwBC,YAAA,CAAMC,QAAN,EAA9B;;EAEA,IAAI,CAACb,oBAAoB,CAACW,iBAAiB,CAACV,OAAnB,EAA4BQ,YAAY,CAACR,OAAzC,CAAzB,EAA4E;IAC1E;EACD;;EAED,MAAMa,QAAQ,GAAGC,iBAAA,CAAOC,aAAP,CAAsB,gBAAtB,CAAjB;;EACAF,QAAQ,CAACG,KAAT;EACA,MAAM,IAAAC,eAAA,EAAQ;IAAEC,UAAU,EAAEL;EAAd,CAAR,CAAN;EACA,MAAM,IAAAM,sCAAA,EAAyB,KAAzB,EAAgC;IAAED,UAAU,EAAEL,QAAQ,CAACO;EAAvB,CAAhC,CAAN;EACAP,QAAQ,CAACQ,GAAT;AACD,CAZ0B,EAYxB,IAZwB,CAA3B;;AAcA,SAASC,yBAAT,GAA2C;EACzC,MAAM;IAAEZ;EAAF,IAAwBC,YAAA,CAAMC,QAAN,EAA9B;;EACAJ,YAAY,GAAG,yBAAUE,iBAAV,CAAf;AACD;;AAEM,SAASa,0BAAT,GAA4C;EACjD;EACA;EACA;EACAD,yBAAyB;;EACzBE,cAAA,CAAQC,EAAR,CAAY,YAAZ,EAAyBH,yBAAzB;;EAEAI,sBAAsB;AACvB;;AAEM,SAASA,sBAAT,GAAwC;EAC7C;EACA;EACAF,cAAA,CAAQC,EAAR,CAAY,yBAAZ,EAAsChB,kBAAtC;AACD;;AAEM,SAASkB,qBAAT,GAAuC;EAC5CH,cAAA,CAAQI,GAAR,CAAa,yBAAb,EAAuCnB,kBAAvC;;EACAA,kBAAkB,CAACoB,MAAnB;AACD"}