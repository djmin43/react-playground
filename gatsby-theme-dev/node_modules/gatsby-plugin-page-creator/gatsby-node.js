"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.createPagesStatefully = createPagesStatefully;
exports.setFieldsOnGraphQLNodeType = setFieldsOnGraphQLNodeType;

var _camelCase2 = _interopRequireDefault(require("lodash/camelCase"));

var _globby = _interopRequireDefault(require("globby"));

var _path = _interopRequireDefault(require("path"));

var _fsExistsCached = require("fs-exists-cached");

var _gatsbyTelemetry = require("gatsby-telemetry");

var _graphql = require("gatsby/graphql");

var _gatsbyPageUtils = require("gatsby-page-utils");

var _createPageWrapper = require("./create-page-wrapper");

var _collectionExtractQueryString = require("./collection-extract-query-string");

var _derivePath = require("./derive-path");

var _validatePathQuery = require("./validate-path-query");

var _errorUtils = require("./error-utils");

let coreSupportsOnPluginInit;

try {
  const {
    isGatsbyNodeLifecycleSupported
  } = require(`gatsby-plugin-utils`);

  if (isGatsbyNodeLifecycleSupported(`onPluginInit`)) {
    coreSupportsOnPluginInit = `stable`;
  } else if (isGatsbyNodeLifecycleSupported(`unstable_onPluginInit`)) {
    coreSupportsOnPluginInit = `unstable`;
  }
} catch (e) {
  console.error(`Could not check if Gatsby supports onPluginInit lifecycle`);
}

const knownCollections = new Map(); // Path creator.
// Auto-create pages.
// algorithm is glob /pages directory for js/jsx/cjsx files *not*
// underscored. Then create url w/ our path algorithm *unless* user
// takes control of that page component in gatsby-node.

async function createPagesStatefully({
  store,
  actions,
  reporter,
  graphql
}, {
  path: pagesPath,
  pathCheck = true,
  ignore,
  slugify: slugifyOptions
}, doneCb) {
  try {
    const {
      deletePage
    } = actions;
    const {
      program,
      config
    } = store.getState();
    const {
      trailingSlash = `legacy`
    } = config;
    const exts = program.extensions.map(e => `${e.slice(1)}`).join(`,`);

    if (!pagesPath) {
      reporter.panic({
        id: (0, _errorUtils.prefixId)(_errorUtils.CODES.RequiredPath),
        context: {
          sourceMessage: `"path" is a required option for gatsby-plugin-page-creator

See docs here - https://www.gatsbyjs.com/plugins/gatsby-plugin-page-creator/`
        }
      });
    } // Validate that the path exists.


    if (pathCheck && !(0, _fsExistsCached.sync)(pagesPath)) {
      reporter.panic({
        id: (0, _errorUtils.prefixId)(_errorUtils.CODES.NonExistingPath),
        context: {
          sourceMessage: `The path passed to gatsby-plugin-page-creator does not exist on your file system:

${pagesPath}

Please pick a path to an existing directory.`
        }
      });
    }

    const pagesDirectory = _path.default.resolve(process.cwd(), pagesPath);

    const pagesGlob = `**/*.{${exts}}`; // Get initial list of files.

    const files = await (0, _globby.default)(pagesGlob, {
      cwd: pagesPath
    });
    files.forEach(file => {
      (0, _createPageWrapper.createPage)(file, pagesDirectory, actions, graphql, reporter, trailingSlash, ignore, slugifyOptions);
    });
    const knownFiles = new Set(files);
    (0, _gatsbyPageUtils.watchDirectory)(pagesPath, pagesGlob, addedPath => {
      try {
        if (!knownFiles.has(addedPath)) {
          (0, _createPageWrapper.createPage)(addedPath, pagesDirectory, actions, graphql, reporter, trailingSlash, ignore, slugifyOptions);
          knownFiles.add(addedPath);
        }
      } catch (e) {
        reporter.panic({
          id: (0, _errorUtils.prefixId)(_errorUtils.CODES.FileSystemAdd),
          context: {
            sourceMessage: e.message
          }
        });
      }
    }, removedPath => {
      // Delete the page for the now deleted component.
      try {
        const componentPath = _path.default.join(pagesDirectory, removedPath);

        store.getState().pages.forEach(page => {
          if (page.component === componentPath) {
            deletePage({
              path: page.path,
              component: componentPath
            });
          }
        });
        knownFiles.delete(removedPath);
      } catch (e) {
        reporter.panic({
          id: (0, _errorUtils.prefixId)(_errorUtils.CODES.FileSystemRemove),
          context: {
            sourceMessage: e.message
          }
        });
      }
    }).then(() => doneCb(null, null));
  } catch (e) {
    reporter.panicOnBuild({
      id: (0, _errorUtils.prefixId)(_errorUtils.CODES.Generic),
      context: {
        sourceMessage: e.message
      }
    });
  }
}

function setFieldsOnGraphQLNodeType({
  getNode,
  type,
  store,
  reporter
}, {
  slugify: slugifyOptions
}) {
  try {
    const extensions = store.getState().program.extensions;
    const {
      trailingSlash = `legacy`
    } = store.getState().config;
    const collectionQuery = (0, _camelCase2.default)(`all ${type.name}`);

    if (knownCollections.has(collectionQuery)) {
      return {
        gatsbyPath: {
          type: _graphql.GraphQLString,
          args: {
            filePath: {
              type: _graphql.GraphQLString
            }
          },
          resolve: (source, {
            filePath
          }) => {
            // This is a quick hack for attaching parents to the node.
            // This may be an incomprehensive fixed for the general use case
            // of connecting nodes together. However, I don't quite know how to
            // fully understand the use-cases. So this is a simple fix for this
            // one common-use, and we'll iterate as we understand.
            const sourceCopy = { ...source
            }; // @ts-ignore

            if (typeof source.parent === `string`) {
              // @ts-ignore
              sourceCopy.parent = getNode(source.parent);
            }

            (0, _validatePathQuery.validatePathQuery)(filePath, extensions);
            const {
              derivedPath
            } = (0, _derivePath.derivePath)(filePath, sourceCopy, reporter, slugifyOptions); // TODO(v5): Remove legacy handling

            const isLegacy = trailingSlash === `legacy`;
            const hasTrailingSlash = derivedPath.endsWith(`/`);
            const path = (0, _gatsbyPageUtils.createPath)(derivedPath, isLegacy || hasTrailingSlash, true);
            const modifiedPath = (0, _gatsbyPageUtils.applyTrailingSlashOption)(path, trailingSlash);
            return modifiedPath;
          }
        }
      };
    }

    return {};
  } catch (e) {
    reporter.panicOnBuild({
      id: (0, _errorUtils.prefixId)(_errorUtils.CODES.GraphQLResolver),
      context: {
        sourceMessage: e.message
      }
    });
    return {};
  }
}

async function initializePlugin({
  reporter
}, {
  path: pagesPath
}) {
  if (reporter.setErrorMap) {
    reporter.setErrorMap(_errorUtils.ERROR_MAP);
  }

  try {
    const pagesGlob = `**/**\\{*\\}**`;
    const files = await (0, _globby.default)(pagesGlob, {
      cwd: pagesPath
    });

    if (files.length > 0) {
      (0, _gatsbyTelemetry.trackFeatureIsUsed)(`UnifiedRoutes:collection-page-builder`);
    }

    await Promise.all(files.map(async relativePath => {
      const absolutePath = require.resolve(_path.default.join(pagesPath, relativePath));

      const queryString = await (0, _collectionExtractQueryString.collectionExtractQueryString)(absolutePath, reporter);
      if (!queryString) return;
      const ast = (0, _graphql.parse)(queryString);
      knownCollections.set( // @ts-ignore
      ast.definitions[0].selectionSet.selections[0].name.value, relativePath);
    }));
  } catch (e) {
    reporter.panicOnBuild({
      id: (0, _errorUtils.prefixId)(_errorUtils.CODES.Generic),
      context: {
        sourceMessage: e.message
      }
    });
  }
}

if (coreSupportsOnPluginInit === `stable`) {
  // need to conditionally export otherwise it throws an error for older versions
  exports.onPluginInit = initializePlugin;
} else if (coreSupportsOnPluginInit === `unstable`) {
  exports.unstable_onPluginInit = initializePlugin;
} else {
  exports.onPreInit = initializePlugin;
}