{"version":3,"file":"index.js","sources":["../src/partytown-context.tsx","../src/gatsby-script.tsx","../src/request-idle-callback-shim.ts"],"sourcesContent":["import { createContext } from \"react\"\nimport { ScriptProps } from \"./gatsby-script\"\n\nconst PartytownContext: React.Context<{\n  collectScript?: (script: ScriptProps) => void\n}> = createContext({})\n\nexport { PartytownContext }\n","import React, { useEffect, useContext } from \"react\"\nimport { PartytownContext } from \"./partytown-context\"\nimport type { ReactElement, ScriptHTMLAttributes } from \"react\"\nimport { requestIdleCallback } from \"./request-idle-callback-shim\"\n\nexport enum ScriptStrategy {\n  postHydrate = `post-hydrate`,\n  idle = `idle`,\n  offMainThread = `off-main-thread`,\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport interface ScriptProps\n  extends Omit<ScriptHTMLAttributes<HTMLScriptElement>, `onLoad` | `onError`> {\n  id?: string\n  strategy?: ScriptStrategy | `post-hydrate` | `idle` | `off-main-thread`\n  children?: string\n  onLoad?: (event: Event) => void\n  onError?: (event: ErrorEvent) => void\n  forward?: Array<string>\n}\n\nconst handledProps = new Set([\n  `src`,\n  `strategy`,\n  `dangerouslySetInnerHTML`,\n  `children`,\n  `onLoad`,\n  `onError`,\n])\n\nexport const scriptCache: Set<string> = new Set()\nexport const scriptCallbackCache: Map<\n  string,\n  {\n    load?: {\n      callbacks?: Array<(event: Event) => void>\n      event?: Event | undefined\n    }\n    error?: {\n      callbacks?: Array<(event: ErrorEvent) => void>\n      event?: ErrorEvent | undefined\n    }\n  }\n> = new Map()\n\nexport function Script(props: ScriptProps): ReactElement | null {\n  const { id, src, strategy = ScriptStrategy.postHydrate } = props || {}\n  const { collectScript } = useContext(PartytownContext)\n\n  useEffect(() => {\n    let details: IInjectedScriptDetails | null\n\n    switch (strategy) {\n      case ScriptStrategy.postHydrate:\n        details = injectScript(props)\n        break\n      case ScriptStrategy.idle:\n        requestIdleCallback(() => {\n          details = injectScript(props)\n        })\n        break\n      case ScriptStrategy.offMainThread:\n        if (collectScript) {\n          const attributes = resolveAttributes(props)\n          collectScript(attributes)\n        }\n        break\n    }\n\n    return (): void => {\n      const { script, loadCallback, errorCallback } = details || {}\n\n      if (loadCallback) {\n        script?.removeEventListener(`load`, loadCallback)\n      }\n\n      if (errorCallback) {\n        script?.removeEventListener(`error`, errorCallback)\n      }\n\n      script?.remove()\n    }\n  }, [])\n\n  if (strategy === ScriptStrategy.offMainThread) {\n    const inlineScript = resolveInlineScript(props)\n    const attributes = resolveAttributes(props)\n\n    if (typeof window === `undefined`) {\n      if (collectScript) {\n        collectScript(attributes)\n      } else {\n        console.warn(\n          `Unable to collect off-main-thread script '${\n            id || src || `no-id-or-src`\n          }' for configuration with Partytown.\\nGatsby script components must be used either as a child of your page, in wrapPageElement, or wrapRootElement.\\nSee https://gatsby.dev/gatsby-script for more information.`\n        )\n      }\n    }\n\n    if (inlineScript) {\n      return (\n        <script\n          type=\"text/partytown\"\n          data-strategy={strategy}\n          crossOrigin=\"anonymous\"\n          {...attributes}\n          dangerouslySetInnerHTML={{ __html: resolveInlineScript(props) }}\n        />\n      )\n    }\n    return (\n      <script\n        type=\"text/partytown\"\n        src={proxyPartytownUrl(src)}\n        data-strategy={strategy}\n        crossOrigin=\"anonymous\"\n        {...attributes}\n      />\n    )\n  }\n\n  return null\n}\n\ninterface IInjectedScriptDetails {\n  script: HTMLScriptElement | null\n  loadCallback: (event: Event) => void\n  errorCallback: (event: ErrorEvent) => void\n}\n\nfunction injectScript(props: ScriptProps): IInjectedScriptDetails | null {\n  const {\n    id,\n    src,\n    strategy = ScriptStrategy.postHydrate,\n    onLoad,\n    onError,\n  } = props || {}\n\n  const scriptKey = id || src\n\n  const callbackNames = [`load`, `error`]\n\n  const currentCallbacks = {\n    load: onLoad,\n    error: onError,\n  }\n\n  if (scriptKey) {\n    /**\n     * If a duplicate script is already loaded/errored, we replay load/error callbacks with the original event.\n     * If it's not yet loaded/errored, keep track of callbacks so we can call load/error callbacks for each when the event occurs.\n     */\n    for (const name of callbackNames) {\n      if (currentCallbacks?.[name]) {\n        const cachedCallbacks = scriptCallbackCache.get(scriptKey) || {}\n        const { callbacks = [] } = cachedCallbacks?.[name] || {}\n        callbacks.push(currentCallbacks?.[name])\n\n        if (cachedCallbacks?.[name]?.event) {\n          currentCallbacks?.[name]?.(cachedCallbacks?.[name]?.event)\n        } else {\n          scriptCallbackCache.set(scriptKey, {\n            ...cachedCallbacks,\n            [name]: {\n              callbacks,\n            },\n          })\n        }\n      }\n    }\n\n    // Avoid injecting duplicate scripts into the DOM\n    if (scriptCache.has(scriptKey)) {\n      return null\n    }\n  }\n\n  const inlineScript = resolveInlineScript(props)\n  const attributes = resolveAttributes(props)\n\n  const script = document.createElement(`script`)\n\n  if (id) {\n    script.id = id\n  }\n\n  script.dataset.strategy = strategy\n\n  for (const [key, value] of Object.entries(attributes)) {\n    script.setAttribute(key, value)\n  }\n\n  if (inlineScript) {\n    script.textContent = inlineScript\n  }\n\n  if (src) {\n    script.src = src\n  }\n\n  const wrappedCallbacks: Record<string, (event: Event | ErrorEvent) => void> =\n    {}\n\n  if (scriptKey) {\n    // Add listeners on injected scripts so events are cached for use in de-duplicated script callbacks\n    for (const name of callbackNames) {\n      const wrappedEventCallback = (event: Event | ErrorEvent): void =>\n        onEventCallback(event, scriptKey, name)\n      script.addEventListener(name, wrappedEventCallback)\n      wrappedCallbacks[`${name}Callback`] = wrappedEventCallback\n    }\n\n    scriptCache.add(scriptKey)\n  }\n\n  document.body.appendChild(script)\n\n  return {\n    script,\n    loadCallback: wrappedCallbacks.loadCallback,\n    errorCallback: wrappedCallbacks.errorCallback,\n  }\n}\n\nfunction resolveInlineScript(props: ScriptProps): string {\n  const { dangerouslySetInnerHTML, children = `` } = props || {}\n  const { __html: dangerousHTML = `` } = dangerouslySetInnerHTML || {}\n  return dangerousHTML || children\n}\n\nfunction resolveAttributes(props: ScriptProps): Record<string, string> {\n  const attributes: Record<string, string> = {}\n\n  for (const [key, value] of Object.entries(props)) {\n    if (handledProps.has(key)) {\n      continue\n    }\n    attributes[key] = value\n  }\n\n  return attributes\n}\n\nfunction proxyPartytownUrl(url: string | undefined): string | undefined {\n  if (!url) {\n    return undefined\n  }\n  return `/__third-party-proxy?url=${encodeURIComponent(url)}`\n}\n\nfunction onEventCallback(\n  event: Event | ErrorEvent,\n  scriptKey: string,\n  eventName: string\n): void {\n  const cachedCallbacks = scriptCallbackCache.get(scriptKey) || {}\n\n  for (const callback of cachedCallbacks?.[eventName]?.callbacks || []) {\n    callback(event)\n  }\n\n  scriptCallbackCache.set(scriptKey, { [eventName]: { event } })\n}\n","// https://developer.chrome.com/blog/using-requestidlecallback/#checking-for-requestidlecallback\n// https://github.com/vercel/next.js/blob/canary/packages/next/client/request-idle-callback.ts\n\nexport const requestIdleCallback =\n  (typeof self !== `undefined` &&\n    self.requestIdleCallback &&\n    self.requestIdleCallback.bind(window)) ||\n  function (cb: IdleRequestCallback): number {\n    const start = Date.now()\n    return setTimeout(function () {\n      cb({\n        didTimeout: false,\n        timeRemaining: function () {\n          return Math.max(0, 50 - (Date.now() - start))\n        },\n      })\n    }, 1) as unknown as number\n  }\n"],"names":["PartytownContext","ScriptStrategy","createContext","self","requestIdleCallback","bind","window","cb","Date","now","didTimeout","timeRemaining","max","start","props","id","src","strategy","postHydrate","load","onLoad","error","onError","scriptKey","callbackNames","currentCallbacks","name","scriptCallbackCache","get","cachedCallbacks","callbacks","push","_cachedCallbacks$name","event","_cachedCallbacks$name2","set","scriptCache","has","resolveInlineScript","resolveAttributes","document","createElement","script","dataset","Object","entries","attributes","setAttribute","inlineScript","textContent","eventName","callback","addEventListener","wrappedEventCallback","wrappedCallbacks","add","body","appendChild","loadCallback","errorCallback","children","dangerouslySetInnerHTML","__html","key","value","handledProps","url","encodeURIComponent","collectScript","useContext","useEffect","details","injectScript","idle","offMainThread","removeEventListener","remove","console","warn","React","type","crossOrigin","proxyPartytownUrl"],"mappings":"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"}